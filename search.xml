<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>如何在2DUI上生成3D模型的包围盒</title>
    <url>/p/8d386e7b10e2/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="前言">前言</h1>
<p>在实际开发中遇到了这个问题，需要判断一个3D模型在专用相机下的显示范围，将其展示在UI上。在这里记录一下实现步骤和代码。</p>
<h1 id="实现方法">实现方法</h1>
<ol type="1">
<li>从需要渲染的对象上获取Renderer组件（对于复杂的3D模型，一般得到的是<code>MeshRenderer</code>）</li>
<li>根据Renderer组件的bounds.center，bounds.extents计算出世界坐标的八个点</li>
<li>使用拍摄渲染对象的Camera调用接口<code>UnityEngine.Camera.WorldToScreenPoint</code>，获取八个点的屏幕坐标</li>
<li>遍历八个点，取出x方向与y方向的最大最小值，返回一个<code>Vector4(minX, minY, maxX, maxY)</code>，这个坐标即是3D模型在2DUI上的显示包围盒（bounds）</li>
<li>最后在UI层调整包围矩形的位置和大小即可</li>
</ol>
<span id="more"></span>
<h1 id="代码示例">代码示例</h1>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">     &#x2F;&#x2F; Static Toolkit Code
     &#x2F;&#x2F;&#x2F; &lt;summary&gt;
     &#x2F;&#x2F;&#x2F; calculate all worldCorners with bounds, and translate into screen point(minX, minY, maxX, maxY)
     &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;
     &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;target&quot;&gt;&lt;&#x2F;param&gt;
     &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;camera&quot;&gt;&lt;&#x2F;param&gt;
     &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;zTest&quot;&gt;if ture, x and y will be set to 0 if z less or equal than 0 if screen point&lt;&#x2F;param&gt;
     &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt;
     public static Vector4 GetScreenCorners(GameObject target, UnityEngine.Camera camera, bool zTest)
     &#123;
         var renderer &#x3D; target.GetComponentInChildren&lt;Renderer&gt;();
         if (renderer &#x3D;&#x3D; null)
         &#123;
             return Vector4.zero;
         &#125;

         var bounds &#x3D; renderer.bounds;
         var center &#x3D; bounds.center;
         var extents &#x3D; bounds.extents;

         var worldCorners &#x3D; new[]
         &#123;
             new Vector3(center.x - extents.x, center.y - extents.y, center.z - extents.z),
             new Vector3(center.x - extents.x, center.y - extents.y, center.z + extents.z),
             new Vector3(center.x - extents.x, center.y + extents.y, center.z - extents.z),
             new Vector3(center.x - extents.x, center.y + extents.y, center.z + extents.z),
             new Vector3(center.x + extents.x, center.y - extents.y, center.z - extents.z),
             new Vector3(center.x + extents.x, center.y - extents.y, center.z + extents.z),
             new Vector3(center.x + extents.x, center.y + extents.y, center.z - extents.z),
             new Vector3(center.x + extents.x, center.y + extents.y, center.z + extents.z),
         &#125;;

         var screenCornerArray &#x3D; new Vector3[8];
         for (int i &#x3D; 0; i &lt; 8; i++)
         &#123;
             screenCornerArray[i] &#x3D; camera.WorldToScreenPoint(worldCorners[i]);
             if (zTest &amp;&amp; screenCornerArray[i].z &lt;&#x3D; 0)
             &#123;
                 screenCornerArray[i].x &#x3D; 0;
                 screenCornerArray[i].y &#x3D; 0;
             &#125;
         &#125;
         
         var minX &#x3D; float.MaxValue;
         var minY &#x3D; float.MaxValue;
         var maxX &#x3D; float.MinValue;
         var maxY &#x3D; float.MinValue;
         for (int i &#x3D; 0; i &lt; screenCornerArray.Length; i++)
         &#123;
             var corner &#x3D; screenCornerArray[i];
             if (corner.x &lt; minX)
             &#123;
                 minX &#x3D; corner.x;
             &#125;

             if (corner.x &gt; maxX)
             &#123;
                 maxX &#x3D; corner.x;
             &#125;

             if (corner.y &lt; minY)
             &#123;
                 minY &#x3D; corner.y;
             &#125;

             if (corner.y &gt; maxY)
             &#123;
                 maxY &#x3D; corner.y;
             &#125;
         &#125;
         
         return new Vector4(minX, minY, maxX, maxY);
     &#125;

     &#x2F;&#x2F; UI Controller Code: Size adjustment
     private void OnTargetObjectScreenBoundsUpdate(object[] param)
     &#123;
         if (param.Length !&#x3D; 2)
         &#123;
             return;
         &#125;

         var targetName &#x3D; (string) param[0];
         var vec4 &#x3D; (Vector4) param[1];
         &#x2F;&#x2F; Debug.LogFormat(&quot;[ScreenCornerController.OnTargetObjectScreenBoundsUpdate] &#123;0&#125;&quot;, vec4);
         var centerX &#x3D; (vec4[2] + vec4[0]) &#x2F; 2;
         var centerY &#x3D; (vec4[3] + vec4[1]) &#x2F; 2;
         var width &#x3D; vec4[2] - vec4[0];
         var height &#x3D; vec4[3] - vec4[1];
         
         &#x2F;&#x2F; selectorImage&lt;UnityEngine.UI.Image&gt;
         selectorImage.rectTransform.anchoredPosition &#x3D; new Vector2(centerX, centerY);
         selectorImage.rectTransform.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, height);
         selectorImage.rectTransform.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, width);
&#x2F;&#x2F; selectorText&lt;TMPro.TextMeshProUGUI&gt;
         selectorText.text &#x3D; $&quot;&#123;targetName&#125;\nminX:&#123;vec4[0]&#125; minY:&#123;vec4[1]&#125;\nmaxX:&#123;vec4[2]&#125; maxY:&#123;vec4[3]&#125;&quot;;
         selectorImage.gameObject.SetActive(width &gt; 0.001f &amp;&amp; height &gt; 0.001f);
     &#125;</code></pre>
<h1 id="效果示例">效果示例</h1>
<a href="/p/8d386e7b10e2/3bounds2.gif" class="gallery-item"><img src="/p/8d386e7b10e2/3bounds2.gif" class="" title="UI包围盒的大小随着兔子模型绕z轴旋转而变化"></a>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script src="/js/lg-thumbnail.min.js"></script><script src="/js/lg-zoom.min.js"></script><script src="/js/lg-fullscreen.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>]]></content>
      <categories>
        <category>游戏开发</category>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>游戏开发</tag>
        <tag>计算机图形学</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Godot引擎贡献最佳实践</title>
    <url>/p/13902132f155/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>翻译自Godot引擎贡献指南，原文：<a
href="https://docs.godotengine.org/en/latest/contributing/development/best_practices_for_engine_contributors.html">best_practices_for_engine_contributors</a></p>
<h2 id="问题总要放在第一位">#1 问题总要放在第一位</h2>
<p>许多代码贡献者非常的有创造力，他们享受设计抽象数据结构，搭建优秀的交互界面的过程，又或许他们只是单纯地热爱编程。代码贡献者们总是有一些很酷的想法，但这些想法或许能、或许不能解决真实的问题。</p>
<figure>
<a href="https://s2.loli.net/2023/06/29/w19dxybmLja7ZMB.png" title="best_practices1" class="gallery-item"><img src="https://s2.loli.net/2023/06/29/w19dxybmLja7ZMB.png"
alt="best_practices1" /></a>
<figcaption aria-hidden="true">best_practices1</figcaption>
</figure>
<p>这就被称为<em>寻找问题的解决方案</em>。在理想的世界，它们也许并不有害，但在现实世界中，代码是需要时间去完成的，它们占用空间，而且一经存在就需要时间去维护。避免一切不必要的事物，在软件开发中一直被视作一种好的实践方式。</p>
<span id="more"></span>
<h2 id="问题要先存在才能被解决">#2 问题要先存在，才能被解决</h2>
<p>关联文章：<a
href="https://cerebralab.com/Imaginary_Problems_Are_the_Root_of_Bad_Software?utm_source=hackernewsletter&amp;utm_medium=email&amp;utm_term=fav">Imaginary
Problems Are the Root of Bad Software</a></p>
<p>这是前一种实践方式的变体。添加一切不必要的事物不是一个好主意，但怎么决定什么是“必要的”，什么又不是呢？</p>
<figure>
<a href="https://s2.loli.net/2023/06/29/6ZRbFksv27PajYV.png" title="best_practices2" class="gallery-item"><img src="https://s2.loli.net/2023/06/29/6ZRbFksv27PajYV.png"
alt="best_practices2" /></a>
<figcaption aria-hidden="true">best_practices2</figcaption>
</figure>
<p>答案是：问题要先存在，才能被解决。它不能是一种假想，或是一种认定。用户一定是在使用这个软件，来创造一些他们需要的东西。在此过程中，用户可能需要解决一个问题才能继续推进工作，或达到更高的产出。在这个情境下，<em>一个解决方案就是必须的了</em>。</p>
<p>“一些问题可能在未来发生，软件必须要在问题发生前做好准备”，这种想法被称为“面向未来”，以下就是一些很有象征性的想法：</p>
<ul>
<li>我认为这个方案会对用户很有帮助...</li>
<li>我认为用户最终会需要一个...</li>
</ul>
<p>这被普遍地认为是一个不好的习惯，因为试图解决一个当下不存在的问题，往往会产出一些从未被使用的代码，或者是一些比实际需要更复杂、更难维护的代码。</p>
<h2 id="问题需要是复杂或频繁的">#3 问题需要是复杂或频繁的</h2>
<p>软件的存在是为了解决问题，但是我们不能指望解决所有问题。作为一个游戏引擎，Godot会帮助你让游戏更好更快，但是它不能帮你把整个游戏做完。在这里，必须要划清界限。</p>
<figure>
<a href="https://s2.loli.net/2023/07/03/jTdZQzW7pyNG65c.png" title="best_practices3" class="gallery-item"><img src="https://s2.loli.net/2023/07/03/jTdZQzW7pyNG65c.png"
alt="best_practices3" /></a>
<figcaption aria-hidden="true">best_practices3</figcaption>
</figure>
<p>问题是否值得解决取决于解决问题所需要的付出。需要的付出取决于：</p>
<ul>
<li>问题的复杂度</li>
<li>问题的发生频率</li>
</ul>
<p>如果解决问题对用户来说过于复杂，软件应该为这个问题提供一个完善的解决方案。同样的，如果一个问题对用户来说很容易解决，提供一个解决方案就显得没有必要了。</p>
<p>一个例外是，如果用户频繁地遇到相同的问题，每次都需要自己来解决就会形成困扰。这种情况下，软件应该提供一种解决方案来简化用例。</p>
<p>一般来说判断一个问题是否复杂或频繁是很容易的，但有时也可能很困难。这就是为什么（在下一点）我们会推荐与其他开发者进行讨论。</p>
<h2 id="问题需要与他人一起讨论">#4 问题需要与他人一起讨论</h2>
<p>通常，当用户遇到问题时，他们往往沉浸在自己的项目中。这些用户会很自然地从他们的角度来解决问题，只考虑他们自己的用例。因此，用户提出的解决方案并不总是考虑所有的用例，往往偏向于用户自身的需求。</p>
<figure>
<a href="https://s2.loli.net/2023/07/03/Y4ZSJTuplaRBjL2.png" title="best_practices4" class="gallery-item"><img src="https://s2.loli.net/2023/07/03/Y4ZSJTuplaRBjL2.png"
alt="best_practices4" /></a>
<figcaption aria-hidden="true">best_practices4</figcaption>
</figure>
<p>开发者的角度又不一样了。他们可能会用户的问题过于独特，以至于无法给出一个合适的解决方案，或者他们可能会推荐一个能解决广泛问题的解决方案（更简单的，或者更低层次的API）来解决部分问题，而将剩下的部分留给用户。</p>
<p>无论如何，在尝试做出贡献之前，与其他开发者或者贡献者讨论实际问题是非常重要的，这样可以在实现上达成更好的一致。</p>
<p>唯一的例外当一块代码有一位明确商定的负责人，他直接与用户对话，并且有着能够直接实现解决方案的丰富知识。</p>
<p>值得一提的是，Godot的设计理念是偏好易用与可维护性，而不是性能。性能优化也会被纳入考量，但若它们让事情变得过于复杂，或者给代码库添加了太多复杂度，它们是不会被允许的。</p>
<h2 id="给每个问题属于它自己的解决方案">#5
给每个问题属于它自己的解决方案</h2>
<p>对程序员来说，寻找解决问题的最优解决方案一直一个享受的挑战。但是也很容易做过头。有些时候，贡献者会试图提出能解决尽可能多问题的解决方案。</p>
<p>当程序员试图让解决方案看起来更巧妙灵活，纯粹基于假定推测的问题也粉墨登场（如#2中描述的），情况往往急转直下。</p>
<figure>
<a href="https://s2.loli.net/2023/07/08/oPZMeT7CfkxbOzF.webp" title="best_practices5" class="gallery-item"><img src="https://s2.loli.net/2023/07/08/oPZMeT7CfkxbOzF.webp"
alt="best_practices5" /></a>
<figcaption aria-hidden="true">best_practices5</figcaption>
</figure>
<p>最主要的问题在于，现实生活中这样一般是行不通的。有时候，为每个问题提供它自己的独立的解决方案，往往能达到更精简，更可维护的代码。</p>
<p>更进一步地说，目标于解决独立问题的解决方案对用户来说是更好的。有确定目标的解决方案能够让用户找到他们确切需要的东西，而不需要为了简单的任务去学习一系列复杂的系统。</p>
<p>大而复杂的解决方案还有一个缺点在于，随着时间推移，它们仍然无法覆盖所有用户的需求。用户会提出更多需求，最终大大增加了API和代码库的复杂度。</p>
<h2 id="迎合常见用例也为罕见特例留下可能">#6
迎合常见用例，也为罕见特例留下可能</h2>
<p>这是前一部分的延续，进一步展开说明了这种为什么倾向于这样思考和设计软件的形式。</p>
<p>在先前也提到过了（#2），对我们来说（作为设计软件者）准确地理解所有未来用户的需求是非常困难的。试图一次性地完成一个能够迎合众多用例的结构灵活解决方案，往往是一个错误。</p>
<p>我们可能会提出一些我们认为很优秀的解决方案，但随后就发现用户甚至连其中一般的功能都不会用到，或者他们需求的功能并不能很好地融入到我们的初始设计中。这就导致我们必须扔掉整套解决方案，或者让它变得更加复杂。</p>
<p>问题在于，我们要如何去设计软件，才能同时满足当下已知的用户需求，以及未来未知的用户需求？</p>
<figure>
<a href="https://s2.loli.net/2023/07/08/FPaQHnVb5CAtfqW.webp" title="best_practices6" class="gallery-item"><img src="https://s2.loli.net/2023/07/08/FPaQHnVb5CAtfqW.webp"
alt="best_practices6" /></a>
<figcaption aria-hidden="true">best_practices6</figcaption>
</figure>
<p>答案即为，为了保证能够满足用户的需求，我们需要为他们提供可用的底层API，尽管对于他们来说可能需要重新实现一些已经存在的逻辑。</p>
<p>在现实生活中，这些用例无论如何都是非常罕见的，所以让用户去实现一个客制化的解决方案是有道理的。所以仍然将基础的构建块提供给用户，这一点是很重要的。</p>
<h2 id="倾向于本地解决方案">#7 倾向于本地解决方案</h2>
<p>在我么们为问题寻求一个解决方案时，可能是实现新功能或者修复一个bug，很多时候最简单的方法就是往核心层代码中添加数据或者一个新的函数。</p>
<p>这里最主要的问题在于，往核心层中添加一些只会在很远地方（很上层）使用的代码，不止会让代码更难读懂，还会让核心API更大更复杂，同样更难理解。</p>
<p>这是很糟糕的，因为核心API的可读性和清晰度一直是至关重要的，有大量的代码都建立在它之上，同时它也是新进代码贡献者学习代码库的起点。</p>
<figure>
<a href="https://s2.loli.net/2023/07/08/qgaOD3Mh9SWJtbG.webp" title="best_practices7" class="gallery-item"><img src="https://s2.loli.net/2023/07/08/qgaOD3Mh9SWJtbG.webp"
alt="best_practices7" /></a>
<figcaption aria-hidden="true">best_practices7</figcaption>
</figure>
<p>想要这样做的一个常见理由是，通常简单地往核心层加一个hack，代码改动量会比较小。</p>
<p>这样做是不被推荐的。一般来说，解决方案的的代码应该离发生问题的代码尽可能的近，尽管可能需要额外的，重复的，更加复杂或者更低效的代码。可能需要一些额外的创造性，但这一直是我们推崇的做法。</p>
<h2 id="不要为简单的问题使用复杂的罐装方案canned-solution">#8
不要为简单的问题使用复杂的罐装方案（canned solution）</h2>
<p>不是每个问题都有简单的解决方案，大多数情况下，正确的选择是使用一个第三方库来解决问题。</p>
<p>因为Godot需要移植到很多硬件平台上，我们不能动态地链接库。我们必须把这些库静态链接，打包进源码中。</p>
<figure>
<a href="https://s2.loli.net/2023/07/08/udXT5Y3yF9cLr7R.webp" title="best_practices8" class="gallery-item"><img src="https://s2.loli.net/2023/07/08/udXT5Y3yF9cLr7R.webp"
alt="best_practices8" /></a>
<figcaption aria-hidden="true">best_practices8</figcaption>
</figure>
<p>所以，我们对于接入地第三方库非常挑剔，我们倾向于更小的库（仅头文件的库是我们的最爱）。只有当别无选择的时候，我们才会将大的库打包进来。</p>
<p>库必须使用足够宽松的许可证才能被包含到 Godot 中。 可接受的许可证包括
Apache 2.0、BSD、MIT、ISC 和 MPL 2.0。 特别的是，我们不能接受根据 GPL 或
LGPL
许可的库，因为这些许可证实际上禁止专有软件中的静态链接（Godot大多数导出项目中都需要是静态链接的）。
这个要求也适用于编辑器，因为我们可能希望长期在 iOS 上运行它。 由于 iOS
不支持动态链接，因此静态链接是该平台上的唯一选择。</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script src="/js/lg-thumbnail.min.js"></script><script src="/js/lg-zoom.min.js"></script><script src="/js/lg-fullscreen.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>]]></content>
      <categories>
        <category>软件工程</category>
        <category>软件设计原则</category>
      </categories>
      <tags>
        <tag>Godot</tag>
        <tag>软件设计原则</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>《CLR via C#》Chapter4 类型基础</title>
    <url>/p/77589f7bf80e/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="第四章-类型基础">第四章 类型基础</h1>
<h2 id="所有类型都从system.object派生">4.1
所有类型都从System.Object派生</h2>
<h3 id="gethashcode-与-equals">GetHashCode() 与 Equals()</h3>
<p>如果对象要在哈希表集合中用作键使用，那么应该重写GetHashCode方法；如果两个对象具有相同的值，那么Equals应该返回true。</p>
<p>Object类的Equals和GetHashCode具体实现都是internalcall，由CLR实现，Equals源码实现可参考以下：</p>
<span id="more"></span>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;384294&#x2F;where-is-the-implementation-of-internalequalsobject-obja-object-objb
&#x2F;&#x2F; sscli20&#x2F;clr&#x2F;src&#x2F;vm&#x2F;comobject.cpp
&#x2F;&#x2F; 不过这份实现很老了，简单参考即可

FCIMPL2(FC_BOOL_RET, ObjectNative::Equals, Object *pThisRef, Object *pCompareRef)
&#123;
    CONTRACTL
    &#123;
        THROWS;
        DISABLED(GC_NOTRIGGER);
        INJECT_FAULT(FCThrow(kOutOfMemoryException););
        MODE_COOPERATIVE;
        SO_TOLERANT;          
    &#125;
    CONTRACTL_END;

    if (pThisRef &#x3D;&#x3D; pCompareRef) &#x2F;&#x2F; 同一个引用类型对象实例
        FC_RETURN_BOOL(TRUE);

    &#x2F;&#x2F; Since we are in FCALL, we must handle NULL specially.
    if (pThisRef &#x3D;&#x3D; NULL || pCompareRef &#x3D;&#x3D; NULL)
         FC_RETURN_BOOL(FALSE);

    MethodTable *pThisMT &#x3D; pThisRef-&gt;GetMethodTable();

    &#x2F;&#x2F; If it&#39;s not a value class, don&#39;t compare by value, &lt;- 只有值类型的对象才进行值比较
    if (!pThisMT-&gt;IsValueClass()) &#x2F;&#x2F; 不同的引用类型对象，在这里结束，返回False
         FC_RETURN_BOOL(FALSE);

    &#x2F;&#x2F; Make sure they are the same type.
    if (pThisMT !&#x3D; pCompareRef-&gt;GetMethodTable())
        FC_RETURN_BOOL(FALSE);

    &#x2F;&#x2F; Compare the contents (size - vtable - sink block index).
    BOOL ret &#x3D; memcmp(
        (void *) (pThisRef+1), 
        (void *) (pCompareRef+1), 
        pThisRef-&gt;GetMethodTable()-&gt;GetBaseSize() - sizeof(Object) - sizeof(int)) &#x3D;&#x3D; 0;

    FC_GC_POLL_RET();

    FC_RETURN_BOOL(ret);
&#125;
FCIMPLEND</code></pre>
<h3 id="new操作符会做什么">new操作符会做什么</h3>
<p>所有对象都用new操作符创建，new操作会做的事情有：</p>
<ol type="1">
<li>计算类型及其所有基类型定义的所有实例字段（即非静态字段）需要的字节数。堆上的每个对象需要一些额外的成员，包括<strong>类型对象指针（type
object pointer）</strong>和<strong>同步块索引（sync block
index）</strong>，CLR利用这些成员管理对象，额外成员的字节数也计入兑现大小</li>
<li>从托管堆中分配需求的字节数，分配的所有字节设为0</li>
<li>初始化对象的<strong>类型对象指针</strong>和<strong>同步块索引</strong>成员</li>
<li>调用类型的实例构造器，调用<strong>System.Object</strong>的构造器（此构造器什么都不做，简单返回）</li>
</ol>
<h2 id="类型转换">4.2 类型转换</h2>
<p>类型安全是CLR最重要的特性之一，运行时CLR总是知道对象的类型是什么</p>
<div class="note warning"><p>类型伪装是许多安全漏洞的根源，它还会破坏应用程序的稳定性和健壮性。因此，类型安全是CLR极其重要的一个特点。</p>
</div>
<p>C#不要求特殊语法
即可将对象转换为它的基类型，因为向基类型的转换被认为是安全隐式转换。然而转换为它的派生类型时，C#要求开发人员只能进行显示转换，因为转换可能在运行时失败。</p>
<div class="note info"><p>注意，命名空间和程序集不一定相关。同一个命名空间中的类型可能在不同程序集中实现，同一个程序集也可能包含不同命名空间中的类型。</p>
</div>
<h2 id="运行时的相互关系">4.4 运行时的相互关系</h2>
<div class="note info"><p>[复习][计算机组成原理]
当每个线程创建完成后都被分配一定大小的栈空间，用于存放局部变量，方法间传递参数，栈空间从高地址向低地址增长。方法调用时，<strong>参数</strong>，以及<strong>被调用方法结束时的返回地址</strong>会被压入栈中</p>
</div>
<h3 id="类型对象">类型对象</h3>
<p>前面提到每个堆上的对象都包括了<strong>类型对象指针（Type object
ptr）</strong>和<strong>同步块索引（sync block
index）</strong>，类型对象（type
object，即每个类型唯一的对象/实例）也是一样的</p>
<p>定义类型的<strong>静态成员</strong>时，用于存放这些静态内容的所有字节就存放在类型对象中</p>
<p>每个类型对象中还存放了方法表，方法表里记录了类型每一个方法的入口，需要补充的是这里并不区分静态方法和非静态方法。可以看到对于子类，方法表中仅有重写（override）了的方法。</p>
<figure>
<a href="https://s2.loli.net/2023/01/25/3tmkIhuFzGON7bn.png" title="Employee与Manager类的声明" class="gallery-item"><img src="https://s2.loli.net/2023/01/25/3tmkIhuFzGON7bn.png"
alt="Employee与Manager类的声明" /></a>
<figcaption aria-hidden="true">Employee与Manager类的声明</figcaption>
</figure>
<figure>
<a href="https://s2.loli.net/2023/01/25/cLj8t4deqmRYQW6.png" title="类型对象创建后的内存分配情况" class="gallery-item"><img src="https://s2.loli.net/2023/01/25/cLj8t4deqmRYQW6.png"
alt="类型对象创建后的内存分配情况" /></a>
<figcaption aria-hidden="true">类型对象创建后的内存分配情况</figcaption>
</figure>
<p>CLR会在方法执行前保证该方法依赖的所有类对象均已创建完毕（但是对于非JIT是否也是方法执行前创建，这个需要确认下）</p>
<h3 id="类型实例的创建与方法调用">类型实例的创建与方法调用</h3>
<p>[解惑]
CLR会自动将局部变量赋值为null或0，但编译器会将“对未赋值局部变量的使用”进行报错处理</p>
<p>举例示例中的Manager对象，分配在堆上，同样拥有<strong>类型对象指针（Type
object ptr）</strong>和<strong>同步块索引（sync block
index）</strong>，除此之外还有用于存放所有非静态字段/实例字段（instance
data fields）的许多字节，这些字段当然包含了基类定义的字段</p>
<p>最后new操作符会返回Manager对象在堆上的内存地址，存放在局部变量e中（e分配在栈上）</p>
<h4 id="静态方法的调用">静态方法的调用</h4>
<p>当调用一个类型的静态方法时，CLR先根据类型找到类型对象，再从类型对象的方法表中找到对应的方法进行调用。</p>
<h4 id="非静态方法的调用">非静态方法的调用</h4>
<p>当调用一个非虚方法（nonvirtual）时，CLR（原文为JIT
Compiler）将会直接根据变量的类型定位到对应类型的<strong>类型对象</strong>；如果在方法表中没有找到这个方法，CLR将会查看类型继承结构直到Object来寻找这个方法。每个类型对象都有一个字段指向它的基类，此内容并没有绘制到图中。</p>
<p>当调用一个虚方法时（virtual），会多执行一些代码：根据变量的类型对象指针找到对象的准确类型，并在此类型对象的方法表中查找方法入口。</p>
<figure>
<a href="https://s2.loli.net/2023/01/25/GgP6z4J1MQ5ZEnX.png" title="调用非虚方法GetYearsEmployed" class="gallery-item"><img src="https://s2.loli.net/2023/01/25/GgP6z4J1MQ5ZEnX.png"
alt="调用非虚方法GetYearsEmployed" /></a>
<figcaption aria-hidden="true">调用非虚方法GetYearsEmployed</figcaption>
</figure>
<p>值得一提的是，对于上述<code>Manager</code>和<code>Employee</code>两个类型对象，它们的类型对象指针也是在初始化时赋值的，它们的类型是<code>System.Type</code>，所以它们的类型对象指针指向的就是<code>System.Type</code>这个类型的类型对象。</p>
<p>而<code>System.Type</code>类型对象的类型对象指针指向它自己，毕竟这个对象也是一个<code>System.Type</code>类型的实例，结构如下图。</p>
<figure>
<a href="https://s2.loli.net/2023/01/25/nh5dGIwtLCyrSkE.png" title="System.Type类型的类型对象" class="gallery-item"><img src="https://s2.loli.net/2023/01/25/nh5dGIwtLCyrSkE.png"
alt="System.Type类型的类型对象" /></a>
<figcaption aria-hidden="true">System.Type类型的类型对象</figcaption>
</figure>
<p>最后回顾并复习一下，使用<code>System.Object</code>的<code>GetType()</code>方法可以返回存储在类型对象指针成员中的内容，从而确定任意对象的确切类型。</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script src="/js/lg-thumbnail.min.js"></script><script src="/js/lg-zoom.min.js"></script><script src="/js/lg-fullscreen.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>C#</tag>
        <tag>.NET</tag>
        <tag>CLR</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET source 系列：System.Collections.Generic.Dictionary</title>
    <url>/p/b1b59cb05264/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1
id="system.collections.generic.dictionary">System.Collections.Generic.Dictionary</h1>
<p>参考版本为 .net framework 4.8</p>
<p><a
href="https://referencesource.microsoft.com/#mscorlib/system/collections/generic/dictionary.cs">https://referencesource.microsoft.com/#mscorlib/system/collections/generic/dictionary.cs</a></p>
<h2 id="前言">前言</h2>
<p>避免犯先入为主的错，先简单 diff 一下和 mono 2.0 有什么不同</p>
<p>附件1：<a href="/p/b1b59cb05264/Dictionary_mono2.cs" title="Dictionary from mono-2-0">Dictionary from mono-2-0</a></p>
<p>附件2：<a href="/p/b1b59cb05264/Dictionary_dotnet48.cs" title="Dictionary from .net framework 4.8">Dictionary from .net framework 4.8</a></p>
<p>diff 结果：</p>
<a href="/p/b1b59cb05264/diff-mono2-with-dotnet48.png" class="gallery-item"><img src="/p/b1b59cb05264/diff-mono2-with-dotnet48.png" class="" title="mono2与dotnet48的实现差异"></a>
<p>只能说是完全不一样了。哈哈。</p>
<h2 id="net-framework-4.8">.net framework 4.8</h2>
<p>reference:</p>
<ul>
<li><a
href="https://blog.markvincze.com/back-to-basics-dictionary-part-1/">https://blog.markvincze.com/back-to-basics-dictionary-part-1/</a>
（longer: 4 parts）</li>
<li><a
href="https://www.yycoding.xyz/post/2023/7/2/details-of-dictionary-source-code-in-dotnet-core">https://www.yycoding.xyz/post/2023/7/2/details-of-dictionary-source-code-in-dotnet-core</a></li>
<li><a
href="https://dotnetos.org/blog/2022-03-28-dictionary-implementation/">https://dotnetos.org/blog/2022-03-28-dictionary-implementation/</a>（just
pics）</li>
</ul>
<h2 id="摘要">摘要</h2>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public class Dictionary&lt;TKey,TValue&gt;: IDictionary&lt;TKey,TValue&gt;, IDictionary, IReadOnlyDictionary&lt;TKey, TValue&gt;, ISerializable, IDeserializationCallback  &#123;

    private struct Entry &#123;
        public int hashCode;    &#x2F;&#x2F; Lower 31 bits of hash code, -1 if unused
        public int next;        &#x2F;&#x2F; Index of next entry, -1 if last
        public TKey key;           &#x2F;&#x2F; Key of entry
        public TValue value;         &#x2F;&#x2F; Value of entry
    &#125;

    private int[] buckets;
    private Entry[] entries;
    private int count;
    private int version;
    private int freeList;
    private int freeCount;
    private IEqualityComparer&lt;TKey&gt; comparer;
    private KeyCollection keys;
    private ValueCollection values;
    private Object _syncRoot;
    &#x2F;&#x2F; ...       
&#125;</code></pre>
<p>.NET中的Dictionary实现，是哈希表<strong>HashTable</strong>和<strong>LinkedList</strong>的组合，<strong>LinkedList</strong>被用于处理哈希冲突（拉链法
separate chaining）</p>
<ul>
<li>HashTable是一个用于存储Pair的数据结构，每个Pair都包含Key和Value。</li>
<li>HashTable的重要功能就是提供Key之后，要能很快地找到与Key值对应的Value。</li>
<li>HashTable会使用hash function来基于Key计算出下标。</li>
</ul>
<span id="more"></span>
<p>Dictionary中最重要的几个组成部分（字段）：</p>
<ul>
<li><strong>buckets(int[])</strong>：有相同hashcode的条目归属于同一个bucket。哈希结果取余之后得到这个
<code>buckets</code> 的下标，下标对应位置存储的是元素集合在
<code>entries</code> 中的第一个元素位置</li>
<li><strong>entries(Entry[])</strong>：Dicionary&lt;TKey, TValue&gt;
的元素集合</li>
<li><strong>freeList(int)</strong>：第一个空闲位置的下标</li>
<li><strong>freeCount(int)</strong>：Entry[] 中共有多少个空闲位置</li>
<li><strong>count(int)</strong>：Dictionary中的内部数组大小，注意并非有效元素个数。有效元素个数通过属性<strong>Count</strong>返回。</li>
<li><strong>version(int)</strong>：Dictionary的修改次数，容器的标记</li>
</ul>
<p>同时Entry也是Dictionary的一个重要结构，包含：</p>
<ul>
<li>Key与Value对象</li>
<li>哈希结果 <strong>hashCode</strong></li>
<li><strong>next</strong>：entries
中相同hashcode的下一个元素下标。如果next值为-1，即表示此元素为相同bucket集合中的最后一个元素</li>
</ul>
<a href="/p/b1b59cb05264/dictionary-layout.png" class="gallery-item"><img src="/p/b1b59cb05264/dictionary-layout.png" class="" title="Dictionary实现图示"></a>
<h2 id="主要行为">主要行为</h2>
<h3 id="构造函数-ctor">构造函数 ctor</h3>
<p>若不传入任何参数会以0为默认capacity调用 <code>Initialize()</code>
开辟空间，同时会使用 <code>EqualityComparer&lt;TKey&gt;.Default</code>
作为默认比较器，用于获取HashCode，以及判断Key之间是否相等。</p>
<p><strong>IEqualityComparer<TKey></strong> 只需要实现两个方法：</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; The generic IEqualityComparer interface implements methods to if check two objects are equal
&#x2F;&#x2F; and generate Hashcode for an object.
&#x2F;&#x2F; It is use in Dictionary class.  
public interface IEqualityComparer&lt;in T&gt;
&#123;
    bool Equals(T x, T y);
    int GetHashCode(T obj);                
&#125;</code></pre>
<h3 id="initializeint-capacity">Initialize(int capacity)</h3>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">private void Initialize(int capacity) &#123;
    int size &#x3D; HashHelpers.GetPrime(capacity);
    buckets &#x3D; new int[size];
    for (int i &#x3D; 0; i &lt; buckets.Length; i++) buckets[i] &#x3D; -1;
    entries &#x3D; new Entry[size];
    freeList &#x3D; -1;
&#125;</code></pre>
<p>此方法依赖 <code>HashHelpers.GetPrime(int min)</code>
来获取第一个大于<strong>capacity</strong>的质数。</p>
<p>类型 <strong>HashHelpers</strong> 中存在静态整型数组
<strong>primes，</strong>这是一个特别挑出的质数组成的质数表（为什么选了这些质数？值得研究下），以<strong>3</strong>开始，以<strong>7199369</strong>结束。若提供的min数字小于
primes 数组中最大值，那么简单地查表就能得到大于它的目标质数。</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; system\Collections\hashtable.cs:1711
        public static readonly int[] primes &#x3D; &#123;
            3, 7, 11, 17, 23, 29, 37, 47, 59, 71, 89, 107, 131, 163, 197, 239, 293, 353, 431, 521, 631, 761, 919,
            1103, 1327, 1597, 1931, 2333, 2801, 3371, 4049, 4861, 5839, 7013, 8419, 10103, 12143, 14591,
            17519, 21023, 25229, 30293, 36353, 43627, 52361, 62851, 75431, 90523, 108631, 130363, 156437,
            187751, 225307, 270371, 324449, 389357, 467237, 560689, 672827, 807403, 968897, 1162687, 1395263,
            1674319, 2009191, 2411033, 2893249, 3471899, 4166287, 4999559, 5999471, 7199369&#125;;

&#x2F;&#x2F; System.Collections.HashHelpers.GetPrime
&#x2F;&#x2F; system\Collections\hashtable.cs:1754
        public static int GetPrime(int min) 
        &#123;
            if (min &lt; 0)
                throw new ArgumentException(Environment.GetResourceString(&quot;Arg_HTCapacityOverflow&quot;));
            Contract.EndContractBlock();

            for (int i &#x3D; 0; i &lt; primes.Length; i++) 
            &#123;
                int prime &#x3D; primes[i];
                if (prime &gt;&#x3D; min) return prime;
            &#125;

            &#x2F;&#x2F;outside of our predefined table. 
            &#x2F;&#x2F;compute the hard way. 
            for (int i &#x3D; (min | 1); i &lt; Int32.MaxValue;i+&#x3D;2) 
            &#123;
                if (IsPrime(i) &amp;&amp; ((i - 1) % Hashtable.HashPrime !&#x3D; 0))
                    return i;
            &#125;
            return min;
        &#125;</code></pre>
<p>否则，<code>GetPrime()</code> 方法将回退到朴素的质数查找：从
<code>min | 1</code> 开始直到
<code>Int32.MaxValue</code>，进行步长为2的遍历，判断每个数字是否是质数
<code>HashHelpers.IsPrime(int candidate)</code>。注意，这个判断方法涉及平方根操作，与一个时间复杂度为<span
class="math inline">\(\bf{O}(\sqrt{\bf{n}})\)</span>的循环。</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; System.Collections.HashHelpers.IsPrime
&#x2F;&#x2F; system\Collections\hashtable.cs:1738
        public static bool IsPrime(int candidate) 
        &#123;
            if ((candidate &amp; 1) !&#x3D; 0) 
            &#123;
                int limit &#x3D; (int)Math.Sqrt (candidate);
                for (int divisor &#x3D; 3; divisor &lt;&#x3D; limit; divisor+&#x3D;2)
                &#123;
                    if ((candidate % divisor) &#x3D;&#x3D; 0)
                        return false;
                &#125;
                return true;
            &#125;
            return (candidate &#x3D;&#x3D; 2);
        &#125;</code></pre>
<h3 id="插入元素-addtkey-key-tvalue-value-索引器">插入元素 Add(TKey key,
TValue value) / 索引器</h3>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public TValue this[TKey key] &#123;
    get &#123;
        int i &#x3D; FindEntry(key);
        if (i &gt;&#x3D; 0) return entries[i].value;
        ThrowHelper.ThrowKeyNotFoundException();
        return default(TValue);
    &#125;
    set &#123;
        Insert(key, value, false);
    &#125;
&#125;

public void Add(TKey key, TValue value) &#123;
    Insert(key, value, true);
&#125;</code></pre>
<p>因为Dictionary实现了非泛型版本的IDictionary，所以也有<code>Add(object key, object value)</code>这样的方法，但也只是在<code>Add(TKey key, TValue value)</code>的基础上新增了类型转换和一些错误检查而已。</p>
<p>方法<code>Add(TKey key, TValue value)</code>依赖方法<code>Insert(TKey key, TValue value, bool add)</code>的实现，参数<strong>add</strong>就是用来区分调用是否来自于<code>Add()</code>方法。在.net源码中看到这样的标识方法还挺意外的…</p>
<p>另外一个依赖方法<code>Insert()</code>的插入元素方法就是使用索引器
<code>this[TKey key]</code>，这时传入的参数add就会是false。一直以来的使用经验也告诉我们传不同参数会带来什么不同了：当调用Add()方法时，若key已存在会<strong>抛出异常</strong>，而使用索引器能够直接覆盖此key对应的内容。</p>
<h3 id="插入元素-inserttkey-key-tvalue-value-bool-add">插入元素
Insert(TKey key, TValue value, bool add)</h3>
<p><code>Insert()</code>
方法将新元素插入到<strong>entries</strong>中，选择性地使用freeList，相应地更新<strong>buckets</strong>，并且可能造成扩容行为。</p>
<p>若当前的<strong>buckets</strong>在Dictionary构造后还没有进行过初始化，那么会使用0作为初始容量进行初始化，按照上面的信息，我们应该能得到一个大小为3的buckets。</p>
<p><strong>获取buckets中下标</strong></p>
<p>插入的元素通过<strong>comparer</strong>以及自己的key得到hashcode后，通过对<code>buckets.Length</code>取余得到目标bucket在数组中的下标<strong>targetBucket</strong>。</p>
<p><strong>查找entries中下标</strong></p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">for (int i &#x3D; buckets[targetBucket]; i &gt;&#x3D; 0; i &#x3D; entries[i].next) &#123;
    if (entries[i].hashCode &#x3D;&#x3D; hashCode &amp;&amp; comparer.Equals(entries[i].key, key)) &#123;
        if (add) &#123; 
            ThrowHelper.ThrowArgumentException(ExceptionResource.Argument_AddingDuplicate);
        &#125;
        entries[i].value &#x3D; value;
        version++;
        return;
    &#125; 
    
    &#x2F;&#x2F; 记录发生冲突的次数，这实际上是用于 FEATURE_RANDOMIZED_STRING_HASHING
    collistionCount++;
&#125;</code></pre>
<p>接下来会通过一个在Dictionary实现中很常见的循环，来查找是否存在一个hashcode与key均相等的元素，如果存在则说明添加了key重复的value，便根据此次<code>Insert</code>是否来源于<code>Add</code>来决定是要抛出异常，还是覆盖原值并更新version。</p>
<p>若不存在这样的元素，那么便可以考虑将新元素加入到Dictionary中：</p>
<ul>
<li>如果freeCount尚有剩余，那么使用freeList的队首元素下标，freeList队首后移，更新freeCount，而不更新<strong>count</strong></li>
<li>否则直接使用当前元素count为下标索引entries，更新<strong>count</strong>
<ul>
<li>注意，当<strong>entries</strong>已满时（<code>count == entries.Length</code>），发生扩容<code>Resize()</code>以及targetBucket的重新计算，毕竟现在的<code>buckets.Length</code>已经不同了</li>
</ul></li>
</ul>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">entries[index].hashCode &#x3D; hashCode;
entries[index].next &#x3D; buckets[targetBucket];
entries[index].key &#x3D; key;
entries[index].value &#x3D; value;
buckets[targetBucket] &#x3D; index;
version++;</code></pre>
<p>最后，通过上述步骤得到的index，设置entries[index]的各种key / hashcode
/
value信息，将此entries[index]设置为targetBucket的队首（buckets[targetBucket]
→ new_entry.next → previous_entry）。</p>
<p><strong>FEATURE_RANDOMIZED_STRING_HASHING</strong></p>
<p>如果上述提到的冲突次数大于<strong>HashHelpers.HashCollisionThreshold</strong>（100）次，且当前comparer被判定为“WellKnownEqualityComparer”，则会为当前Dictionary选择一个<strong>RandomziedEqualityComparer</strong>，之后对Dictionary进行<code>Resize</code>，并且<strong>forceNewHashCodes</strong>，使用新的comparer来计算hashcode</p>
<p>举例在mscorlib中就能找到System/StringComparer.cs，其中包含了
<strong>CultureAwareRandomizedComparer</strong>，<strong>OrdinalRandomizedComparer</strong>
等comparer，这里就先不展开了。</p>
<h3 id="扩容-resize">扩容 Resize()</h3>
<p><code>Resize()</code>
方法会用一个大于当前元素个数两倍的质数，来对当前字典进行扩容。</p>
<p>默认无参的Resize()方法会根据当前的有效元素个数count，调用方法
<code>HashHelpers.ExpandPrime</code>。</p>
<p><code>HashHelpers.ExpandPrime(int oldSize)</code>
的行为逻辑为简单地将 <strong>oldSize</strong> x 2 得到
<strong>newSize</strong>，做一个越界检查（此处对比的常量为
<strong>HashHelpers.MaxPrimeArrayLength / 0x7FEFFFFD /
2146435069</strong>），接着并将 <strong>newSize</strong> 传入方法
<code>HashHelpers.GetPrime</code>
得到比它更大的质数，最后将此结果用于调用方法
<code>Resize(int newSize, bool forceNewHashCodes)</code>。</p>
<h3 id="扩容-resizeint-newsize-bool-forcenewhashcodes">扩容 Resize(int
newSize, bool forceNewHashCodes)</h3>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">private void Resize(int newSize, bool forceNewHashCodes) &#123;
    Contract.Assert(newSize &gt;&#x3D; entries.Length);
    int[] newBuckets &#x3D; new int[newSize];
    for (int i &#x3D; 0; i &lt; newBuckets.Length; i++) newBuckets[i] &#x3D; -1;
    Entry[] newEntries &#x3D; new Entry[newSize];
    Array.Copy(entries, 0, newEntries, 0, count);
    if(forceNewHashCodes) &#123;
        for (int i &#x3D; 0; i &lt; count; i++) &#123;
            if(newEntries[i].hashCode !&#x3D; -1) &#123;
                newEntries[i].hashCode &#x3D; (comparer.GetHashCode(newEntries[i].key) &amp; 0x7FFFFFFF);
            &#125;
        &#125;
    &#125;
    &#x2F;&#x2F; pay attention to this loop
    for (int i &#x3D; 0; i &lt; count; i++) &#123;
        int bucket &#x3D; newEntries[i].hashCode % newSize;
        newEntries[i].next &#x3D; newBuckets[bucket];
        newBuckets[bucket] &#x3D; i;
    &#125;
    buckets &#x3D; newBuckets;
    entries &#x3D; newEntries;
&#125;</code></pre>
<p>方法内部按照新的size大小开辟了两个新数组，分别是
<strong>buckets</strong> 和
<strong>entries</strong>。<strong>buckets</strong>的每个成员都会被初始化为-1。而对
<strong>entries</strong>，则是先进行了已有 count 个条目的
<code>Array.Copy</code>。</p>
<p>如果方法传入了<strong>forceNewHashCodes</strong>，那么每个entry的hashcode都会基于字典内部的comparer以及entry的key重新计算一遍。</p>
<p>很有意思的是方法内部通过一个循环来重置了<code>Resize</code>操作后的<strong>buckets</strong>以及<strong>entries</strong>链表，而循环体的实现可以同时应对两种情况：</p>
<ul>
<li>对那些对应bucket为空的entry，entry的next会被设置为-1，之后这个bucket会指向这个entry；</li>
<li>对那些对应bucket不为空的entry（即存在其他相同hashcode的entry），entry的next会被设置为bucket指向的同hashcode
entry，随后bucket同样会指向这个entry。</li>
</ul>
<p>这样一来，新的entry总是被插入到bucket指向的队首。</p>
<h3 id="移除元素-removetkey-key">移除元素 Remove(TKey key)</h3>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public bool Remove(TKey key) &#123;
    if(key &#x3D;&#x3D; null) &#123;
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);
    &#125;

    if (buckets !&#x3D; null) &#123;
        int hashCode &#x3D; comparer.GetHashCode(key) &amp; 0x7FFFFFFF;
        int bucket &#x3D; hashCode % buckets.Length;
        int last &#x3D; -1;
        for (int i &#x3D; buckets[bucket]; i &gt;&#x3D; 0; last &#x3D; i, i &#x3D; entries[i].next) &#123;
            if (entries[i].hashCode &#x3D;&#x3D; hashCode &amp;&amp; comparer.Equals(entries[i].key, key)) &#123;
                if (last &lt; 0) &#123;
                    buckets[bucket] &#x3D; entries[i].next;
                &#125;
                else &#123;
                    entries[last].next &#x3D; entries[i].next;
                &#125;
                entries[i].hashCode &#x3D; -1;
                entries[i].next &#x3D; freeList;
                entries[i].key &#x3D; default(TKey);
                entries[i].value &#x3D; default(TValue);
                freeList &#x3D; i;
                freeCount++;
                version++;
                return true;
            &#125;
        &#125;
    &#125;
    return false;
&#125;</code></pre>
<p>当Remove操作发生时：</p>
<p>维护 <strong>buckets</strong> / <strong>entries</strong> 链表：</p>
<ul>
<li>如果移除的entry是此hashcode对应的bucket指向的首个entry，那么需要更新bucket的值</li>
<li>如果不是bucket指向的entry，那么需要更新同hashcode的指向这个entry的上一entry存储的next</li>
</ul>
<p>维护空闲队列，freeList / freeCount 更新操作发生：</p>
<ul>
<li>被移除的entry，其next会指向当前freeList，即旧的freeList队首</li>
<li>freeList指向被移除的entry，此空闲entry现在变成freeList的队首元素</li>
<li>freeCount / version 递增</li>
</ul>
<p>注意也是这个方法内表明了，
当Entry被移除时，hashCode会被标记为-1，这也是根据<strong>comparer</strong>获取HashCode后总是要取低31位的原因。</p>
<h3 id="查找元素-containskeytkey-key-containsvaluetvalue-value">查找元素
ContainsKey(TKey key) / ContainsValue(TValue value)</h3>
<p><code>ContainsKey</code> 的实现是基于方法
<code>FindEntry(TKey key)</code> 的，而 <code>ContainsValue</code>
的实现是一个简单的对<strong>entries</strong>的遍历，对于非null的目标value，会使用当前TValue类型的DefaultEqualityComparer进行比较。</p>
<p><code>FindEntry(TKey key)</code>
的实现是先基于key获取hashcode，再从<strong>buckets</strong>索引到entries的起始位置，接下来根据每个entry的next遍历整个数组中的链表，进行key的相等判定。</p>
<p>对字典的直接索引方法 dict[key] 也是基于方法
<code>FindEntry(TKey key)</code>
的，这里就不赘述了，唯一需要注意的是索引方法在找不到对应key时会直接<strong>抛出异常</strong>，想要安全的获取值，推荐的是下述<code>TryGetValue</code>方法。</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public TValue this[TKey key] &#123;
    get &#123;
        int i &#x3D; FindEntry(key);
        if (i &gt;&#x3D; 0) return entries[i].value;
        ThrowHelper.ThrowKeyNotFoundException();
        return default(TValue);
    &#125;
    set &#123;
        Insert(key, value, false);
    &#125;
&#125;</code></pre>
<h3 id="获取元素-trygetvaluetkey-key-out-tvalue-value">获取元素
TryGetValue(TKey key, out Tvalue value)</h3>
<p>TryGetValue 方法同样基于
<code>FindEntry(TKey key)</code>，只是其结果通过 out
关键字返回，而key是否在字段中的结果会使用bool结果返回。</p>
<h2 id="迭代器-enumerator">迭代器 Enumerator</h2>
<p>字典中存在三个可遍历的对象，分别是
<strong>Dictionary&lt;TKey,TValue&gt;.Enumerator</strong>，<strong>Dictionary&lt;TKey,TValue&gt;.KeyCollection</strong>，以及
<strong>Dictionary&lt;TKey,TValue&gt;.ValueCollection</strong>
分别可通过字典的 GetEnumerator，以及 Keys，Values 属性返回。</p>
<p>其中 <strong>Dictionary&lt;TKey,TValue&gt;.Enumerator</strong>
为struct，而<strong>KeyCollection</strong>与<strong>ValueCollection</strong>均为class，且存在相应的内部成员，会在第一次获取的时候发生实例化及堆内存分配。<strong>KeyCollection</strong>
与 <strong>ValueCollection</strong> 均存在自己的内部 Enumerator
声明。</p>
<p>值得一提的是三者的 Dispose()
方法中均为空，没有重要弃置的外部资源。</p>
<h3
id="dictionarytkeytvalue.enumerator">Dictionary&lt;TKey,TValue&gt;.Enumerator</h3>
<p>持有当前dictionary引用。</p>
<p>调用方法 MoveNext() 时会基于 entries 进行遍历，遍历过程中只有
<code>hashcode ≥ 0</code> 的条目会被返回，即只会遍历有效条目。方法内会将
version，遍历下标 index，以及当前KeyValuePair&lt;TKey, TValue&gt;
(struct) 作为自身成员保存。</p>
<p>当前遍历的键值对为struct，可不用担心堆内存分配，此结果被保存在
<strong>current</strong> 成员中，也是 <strong>Current</strong>
属性的返回结果。</p>
<h3 id="keycollection-valuecollection">KeyCollection /
ValueCollection</h3>
<p>两者返回的Enumerator，及其遍历过程均与字典自身返回KeyValuePair的Enumerator无太大差异，下面直接贴上代码进行比较。</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; Dictionary&lt;TKey,TValue&gt;.Enumerator.MoveNext
public bool MoveNext() &#123;
    &#x2F;&#x2F; ...

    &#x2F;&#x2F; 使用uint转换比较，可以保证即使dicionary.count为Int32.MaxValue，
    &#x2F;&#x2F; 遍历结束后将index设置为count+1（int下为负值），后续也不会通过这个判断式进入while块
    while ((uint)index &lt; (uint)dictionary.count) &#123;
        if (dictionary.entries[index].hashCode &gt;&#x3D; 0) &#123;
            current &#x3D; new KeyValuePair&lt;TKey, TValue&gt;(dictionary.entries[index].key, dictionary.entries[index].value);
            index++;
            return true;
        &#125;
        index++;
    &#125;

    index &#x3D; dictionary.count + 1;
    current &#x3D; new KeyValuePair&lt;TKey, TValue&gt;();
    return false;
&#125;

    &#x2F;&#x2F; Dictionary&lt;TKey,TValue&gt;.KeyCollection.Enumerator.MoveNext
    public bool MoveNext() &#123;
        &#x2F;&#x2F; ...

        while ((uint)index &lt; (uint)dictionary.count) &#123;
            if (dictionary.entries[index].hashCode &gt;&#x3D; 0) &#123;
                currentKey &#x3D; dictionary.entries[index].key;
                index++;
                return true;
            &#125;
            index++;
        &#125;

        index &#x3D; dictionary.count + 1;
        currentKey &#x3D; default(TKey);
        return false;
    &#125;
    
    &#x2F;&#x2F; Dictionary&lt;TKey,TValue&gt;.ValueCollection.Enumerator.MoveNext
    public bool MoveNext() &#123;                    
        if (version !&#x3D; dictionary.version) &#123;
            ThrowHelper.ThrowInvalidOperationException(ExceptionResource.InvalidOperation_EnumFailedVersion);
        &#125;
        
        while ((uint)index &lt; (uint)dictionary.count) &#123;
            if (dictionary.entries[index].hashCode &gt;&#x3D; 0) &#123;
                currentValue &#x3D; dictionary.entries[index].value;
                index++;
                return true;
            &#125;
            index++;
        &#125;
        index &#x3D; dictionary.count + 1;
        currentValue &#x3D; default(TValue);
        return false;
    &#125;</code></pre>
<h2 id="可借鉴之处">可借鉴之处</h2>
<p>记录一些在阅读 .net framework 4.8 的 Dictionary
源码过程中，觉得未来在设计数据结构可以参照学习的要点:</p>
<ul>
<li>存储Dictionary的Value的实体<strong>Entry</strong>被设计为了值类型，而不是引用类型。一般而言，对于基本的数据类型或者纯字段或者小于16个字节的，设计为struct，而不是class能够明显提高内存局部性，并且能极大减少GC压力。</li>
<li>特别地，相比class数组，struct数组的内存局部性有极大的优势。</li>
<li>删除Dictionary某个key对应的元素，只是将<strong>entries</strong>中对应的元素移到了空闲列表中，在下次插入时，优先把数据分配到空闲列表上。这样一定程度上能减少page交换，和新的内存注销和分配。</li>
<li>这种技巧在C++编程语言中广泛存在，由于在非托管语言中，内存的注销和分配是一个相对来说比较耗资源的操作，所以这种内存留用操作非常普遍。</li>
<li>在判断链表是否到达尽头时，即next是否为-1时，对于普通储值的链表，直接将-1转换为uint，然后跟<strong>entries</strong>的length做比较，这里利用了负数转为无符号整型会溢出成为非常大的整数的特性。</li>
</ul>
<h2 id="mono-2.0-dictionary-allocation">mono 2.0 Dictionary
Allocation</h2>
<p>在这里额外记录一个个人觉得在比较过时的.NET环境开发中需要注意的点，就是字典在初始化以及扩容时带来的较大内存开销，从初始化的两个重要方法中我们可以看到：</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">const int INITIAL_SIZE &#x3D; 10;
const float DEFAULT_LOAD_FACTOR &#x3D; (90f &#x2F; 100);

private void Init (int capacity, IEqualityComparer&lt;TKey&gt; hcp)
&#123;
    if (capacity &lt; 0)
        throw new ArgumentOutOfRangeException (&quot;capacity&quot;);
    this.hcp &#x3D; (hcp !&#x3D; null) ? hcp : EqualityComparer&lt;TKey&gt;.Default;
    if (capacity &#x3D;&#x3D; 0)
        capacity &#x3D; INITIAL_SIZE;

    &#x2F;* Modify capacity so &#39;capacity&#39; elements can be added without resizing *&#x2F;
    capacity &#x3D; (int)(capacity &#x2F; DEFAULT_LOAD_FACTOR) + 1;
    
    InitArrays (capacity);
    generation &#x3D; 0;
&#125;

private void InitArrays (int size) &#123;
    table &#x3D; new int [size];

    linkSlots &#x3D; new Link [size];
    emptySlot &#x3D; NO_SLOT;

    keySlots &#x3D; new TKey [size];
    valueSlots &#x3D; new TValue [size];
    touchedSlots &#x3D; 0;

    threshold &#x3D; (int)(table.Length * DEFAULT_LOAD_FACTOR);
    if (threshold &#x3D;&#x3D; 0 &amp;&amp; table.Length &gt; 0)
        threshold &#x3D; 1;
&#125;</code></pre>
<p>可以看到一般来说若没有传入初始容量，或者传入0，直接的结果就是导致计算初始容量时将得到12，且在InitArrays中将分配四个数组，分别负责：</p>
<ol type="1">
<li>table：存储取余后的hashcode，到linkSlots下标的映射，这个下标同样用于索引keySlots与valueSlots。</li>
<li>linkSlots：存储计算hashcode结果以及next信息</li>
<li>keySlots：键内容的存储数组</li>
<li>valueSlots：值内容的存储数组</li>
</ol>
<p>因此如果有把握此字典被插入的元素并不多（甚至仅有一个元素），或许可以考虑一开始就传入初始容量1，这样至少分配的数组的大小是最小的。</p>
<p>测试代码示例：</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public class DictionaryAllocationTest : MonoBehaviour
&#123;
    private Dictionary&lt;uint, GameObject&gt; m_Objects;
    &#x2F;&#x2F; Start is called before the first frame update
    void Start()
    &#123;
        m_Objects &#x3D; new Dictionary&lt;uint, GameObject&gt;();
        for (int i &#x3D; 0; i &lt; 14; i++)
        &#123;
            m_Objects.Add((uint)i, null);
        &#125;
    &#125;
&#125;</code></pre>
<p><code>Start()</code>
中构造函数执行完毕，尚未进行元素插入的debug结果：</p>
<a href="/p/b1b59cb05264/mono2-dict-after-ctor.png" class="gallery-item"><img src="/p/b1b59cb05264/mono2-dict-after-ctor.png" class="" title="构造函数之后的内部数组情况"></a>
<p>而当插入12个元素后，内部数组将同步扩容到37：</p>
<a href="/p/b1b59cb05264/mono2-dict-after-12inserts.png" class="gallery-item"><img src="/p/b1b59cb05264/mono2-dict-after-12inserts.png" class="" title="抵达容量限制扩容后的内部数组情况"></a>
<p>而在上述更新版本的字典实现中，无论是初始化大小，还是扩容速度，都要更为保守。</p>
<p>因此需要注意当自己在版本老旧的.NET环境开发，且代码运行在内存资源吃紧的场景下时，要慎用Dictionary。</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script src="/js/lg-thumbnail.min.js"></script><script src="/js/lg-zoom.min.js"></script><script src="/js/lg-fullscreen.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>.NET</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET source 系列：System.Collections.Generic.LinkedList</title>
    <url>/p/4c13c2dd8346/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="net-source-linkedlist">[.NET source] LinkedList</h1>
<p>namespace: System.Collections.Generic.LinkedList</p>
<p>project: ndp.csproj</p>
<p>file: <a
href="https://referencesource.microsoft.com/#System/compmod/system/collections/generic/linkedlist.cs,df5a6c7b6b60da4f">linkedlist.cs</a></p>
<p>version: 参考版本为属于 .net standard 2.0 的 .NET Framework 4.8</p>
<h2 id="摘要">摘要</h2>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public class LinkedList&lt;T&gt;: ICollection&lt;T&gt;, System.Collections.ICollection
       ,ISerializable, IDeserializationCallback 
&#123;
    internal LinkedListNode&lt;T&gt; head;
    internal int count;
    internal int version;
    private Object _syncRoot;

    &#x2F;&#x2F; serialization ...
&#125;

public sealed class LinkedListNode&lt;T&gt; &#123;
    internal LinkedList&lt;T&gt; list;
    internal LinkedListNode&lt;T&gt; next;
    internal LinkedListNode&lt;T&gt; prev;
    internal T item;
    
    public LinkedListNode( T value) &#123;
        this.item &#x3D; value;
    &#125;

    internal LinkedListNode(LinkedList&lt;T&gt; list, T value) &#123;
        this.list &#x3D; list;
        this.item &#x3D; value;
    &#125;

    public LinkedListNode&lt;T&gt; Next &#123;
        get &#123; return next &#x3D;&#x3D; null || next &#x3D;&#x3D; list.head? null: next;&#125;
    &#125;

    public LinkedListNode&lt;T&gt; Previous &#123;
        get &#123; return prev &#x3D;&#x3D; null || this &#x3D;&#x3D; list.head? null: prev;&#125;
    &#125;
    &#x2F;&#x2F; ...    
&#125;  </code></pre>
<blockquote>
<p>This LinkedList is a doubly-Linked circular list.</p>
</blockquote>
<p>LinkedList 的实现符合常见的链表数据结构设计，且 LinkedList
实现的是通用性更强的双向、环状（<code>head→prev == tail</code>,
<code>tail→next == head</code>）列表，阅读源码的过程更像是指针操作的一次复习。</p>
<p>LinkedList 能够返回节点个数 <strong>count</strong>，以及链表的头节点
<strong>First</strong>，尾节点 <strong>Last</strong>
(<code>head.prev</code>)</p>
<span id="more"></span>
<h2 id="对外方法">对外方法</h2>
<h3 id="构造函数-ctor">构造函数 ctor</h3>
<ol type="1">
<li>存在无参，以及接受 IEnumerable&lt;T&gt; 两个版本的构造函数</li>
<li>接受 IEnumerable&lt;T&gt; 的构造函数依赖的是方法
<code>LinkedList&lt;T&gt;.AddLast</code></li>
</ol>
<h3 id="空链表判断">空链表判断</h3>
<p>可以通过简单的 <code>head == null</code> 判断当前链表是否为空</p>
<h3 id="头尾插入节点-addfirst-addlast">头尾插入节点 AddFirst /
AddLast</h3>
<p>头尾插入元素的方法都支持插入值 <code>(T value)</code> 以及插入节点
<code>(LinkedListNode&lt;T&gt; node)</code> 的版本。</p>
<p><strong>AddFirst</strong> 操作对于空链表情况，内部实现为
<code>InternalInsertNodeToEmptyList(node)</code>，对于非空链表，内部实现为
<code>InternalInsertNodeBefore(head, node)</code>，即将节点node插入到头指针head之前，之后再把指针的头节点设置为传入的node。</p>
<p><strong>AddLast</strong> 操作的巧妙之处在于方法实现与
<strong>AddFirst</strong>
基本是一致的，唯一差异在于链表非空的情况下，在<code>InternalInsertNodeBefore(head, node)</code>
之后，少了一步把头节点设置为传入的node，这样新插入的节点就自然在链表的最末尾了，因为在双向指针中我们有
<code>head → prev == tail</code></p>
<h3 id="前后插入节点-addafter-addbefore">前后插入节点 AddAfter /
AddBefore</h3>
<p>AddAfter 的操作依赖
<code>InternalInsertNodeBefore(node→next, newNode)</code> 。</p>
<p>AddBefore 的操作则直接使用
<code>InternalInsertNodeBefore(node, newNode)</code>，但需要额外注意的是若此处的目标节点
node 是头节点，前插之后记得更新头节点</p>
<h3 id="节点查找-find-findlast">节点查找 Find / FindLast</h3>
<p>Find 内部仅区分查找的元素 <code>(T value)</code> 是否为
null，以此决定用
<code>EqualityComparer&lt;T&gt;.Default</code>，还是简单地进行
<code>node.item == null</code> 的判断。</p>
<p>而 FindLast 和 Find 的差异仅在于从后往前找，还是从前往后找。</p>
<h3 id="链表的清空-clear">链表的清空 Clear</h3>
<p>链表的清空操作涉及到节点的无效化（Invalidate）操作，使用节点 Next
遍历整个链表，将每个节点都无效化。Clear 操作最后将链表的头指针 head
置空，节点个数值置0。</p>
<h3 id="拷贝到数组-copytot-array-int-index">拷贝到数组 CopyTo(T[] array,
int index)</h3>
<p>（需要自己开辟数组传入）</p>
<p>虽然除去一些数组大小的合法性检测，逻辑还是比较简单的：遍历链表并依次存入到数组中而已，
但是惊讶于有这样一个方法，或许在一些场合会派上用场。</p>
<h3 id="节点移除-remove">节点移除 Remove</h3>
<p>类似节点的插入，节点的移除操作除了指定值的
<code>Remove(T value)</code>，还有移除头节点的
<code>RemoveFirst()</code>，以及移除尾节点的
<code>RemoveLast()</code>，它们都依赖同一个内部方法
<code>InternalRemoveNode(LinkedListNode&lt;T&gt; node)</code></p>
<h2 id="内部实现">内部实现</h2>
<h3 id="节点移除-internalremovenode">节点移除 InternalRemoveNode</h3>
<p>此方法的实现除去合法性校验部分，只剩下了一个标准的双向链表移除节点操作</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">internal void InternalRemoveNode(LinkedListNode&lt;T&gt; node) &#123;
    &#x2F;&#x2F; ...
    if ( node.next &#x3D;&#x3D; node) &#123;
        &#x2F;&#x2F; Debug.Assert(count &#x3D;&#x3D; 1 &amp;&amp; head &#x3D;&#x3D; node, ...
        head  &#x3D; null;
    &#125; 
    else &#123;
        node.next.prev &#x3D; node.prev;
        node.prev.next &#x3D; node.next;
        if ( head &#x3D;&#x3D; node) &#123;
            head &#x3D; node.next;
        &#125;
    &#125;
    node.Invalidate();  
    count--;
    version++;          
&#125;</code></pre>
<p>移除节点将会更新链表的节点个数 count，以及版本 version</p>
<h3 id="初始化空链表-internalinsertnodetoemptylist">初始化空链表
InternalInsertNodeToEmptyList</h3>
<p>使用新节点初始化空链表时，head 指向唯一节点，且此节点的 prev，next
均为自己</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">private void InternalInsertNodeToEmptyList(LinkedListNode&lt;T&gt; newNode) &#123;
    &#x2F;&#x2F; Debug.Assert( head &#x3D;&#x3D; null &amp;&amp; count &#x3D;&#x3D; 0, ...
    newNode.next &#x3D; newNode;
    newNode.prev &#x3D; newNode;
    head &#x3D; newNode;
    version++;
    count++; 
&#125;
 </code></pre>
<h3 id="节点前插-internalinsertnodebefore">节点前插
InternalInsertNodeBefore</h3>
<p>一个规范的双向链表节点前插实现，可以作为参考</p>
<p>LinkedList 中的所有链表插入操作仅依赖这一个方法，后插的操作会通过
<code>InsertNodeBefore(node→next, newNode)</code> 来实现</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">private void InternalInsertNodeBefore(LinkedListNode&lt;T&gt; node, LinkedListNode&lt;T&gt; newNode) &#123;
    newNode.next &#x3D; node;
    newNode.prev &#x3D; node.prev;
    node.prev.next &#x3D; newNode;
    node.prev &#x3D; newNode;            
    version++;
    count++;
&#125;</code></pre>
<h3 id="节点无效化-invalidatenode">节点无效化 InvalidateNode</h3>
<p>无效化操作会将节点存有的链表引用，前向、后向指针都置为
null，这样当操作完成后，这些节点就都会被GC回收了。</p>
<h3 id="节点校验-validatenode-validatenewnode">节点校验 ValidateNode /
ValidateNewNode</h3>
<p>对于新节点，将校验节点是否为null，节点是否还Attach在之前的list上（要求
<code>node.list</code>
为null）；而对于已在链表中的节点，同样校验节点是否为null，且校验节点存有的链表引用是否为当前链表（要求
<code>node.list == this</code> ）</p>
<h3 id="节点的next与previous">节点的Next与Previous</h3>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public LinkedListNode&lt;T&gt; Next &#123;
    get &#123; return next &#x3D;&#x3D; null || next &#x3D;&#x3D; list.head? null: next;&#125;
&#125;

public LinkedListNode&lt;T&gt; Previous &#123;
    get &#123; return prev &#x3D;&#x3D; null || this &#x3D;&#x3D; list.head? null: prev;&#125;
&#125;</code></pre>
<p>在双向链表中的节点有此设计：若当前节点的下一个节点已是头节点，那么在访问
Next 时会返回 null
来表示自己是尾节点；若当前节点与引用链表的头节点相等，那么在访问
Previous 时会返回 null 来表示自己是头节点。</p>
<h2 id="迭代器-enumerator">迭代器 Enumerator</h2>
<p>LinkedList 的迭代器实现也是比较符合直觉的，重点观察下
<code>MoveNext()</code> 方法中的终止条件即可：</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public bool MoveNext() &#123;
    if (version !&#x3D; list.version) &#123;
        throw new InvalidOperationException(SR.GetString(SR.InvalidOperation_EnumFailedVersion));
    &#125;
 
    if (node &#x3D;&#x3D; null) &#123;
        index &#x3D; list.Count + 1;
        return false;
    &#125;
 
    ++index;
    current &#x3D; node.item;   
    node &#x3D; node.next;  
    if (node &#x3D;&#x3D; list.head) &#123;
        node &#x3D; null;
    &#125;
    return true;
&#125;</code></pre>
<p>除了熟悉的 version check，只需要注意迭代在下方的
<code>node == list.head</code> 基本结束，下次便会由于 node 已设置
null，而将 index
设置为无效值<code>count + 1</code>，以此来结束迭代。</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script src="/js/lg-thumbnail.min.js"></script><script src="/js/lg-zoom.min.js"></script><script src="/js/lg-fullscreen.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>.NET</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET source 系列：System.Collections.Generic.List</title>
    <url>/p/e5c0cabb6711/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1
id="system.collections.generic.list">System.Collections.Generic.List</h1>
<p>参考版本为 .net framework 4.8</p>
<p><a
href="https://referencesource.microsoft.com/#mscorlib/system/collections/generic/list.cs">https://referencesource.microsoft.com/#mscorlib/system/collections/generic/list.cs</a></p>
<h2 id="摘要">摘要</h2>
<ul>
<li>泛型类型 <code>List&lt;T&gt;</code>，实现接口
IList&lt;T&gt;，IReadOnlyList&lt;T&gt;</li>
<li>使用数组 <code>T[] _items</code> 实现，当前已存储的元素个数为
<code>_size</code> / <code>Count</code>，当前容量大小通过
Capacity得到，直接返回数组 <code>_items</code> 的长度。</li>
</ul>
<span id="more"></span>
<h2 id="主要行为">主要行为</h2>
<h3 id="构造函数-ctor">构造函数 ctor</h3>
<ul>
<li>使用 List 的无参构造函数，会将List内部的静态空数组
<code>static readonly T[] _emptyArray = new T[0]</code> 设置到
<code>_items</code>
上，这是一个使用静态变量避免零大小数组重复创建的技巧。</li>
<li>使用带 <code>capacity</code>
参数的构造函数，可以在构造时就分配出指定大小的数组，避免后续添加元素时的扩容。</li>
<li>使用 <code>IEnumerable&lt;T&gt; collection</code>
参数的构造函数，会在内部先检查是否能转换为
<code>ICollection&lt;T&gt;</code>，这样直接开辟定长数组并直接
<code>CopyTo</code> 是更高效的；否则即使用 <code>GetEnumerator</code>
并遍历元素进行 <code>Add()</code> 的方式进行构造。</li>
</ul>
<h3 id="prop-capacity">(prop) Capacity</h3>
<p>getter 获取时直接返回内部数组的长度</p>
<p>setter
首先保证设置的容量大于元素个数；其次设置的容量值非0，直接分配对应大小的新数组，并将原内容
<code>Array.Copy</code> ，在容量值为0的情况下直接令 <code>_items</code>
指向 <code>_emptyArray</code></p>
<h3 id="prop-count">(prop) Count</h3>
<p>仅 getter，直接返回代表当前元素个数的 <code>_size</code></p>
<h3 id="ensurecapacityint-min">EnsureCapacity(int min)</h3>
<p>只有在传入的min大于内部数组长度时才会工作。</p>
<p>若内部数组长度为0，那么第一次扩容的长度会是<strong>_defaultCapacity</strong>，这个值在参考的源码中是4。</p>
<p>若不是第一次扩容，那么预期的扩容长度是<strong>当前数组长度
x2</strong>。</p>
<p>Capacity存在上界，这个值为
<code>Array_ReferenceSources.MaxArrayLength</code>，这个值为
<code>0X7FEFFFFF</code>（2亿多一些）。扩容的大小不会超过这个数值。</p>
<p>若预期扩容后的个数仍然没有达到传入的min，那么直接让新的容量大小等于传入的min。</p>
<p>最后这个 <code>newCapactiy</code> 通过上述 Capacity 的 setter
进行扩容。</p>
<h3 id="addt-item">Add(T item)</h3>
<p>若当前元素个数已达内部数组大小上限，通过
<code>EnsureCapacity(_size+1)</code> 来扩容</p>
<p>扩容后，新元素 item 会被放置到新数组的 _size++ 位置上</p>
<p>*此方法会更新 _version</p>
<h3 id="clear">Clear()</h3>
<p>Clear 方法只是释放了内部数组中每个元素的引用，并且将 _size
重置为0，即内部数组仍然存在 Capacity
即相应的内存占用，同时也很可能不会在下一次 Add() 中发生扩容。</p>
<p>*此方法会更新 _version</p>
<h3 id="containst-item">Contains(T item)</h3>
<p>若传入item为null，则进行内部数组所有元素（转换为Object）的null-check</p>
<p>若不为null，则获取类型T的默认比较器进行遍历比较</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">EqualityComparer&lt;T&gt; c &#x3D; EqualityComparer&lt;T&gt;.Default;
for(int i&#x3D;0; i&lt;_size; i++) &#123;
    if (c.Equals(_items[i], item)) return true;
&#125;
return false;</code></pre>
<h3 id="insertint-index-t-item">Insert(int index, T item)</h3>
<p>若List内部元素以达到内部数组上限，触发 _size + 1 扩容。</p>
<p>将插入位置往后的所有元素使用 <code>Array.Copy</code>
全部右移。List内部元素数增加。</p>
<p>*此方法会更新 _version</p>
<h3 id="insertrangeint-index-ienumerablet-collection">InsertRange(int
index, IEnumerable&lt;T&gt; collection)</h3>
<p>同样会检测传入的 collection 是否是 ICollection，对于不是 ICollection
的情况比较简单，使用 <code>GetEnumerator()</code> 遍历整个
collection，逐一进行 <code>Insert()</code>即可。</p>
<p>对于是 ICollection 的情况：</p>
<ul>
<li>使用 _size + collection.Count 大小进行扩容</li>
<li>将插入 index 往后的内容 copy 到 index + count 位置</li>
<li>若当前插入的 collection 是自己：
<ol type="1">
<li>将插入 index 前的内容复制到 index 位置</li>
<li>将前面保存在 index + count 位置的尾部内容重新复制为 index * 2 的位置
[ part1 | (index) part1 | (index*2) part2 | (index+count) part2 ]</li>
</ol></li>
<li>若当前插入的 collection 不是自己：新开辟指定 Count 大小的数组，直接
Copy 到 index 位置</li>
</ul>
<p>*此方法会更新 _version</p>
<h3 id="removet-item">Remove(T item)</h3>
<p>实现为 IndexOf(T item) 和 RemoveAt(int index) 的组合</p>
<h3 id="removeatint-index">RemoveAt(int index)</h3>
<p>若指定小标大于等于 _size 将抛出越界异常</p>
<p>减小List的元素数量 _size，当 index &lt; _size 时进行 Array.Copy</p>
<p>因为若需要移除的位置是当前元素的末尾，直接执行后续的
<code>_items[_size] = default(T)</code> 即可，不需要移动数组元素</p>
<p>*此方法会更新 _version</p>
<h3 id="removerangeint-index-int-count">RemoveRange(int index, int
count)</h3>
<p>RemoveRange会在方法起始做一系列越界检测。</p>
<p>剩下的内容与 RemoveAt 差别不大，_size
会减去指定的Count，同时进行数组的Copy。</p>
<p>差别较大的是这里并不将数组元素逐一设置为 default(T)，而是直接使用
<code>Array.Clear</code> 抹掉指定位上的内容。</p>
<p>个人而言 <code>Array.Clear</code>
并不特别常用，后续可以多关注这一类数组提供的方法。</p>
<p>*此方法会更新 _version</p>
<h3 id="trimexcess">TrimExcess()</h3>
<p>将List的内部数组大小，即容量大小，设置为严格与 _size
一致。只有用这个方法（或者手动设置Capacity）能够真正缩小List的内部数组内存占用，这在已知List不会再有新元素时相当有用。</p>
<p>想要完全清空一个List并且释放所有内存，正确的做法是：</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">list.Clear();
list.TrimExcess();</code></pre>
<h2 id="enumerator">Enumerator</h2>
<p>构造 Enumerator 时，内部会存有原 List
对象引用，新增表示遍历下标的index，表示当前元素的Current（构造时设置为
default(T)），并且记录构造时list的版本
list._version，防止遍历过程中list内容发生改变。</p>
<p>如果在MoveNext过程中，version发生了改变，那么将会立即抛出
<code>InvalidOperation_EnumFailedVersion</code> 异常。</p>
<p>第一次调用 <code>MoveNext()</code>
后，index和Current便会是List内部的第一个元素位置。最后一次调用
<code>MoveNext()</code> 后，将会进入方法
<code>MoveNextRare()</code>，此时index等于_size，Current恢复为default(T)，<code>MoveNextRare()</code>
将会返回 False 保证遍历过程停止。</p>
<h2 id="what-about-unity">What about Unity?</h2>
<h3 id="working-with-2018.4.11f1">working with 2018.4.11f1</h3>
<p>测试环境信息：</p>
<ul>
<li>API Compatibiliy Level: .NET 2.0 Subset</li>
<li>Scripting Runtime: 3.5 equivalent</li>
<li>Unity version: 2018.4.11f1</li>
</ul>
<p>写到这里时，正好在一个使用较低版本Unity的项目组中参与开发工作，因此虽然已有耳闻高版本的Unity在泛型共享方面有做优化，阅读il2cpp输出可能意义不大，但还是出于好奇观察了下
<code>System.Collections.Generic.List</code> 在低版本 unity / il2cpp
下的生成内容。</p>
<p>粗看之下类型成员，以及静态类型成员看上去没有什么不同。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; System.Collections.Generic.List&#96;1&lt;System.Int32&gt;
struct  List_1_t4A961510635950236678F1B3B2436ECCAF28713A  : public RuntimeObject
&#123;
public:
    &#x2F;&#x2F; T[] System.Collections.Generic.List&#96;1::_items
    Int32U5BU5D_t20AF77B812DFA3168922AE8F35FB9FD20D7EA074* ____items_1;
    &#x2F;&#x2F; System.Int32 System.Collections.Generic.List&#96;1::_size
    int32_t ____size_2;
    &#x2F;&#x2F; System.Int32 System.Collections.Generic.List&#96;1::_version
    int32_t ____version_3;
&#125;;

struct List_1_t4A961510635950236678F1B3B2436ECCAF28713A_StaticFields
&#123;
public:
    &#x2F;&#x2F; T[] System.Collections.Generic.List&#96;1::EmptyArray
    Int32U5BU5D_t20AF77B812DFA3168922AE8F35FB9FD20D7EA074* ___EmptyArray_4;
&#125;;</code></pre>
<p>但是没有发现 <code>EnsureCapacity</code>，取而代之的是
<code>GrowIfNeeded</code> 方法。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; System.Void System.Collections.Generic.List&#96;1&lt;System.Object&gt;::GrowIfNeeded(System.Int32)
extern &quot;C&quot; IL2CPP_METHOD_ATTR void List_1_GrowIfNeeded_m3C3B2872122BDF013830789D49EE77F7880CDEC5_gshared (List_1_tE72A517BD14F52539FF78EA90F58D1387FEED660 * __this, int32_t ___newCount0, const RuntimeMethod* method)
&#123;
    int32_t V_0 &#x3D; 0;
    &#123;
        int32_t L_0 &#x3D; (int32_t)__this-&gt;get__size_2();
        int32_t L_1 &#x3D; ___newCount0;
        V_0 &#x3D; (int32_t)((int32_t)il2cpp_codegen_add((int32_t)L_0, (int32_t)L_1));
        int32_t L_2 &#x3D; V_0;
        ObjectU5BU5D_t8D571697F3A1B33B696E2F80500C21F1A1748C5D* L_3 &#x3D; (ObjectU5BU5D_t8D571697F3A1B33B696E2F80500C21F1A1748C5D*)__this-&gt;get__items_1();
        NullCheck(L_3);
        if ((((int32_t)L_2) &lt;&#x3D; ((int32_t)(((int32_t)((int32_t)(((RuntimeArray *)L_3)-&gt;max_length)))))))
        &#123;
            goto IL_0031;
        &#125;
    &#125;
    &#123;
        NullCheck((List_1_tE72A517BD14F52539FF78EA90F58D1387FEED660 *)__this);
        int32_t L_4 &#x3D; ((  int32_t (*) (List_1_tE72A517BD14F52539FF78EA90F58D1387FEED660 *, const RuntimeMethod*))IL2CPP_RGCTX_METHOD_INFO(method-&gt;klass-&gt;rgctx_data, 18)-&gt;methodPointer)((List_1_tE72A517BD14F52539FF78EA90F58D1387FEED660 *)__this, &#x2F;*hidden argument*&#x2F;IL2CPP_RGCTX_METHOD_INFO(method-&gt;klass-&gt;rgctx_data, 18));
        int32_t L_5 &#x3D; Math_Max_m8B815B13982D8738EF051EA87C1CCB722CDF29B2((int32_t)((int32_t)il2cpp_codegen_multiply((int32_t)L_4, (int32_t)2)), (int32_t)4, &#x2F;*hidden argument*&#x2F;NULL);
        int32_t L_6 &#x3D; V_0;
        int32_t L_7 &#x3D; Math_Max_m8B815B13982D8738EF051EA87C1CCB722CDF29B2((int32_t)L_5, (int32_t)L_6, &#x2F;*hidden argument*&#x2F;NULL);
        NullCheck((List_1_tE72A517BD14F52539FF78EA90F58D1387FEED660 *)__this);
        ((  void (*) (List_1_tE72A517BD14F52539FF78EA90F58D1387FEED660 *, int32_t, const RuntimeMethod*))IL2CPP_RGCTX_METHOD_INFO(method-&gt;klass-&gt;rgctx_data, 19)-&gt;methodPointer)((List_1_tE72A517BD14F52539FF78EA90F58D1387FEED660 *)__this, (int32_t)L_7, &#x2F;*hidden argument*&#x2F;IL2CPP_RGCTX_METHOD_INFO(method-&gt;klass-&gt;rgctx_data, 19));
    &#125;

IL_0031:
    &#123;
        return;
    &#125;
&#125;</code></pre>
<p>这就需要我们按照上述测试环境找到准确的Mono版本了，已知当前的
Scripting runtime 对齐（equivalent） .NET framework
3.5，根据以下表格可以对应到 C# 3.0 版本。</p>
<figure>
<a href="https://s2.loli.net/2024/08/29/7LYwAR2mQ9XNdZ4.png" title="csharp-with-dotnet-framework-version" class="gallery-item"><img src="https://s2.loli.net/2024/08/29/7LYwAR2mQ9XNdZ4.png"
alt="csharp-with-dotnet-framework-version" /></a>
<figcaption
aria-hidden="true">csharp-with-dotnet-framework-version</figcaption>
</figure>
<p>再根据这张表格可以得到 Mono 实现 C# 3.0 的相应版本为 mono
2.0，这样就找到我们的源码目标了。需要额外注意的是，这里的表格中的 .net
2.0 是与现代 .net 6/7/8 的同一套标准的不同版本，而不是指 .NET Standard
2.0，不要把（很容易搞混的）概念搞混了。</p>
<figure>
<a href="https://s2.loli.net/2024/08/29/Fe2TCPKOb5QZqcB.png" title="mono-with-dotnet-version" class="gallery-item"><img src="https://s2.loli.net/2024/08/29/Fe2TCPKOb5QZqcB.png"
alt="mono-with-dotnet-version" /></a>
<figcaption aria-hidden="true">mono-with-dotnet-version</figcaption>
</figure>
<p>from: <a
href="https://www.cnblogs.com/zhaoqingqing/p/5762867.html">https://www.cnblogs.com/zhaoqingqing/p/5762867.html</a></p>
<p>所以Project Setting里面的<strong>API Compatibility
Level</strong>其实也是很重要的信息，之前一直下意识忽略掉了这个选项。在我们的老项目里，这里就直接告诉你
API 的兼容性版本是 <strong>.NET 2.0 Subset</strong>
了。如果能早一点意识到这个选项起到决定性作用，就不用兜兜转转一大圈了。</p>
<figure>
<a href="https://s2.loli.net/2024/09/23/ucRdJb64KE8TPrz.png" title="api-compatibility-level-in-project-setting" class="gallery-item"><img src="https://s2.loli.net/2024/09/23/ucRdJb64KE8TPrz.png"
alt="api-compatibility-level-in-project-setting" /></a>
<figcaption
aria-hidden="true">api-compatibility-level-in-project-setting</figcaption>
</figure>
<p>（在自家电脑上截的图，选用的API Compatibility
Level也（相对）新一点）</p>
<p>最后跳转到相应的 <a
href="https://github.com/mono/mono/blob/mono-2-0/mcs/class/corlib/System.Collections.Generic/List.cs">mono-2.0
源码</a>，就能看到方法 <code>GrowIfNeeded</code> 了。可以发现在实现上与
<code>EnsureCapacity</code>
不同的是传入的数值为此次操作的元素个数增量，而不是元素个数的目标大小。</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;mono&#x2F;mono&#x2F;blob&#x2F;a1f3cf39287ceaca189ae1b4c06ad1677c8988cf&#x2F;mcs&#x2F;class&#x2F;corlib&#x2F;System.Collections.Generic&#x2F;List.cs#L83

        public void Add (T item)
        &#123;
            &#x2F;&#x2F; If we check to see if we need to grow before trying to grow
            &#x2F;&#x2F; we can speed things up by 25%
            if (_size &#x3D;&#x3D; _items.Length)
                GrowIfNeeded (1);
            _items [_size ++] &#x3D; item;
            _version++;
        &#125;
        
        void GrowIfNeeded (int newCount)
        &#123;
            int minimumSize &#x3D; _size + newCount;
            if (minimumSize &gt; _items.Length)
                Capacity &#x3D; Math.Max (Math.Max (Capacity * 2, DefaultCapacity), minimumSize);
        &#125;</code></pre>
<p>再一次说明了在做Unity性能调优，或者在预测Unity上的业务代码性能表现情况时，有一份版本正确的源码很重要。如果觉得在诸多版本之间定位C#源码过于麻烦，直接阅读il2cpp输出的cpp源码，或许也是一种办法。</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script src="/js/lg-thumbnail.min.js"></script><script src="/js/lg-zoom.min.js"></script><script src="/js/lg-fullscreen.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>.NET</tag>
        <tag>源码阅读</tag>
        <tag>IL2CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>探究 .NET 源码系列：System.Text.StringBuilder</title>
    <url>/p/170a3913b9c4/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="net-source-stringbuilder">[.NET source] StringBuilder</h1>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>namespace</th>
<th>System.Text.StringBuilder</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>project</td>
<td>ndp.csproj</td>
</tr>
<tr class="even">
<td>file</td>
<td><a
href="https://referencesource.microsoft.com/#mscorlib/system/text/stringbuilder.cs">stringbuilder.cs</a></td>
</tr>
<tr class="odd">
<td>version</td>
<td>属于 .net standard 2.0 的 .NET Framework 4.8</td>
</tr>
</tbody>
</table>
<h2 id="摘要">摘要</h2>
<blockquote>
<p>This class represents a mutable string. It is convenient for
situations in which it is desirable to modify a string, perhaps by
removing, replacing, or inserting characters, without creating a new
String subsequent to each modification.</p>
<p>此类型代表一个可变字符串，有时我们需要对字符串进行移除，替换，插入字符等操作，但又不想每个操作都产生一个新的子串，在这样的情境下
StringBuilder 就特别有用。</p>
<p>A StringBuilder is internally represented as a linked list of blocks
each of which holds a chunk of the string. It turns out string as a
whole can also be represented as just a chunk, so that is what we
do.</p>
<p>StringBuilder
在内部表示为由块（Block）组成的链表，每个块都包含一个字符串块（Chunk）。
实际上完整的字符串也可以仅用一个块来表示，所以我们便这么实现了。</p>
</blockquote>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public sealed class StringBuilder : ISerializable &#123;
    &#x2F;&#x2F; The characters in this block
    internal char[] m_ChunkChars;
    &#x2F;&#x2F; Link to the block logically before this block
    internal StringBuilder m_ChunkPrevious;
    &#x2F;&#x2F; The index in m_ChunkChars that represent the end of the block
    internal int m_ChunkLength;
    &#x2F;&#x2F; The logial offset (sum of all characters in previous blocks)
    internal int m_ChunkOffset;
    internal int m_MaxCapacity &#x3D; 0;

    internal const int DefaultCapacity &#x3D; 16;
    &#x2F;&#x2F; ...
    
    &#x2F;&#x2F; We want to keep chunk arrays out of large object heap (&lt; 85K bytes ~ 40K chars) to be sure.
    &#x2F;&#x2F; Making the maximum chunk size big means less allocation code called, but also more waste
    &#x2F;&#x2F; in unused characters and slower inserts &#x2F; replaces (since you do need to slide characters over
    &#x2F;&#x2F; within a buffer).  
    internal const int MaxChunkSize &#x3D; 8000;
    
    &#x2F;&#x2F; ...
&#125;</code></pre>
<p>部分类型成员说明：</p>
<ul>
<li><strong>m_ChunkChars</strong>：内建字符数组，存储字符串内容用</li>
<li><strong>m_ChunkLength</strong>：指向了当前 chunk 中的字符数组
m_ChunkChars 的最后一个有效字符，即当前 chunk 有效内容的长度</li>
<li><strong>m_ChunkOffset</strong>：之前所有 blocks / chunks
的字符总数，即当前 chunk 的字符偏移量</li>
<li><strong>m_MaxCapacity</strong>：完整字符串的长度限制</li>
</ul>
<p>从 StringBuilder 的类型成员能够推断出，实际上每个 StringBuilder
都被看作是一个
<strong>Chunk</strong>，在不断添加新的字符串内容时，当前创建的
StringBuilder 会通过构造新的 StringBuilder 实例的方式，来创建出一个新的
<strong>Chunk</strong>。</p>
<p>那么也就是说，在获取 Capacity 以及 Length 时，我们都需要考虑 previous
Chunk 的存在，同时在重新设置（setter）Capacity 和 Length
时也要多做一些额外工作。</p>
<p>在探究构造函数和重要的内部实现与对外方法时，会重点关注此部分内容。</p>
<h2 id="构造函数">构造函数</h2>
<p>提供了多个构造函数，可以分别指定初始容量，初始字符串值，指定初始字符串值为给定字符串的一个子串…并且它们均依赖同一份构造函数实现，即
<code>StringBuilder(String value, int startIndex, int length, int capacity)</code></p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public StringBuilder(String value, int startIndex, int length, int capacity) &#123;
    &#x2F;&#x2F; 初始参数 startIndex, length, capacity 的一些合法性检测 ...
    if (value &#x3D;&#x3D; null) &#123;
        value &#x3D; String.Empty;
    &#125;
    &#x2F;&#x2F; if (startIndex &gt; value.Length - length) &#123; &#x2F;&#x2F; 越界检测
    m_MaxCapacity &#x3D; Int32.MaxValue;
    if (capacity &#x3D;&#x3D; 0) &#123;
        capacity &#x3D; DefaultCapacity;
    &#125;
    if (capacity &lt; length)
        capacity &#x3D; length;

    m_ChunkChars &#x3D; new char[capacity];
    m_ChunkLength &#x3D; length;

    unsafe &#123;
        fixed (char* sourcePtr &#x3D; value)
            ThreadSafeCopy(sourcePtr + startIndex, m_ChunkChars, 0, length);
    &#125;
&#125;</code></pre>
<p>可以得到以下信息：</p>
<ul>
<li>StringBuilder 有默认大小 <code>DefaultCapacity == 16</code></li>
<li>StringBuilder 中的字符内容被存储在
<strong>m_ChunkChars</strong>，并且长度也被记录于
<strong>m_ChunkLength</strong></li>
</ul>
<h2 id="部分关键实现">部分关键实现</h2>
<h3 id="字符串内容拷贝-stringbuilder.threadsafecopy">字符串内容拷贝
StringBuilder.ThreadSafeCopy</h3>
<p>字符串内容的拷贝基于 unsafe 方法
<code>static unsafe StringBuilder.ThreadSafeCopy</code>，方法内部做了字符串数组的边界检测，并且基于方法
<strong>System.String.wstrcpy</strong> 实现了内容的拷贝。</p>
<p>顺带一提，可以看到 <strong>System.String.wstrcpy</strong> 内部基于
<strong>System.Buffer.Memcpy</strong>，并且对于每个字符均采用两个字节的长度。使用
<code>charCount * 2</code> 是因为此版本下 C# 中的字符串是以 UTF-16
编码存储的（但注意 UTF-16 也是变长编码）。每个字符占用 2 个字节（16
位），因此需要将字符数乘以 2 来计算字节数。</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; ndp\clr\src\BCL\system\text\stringbuilder.cs:1846

if ((uint)destinationIndex &lt;&#x3D; (uint)destination.Length &amp;&amp; (destinationIndex + count) &lt;&#x3D; destination.Length)
&#123;                                                                                                          
    fixed (char* destinationPtr &#x3D; &amp;destination[destinationIndex])                                          
        string.wstrcpy(destinationPtr, sourcePtr, count);                                                  
&#125;                                                                                                          

&#x2F;&#x2F; ndp\clr\src\BCL\system\string.cs:1546
        internal static unsafe void wstrcpy(char *dmem, char *smem, int charCount)
        &#123;
            Buffer.Memcpy((byte*)dmem, (byte*)smem, charCount * 2); &#x2F;&#x2F; 2 used everywhere instead of sizeof(char)
        &#125;</code></pre>
<h3 id="容量的获取与设置-capacity">容量的获取与设置 Capacity</h3>
<p>从容量的获取不难看出 <strong>m_ChunkOffset</strong> 即是先前 Chunk
中包含字符串数量。</p>
<p>builder 的 <strong>Capacity</strong>
是当前chunk的字符偏移值，加上内部数组的大小。</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public int Capacity &#123;
    get &#123; return m_ChunkChars.Length + m_ChunkOffset; &#125;</code></pre>
<p>容量的设置方法中也考虑了 <strong>m_ChunkOffset</strong>，当前
StringBuilder
的字符数组，会被一个新的字符数组取代（由于做了合法性检测保证新的
Capacity &gt; Length，此处不同担心新的字符数组长度是非法值）</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">if (Capacity !&#x3D; value) &#123;
    int newLen &#x3D; value - m_ChunkOffset;
    char[] newArray &#x3D; new char[newLen];
    Array.Copy(m_ChunkChars, newArray, m_ChunkLength);
    m_ChunkChars &#x3D; newArray;
&#125;</code></pre>
<h3 id="长度的获取与设置-length">长度的获取与设置 Length</h3>
<p>builder 的 <strong>Length</strong>
是当前chunk的字符偏移值，加上内部数组中有效内容的长度。</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public int Length &#123;
    get &#123;
        Contract.Ensures(Contract.Result&lt;int&gt;() &gt;&#x3D; 0);
        return m_ChunkOffset + m_ChunkLength;
    &#125;</code></pre>
<p>而从容量的设置我们可以看到 StringBuilder
在容量更新时是如何处理多个Chunk的情况的：</p>
<p>首先还是惯例的合法性检测，同时保留当前的容量值</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; Sets the length of the String in this buffer.  If length is less than the current
&#x2F;&#x2F; instance, the StringBuilder is truncated.  If length is greater than the current 
&#x2F;&#x2F; instance, nulls are appended.  The capacity is adjusted to be the same as the length.
public int Length &#123;
    set &#123;
        &#x2F;&#x2F;If the new length is less than 0 or greater than our Maximum capacity, bail.
        &#x2F;&#x2F; 一些合法性检测，保证 0 &lt; value &lt;&#x3D; MaxCapacity
        &#x2F;&#x2F; ... &#x2F;&#x2F; Contract.EndContractBlock();

        int originalCapacity &#x3D; Capacity;
    &#125;
&#125;</code></pre>
<p>如果是将 StringBuilder 置空的常见操作，那么只是重置
<strong>m_ChunkLength</strong> 以及
<strong>m_ChunkOffset</strong>，没有太多进一步操作了。考虑到将
StringBuilder 重置是一个发生频率比较高的操作，将
<strong>m_ChunkChars</strong> 中的内容先做保留或许也是正确的选择。</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">if (value &#x3D;&#x3D; 0 &amp;&amp; m_ChunkPrevious &#x3D;&#x3D; null)
&#123;
    m_ChunkLength &#x3D; 0;
    m_ChunkOffset &#x3D; 0;
    Contract.Assert(Capacity &gt;&#x3D; originalCapacity, &quot;setting the Length should never decrease the Capacity&quot;);
    return;
&#125;</code></pre>
<p>如果长度发生了增长，那么将填充 <code>delta * ‘\0’</code>
到字符数组的末尾。这个操作和对外方法 <code>Append</code>
并没有区别，都有可能造成新的Chunk增长，但之后在探究
<code>ExpandByABlock</code>
实现时我们会发现这里顶多也只会增长一个Chunk。（可以看到注释评价此处的实现是可以改进的，可能做一个简单的
<strong>m_ChunkChars</strong>
容量调整，或者直接加上一个新的Chunk都会更简单高效一些）</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int delta &#x3D; value - Length;
&#x2F;&#x2F; if the specified length is greater than the current length
if (delta &gt; 0)
&#123;
    &#x2F;&#x2F; the end of the string value of the current StringBuilder object is padded with the Unicode NULL character
    Append(&#39;\0&#39;, delta);        &#x2F;&#x2F; We could improve on this, but who does this anyway?
&#125;</code></pre>
<p>如果长度发生了缩减，那么通过方法 <code>FindChunkForIndex</code>
先找到对应的chunk，然后分为“是当前chunk”还有“不是当前chunk”来讨论：</p>
<p>如果是当前chunk，那么简单地更新一下 <strong>m_ChunkLength</strong>
即可；如果不是当前chunk，那么实际的操作是：</p>
<ol type="1">
<li>由于 StringBuilder
的长度发生了缩减，其内部的有效内容也会发生相应的缩减，builder的当前chunk，将被用来取代缩减位置所对应的chunk，下简称为<strong>targetChunk</strong>。</li>
<li>首先，新的内部数组长度，将保证至少能够容纳缩减的这些内容，长度为
<code>originalCapacity - targetChunk.m_ChunkOffset</code></li>
<li>其次，<strong>targetChunk</strong>中的内容将被完整复制到这个新的数组（可能有新length以后的内容，但不要紧，后面
<strong>m_ChunkLength</strong> 的更新将会无视掉这部分多余的内容）</li>
<li>最后，当前chunk将会使用这个新开辟的字符数组，同时继承<strong>targetChunk</strong>的前向chunk，offset等信息</li>
<li>这些被略过，以及被取代掉的chunk，以及它们内部的数组内容都已没有引用，它们所占有的内存空间将在下一次
GC.Collect 时释放掉</li>
</ol>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; if the specified length is less than or equal to the current length 
else
&#123;
    StringBuilder chunk &#x3D; FindChunkForIndex(value);
    if (chunk !&#x3D; this)
    &#123;
        &#x2F;&#x2F; we crossed a chunk boundary when reducing the Length, we must replace this middle-chunk with a new
        &#x2F;&#x2F; larger chunk to ensure the original capacity is preserved
        int newLen &#x3D; originalCapacity - chunk.m_ChunkOffset;
        char[] newArray &#x3D; new char[newLen];
        Contract.Assert(newLen &gt; chunk.m_ChunkChars.Length, &quot;the new chunk should be larger than the one it is replacing&quot;);
        Array.Copy(chunk.m_ChunkChars, newArray, chunk.m_ChunkLength);
        
        m_ChunkChars &#x3D; newArray;
        m_ChunkPrevious &#x3D; chunk.m_ChunkPrevious;                        
        m_ChunkOffset &#x3D; chunk.m_ChunkOffset;
    &#125;
    m_ChunkLength &#x3D; value - chunk.m_ChunkOffset;
    VerifyClassInvariant();
&#125;</code></pre>
<h3 id="清空操作-clear">清空操作 Clear</h3>
<p>简单地提一下，builder的清空操作实际上就是将 Length 设置为0的操作</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; Convenience method for sb.Length&#x3D;0;
public StringBuilder Clear() &#123;
    this.Length &#x3D; 0;
    return this;
&#125;</code></pre>
<h3 id="字符索引-index">字符索引 index</h3>
<p>从 index 方法的实现是符合直觉的，如果 index - chunk.offset
大于等于0，那么，字符就在当前chunk中，直接对 m_ChunkChars
进行数组索引；如果小于0，说明字符位于先前的chunk中，chunk指向previous，并使用新的offset更新index值，不断循环即可。</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public char this[int index] &#123;
    &#x2F;&#x2F; 

    get &#123;
        StringBuilder chunk &#x3D; this;
        for (; ; )
        &#123;
            int indexInBlock &#x3D; index - chunk.m_ChunkOffset;
            if (indexInBlock &gt;&#x3D; 0)
            &#123;
                if (indexInBlock &gt;&#x3D; chunk.m_ChunkLength)
                    throw new IndexOutOfRangeException();
                return chunk.m_ChunkChars[indexInBlock];
            &#125;
            chunk &#x3D; chunk.m_ChunkPrevious;
            if (chunk &#x3D;&#x3D; null)
                throw new IndexOutOfRangeException();
        &#125;
    &#125;
    &#x2F;&#x2F; set 方法是类似的</code></pre>
<p>这就导致如果对很多的chunk组成的builder进行从头到尾的逐字符遍历，实际执行的指令数可能会很多，比如在
<strong>System.Net.NetworkingPerfCounters</strong> 中的这个方法。</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; ndp\fx\src\net\System\Net\_NetworkingPerfCounters.cs:372
&#x2F;&#x2F; NetworkingPerfCounters.ReplaceInvalidChars
        private static string ReplaceInvalidChars(string instanceName)
        &#123;
            &#x2F;&#x2F; map invalid characters as suggested by MSDN (see PerformanceCounter.InstanceName Property help)

            StringBuilder result &#x3D; new StringBuilder(instanceName);
            for (int i &#x3D; 0; i &lt; result.Length; i++)
            &#123;
                switch (result[i])
                &#123;
                    case &#39;(&#39;:
                        result[i] &#x3D; &#39;[&#39;;
                        break;
                    case &#39;)&#39;:
                        result[i] &#x3D; &#39;]&#39;;
                        break;
                    case &#39;&#x2F;&#39;:
                    case &#39;\\&#39;:
                    case &#39;#&#39;:
                        result[i] &#x3D; &#39;_&#39;;
                        break;
                &#125;
            &#125;

            return result.ToString();
        &#125;</code></pre>
<p>当然，如果instanceName并不长（在这个case中实际上只有一个chunk），那问题就不大。</p>
<div class="note warning"><p>这警示我们实现自定义index方法时注重可读性，并且在调用其他人写的自定义index方法时，最好也去了解一下具体实现。</p>
</div>
<h3 id="输出字符串-tostring">输出字符串 ToString()</h3>
<p>ToString 方法依赖了 String 类的内部静态方法
<code>String.FastAllocateString</code>，来分配出长度为 Length
的字符串对象 <strong>ret，</strong>通过 unsafe 得到此目标字符串的地址
<strong>destination_ptr。</strong></p>
<p>后续首先将 <strong>m_ChunkChars</strong> 中的内容通过 unsafe 方式
<code>string.wstrcpy</code> 到目标字符串的
<code>destination_ptr + checkOffset</code> 位置，处理完毕后指向前一个
chunk (StringBuilder)，继续处理，直到所有 chunk
处理完毕，这样完整的字符串构建过程便完成了。</p>
<p>StringBuilder 还提供了可执行从某个位置起指定字符个数版本的
<code>ToString(int startIndex, int length)</code>，这里不再赘述。</p>
<h3 id="分配新的chunk-expandbyablockint-minblockcharcount">分配新的Chunk
/ ExpandByABlock(int minBlockCharCount)</h3>
<ol type="1">
<li><p>长度校验：当前字符串总长度 + 新 chunk 需求长度 不可超过
<code>m_MaxCapacity</code></p></li>
<li><p>新 chunk 大小计算：此处细节比较多，新分配的一个 chunk 大小将为
<code>Math.Max(minBlockCharCount, Math.Min(Length, MaxChunkSize))</code>,
有以下这些考量</p>
<ol type="1">
<li>保证新分配的 chunk 满足需求 <strong>minBlockCharCount</strong></li>
<li>保证在连续请求（Append）短字符串时，采用总体字符串长度
<strong>Length</strong> 能保证分配出较长的
chunk，来容纳多个短字符串</li>
<li>在此基础上，通过 <strong>MaxChunkSize（常量
8000）</strong>保证在总体字符串较长的情况下，不会分配出特别大的
chunk，以此来保证分配内存操作保留在 small object heap，而不是 large
object heap。这里两种不同 heap
的概念之前没有学习过，可以后续详细了解下。贴上源码中的两处注释以供后续参考：</li>
</ol>
<p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; ndp\clr\src\bcl\system\text\stringbuilder.cs:76
        
&#x2F;&#x2F; We want to keep chunk arrays out of large object heap (&lt; 85K bytes ~ 40K chars) to be sure.   
&#x2F;&#x2F; Making the maximum chunk size big means less allocation code called, but also more waste      
&#x2F;&#x2F; in unused characters and slower inserts &#x2F; replaces (since you do need to slide characters over
&#x2F;&#x2F; within a buffer).                                                                             
internal const int MaxChunkSize &#x3D; 8000;
        
&#x2F;&#x2F; ndp\clr\src\bcl\system\text\stringbuilder.cs:1977
        
&#x2F;&#x2F; Compute the length of the new block we need                                       
&#x2F;&#x2F; We make the new chunk at least big enough for the current need (minBlockCharCount)
&#x2F;&#x2F; But also as big as the current length (thus doubling capacity), up to a maximum   
&#x2F;&#x2F; (so we stay in the small object heap, and never allocate really big chunks even if
&#x2F;&#x2F; the string gets really big.                                                       
int newBlockLength &#x3D; Math.Max(minBlockCharCount, Math.Min(Length, MaxChunkSize));    </code></pre></p></li>
<li><p>当前 chunk 通过复制拷贝的方式传递给 m_ChunkPrevious
&lt;StringBuilder&gt;，ChunkOffset 增长到扩容前的 Length 值</p></li>
<li><p>最后如果发现 ChunkOffset 加上计算出的
<strong>newBlockLength</strong> 已经超过了 int.MaxInt，发生上溢，会抛出
OutOfMemory 异常</p></li>
<li><p>最后，当前 StringBuilder 被作为整个字符串的最后一个
chunk，分配一个大小为 newBlockLength 的内建字符数组给
<strong>m_ChunkChars</strong></p></li>
</ol>
<h2 id="对外方法">对外方法</h2>
<h3 id="append">Append</h3>
<p>大多数 <strong>Append</strong> 方法会依赖 unsafe 方法
<code>Append(char* value, int valueCount)</code>，简单处理为两种情况：</p>
<ul>
<li>若需 append 的内容未超过当前 chunk 容量 →
<code>ThreadSafeCopy</code> 填充当前 chunk</li>
<li>需 append 内容超过当前 chunk 容量：
<ol type="1">
<li>将当前 chunk 剩余容量填充满 → <code>ThreadSafeCopy</code></li>
<li>将当前 chunk 复制到内部新的 chunk 作为 previous，当前 chunk
再作为整个字符串中的最后一个 chunk 返回 →
<code>ExpandByABlock(int minBlockCharCount)</code></li>
<li>需 append 的剩余内容填充到新的 chunk 中 →
<code>ThreadSafeCopy</code></li>
</ol></li>
</ul>
<h3 id="appendstring-value">Append(String value)</h3>
<p>作为使用相当频繁的 Append 方法， 与上述
<code>Append(char* value, int valueCount)</code> 存在些许不同。若 append
新内容后所需长度没有超过当前 chunk 的容量，那么进行简化的操作：</p>
<ol type="1">
<li>append 长度不超过2时直接进行字符数组设置</li>
<li>超过2时进行 string.wstrcpy 将 append 数组复制到当前 chunk 中</li>
</ol>
<p>其他情况下使用 AppendHelper，回到上述
<code>Append(char* value, int valueCount)</code> →
<code>ThreadSafeCopy</code> 调用链</p>
<h3
id="copytoint-sourceindex-char-destination-int-destinationindex-int-count">CopyTo(int
sourceIndex, char[] destination, int destinationIndex, int count)</h3>
<p>StringBuilder 提供将 builder 内指定子串内容复制到目标字符数组的方法
<code>CopyTo</code>，实现基于从后往前的 chunk 遍历搜索 +
<code>ThreadSafeCopy</code>，比较符合直觉，此处不展开。</p>
<h3 id="insert">Insert</h3>
<p>大多数 <strong>Insert</strong> 方法依赖方法
<code>Insert(int index, String value, int count)</code>
，方法除去大多数合法性校验外，核心逻辑集中在两个方法：<code>MakeRoom</code>
以及循环调用 count 次的 <code>ReplaceInPlaceAtChunk</code></p>
<p>合法性校验中值得额外提及的是，插入字符串总长度 value.Length * cout
加上已有长度 <strong>Length</strong> 仍然不可超过限定长度
<strong>MaxCapacity</strong></p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">StringBuilder chunk;                                                                   
int indexInChunk;                                                                      
MakeRoom(index, (int) insertingChars, out chunk, out indexInChunk, false);             
unsafe &#123;                                                                               
    fixed (char* valuePtr &#x3D; value) &#123;                                                   
        while (count &gt; 0)                                                              
        &#123;                                                                              
            ReplaceInPlaceAtChunk(ref chunk, ref indexInChunk, valuePtr, value.Length);
            --count;                                                                   
        &#125;                                                                              
    &#125;                                                                                  
&#125;                                                                                      </code></pre>
<p>方法 <code>MakeRoom</code> 细节如下，先通过向前遍历找到插入位置 index
对应的chunk，接下来若此 chunk 存在足够剩余空间容纳大小为 count
的目标字符串，那么将此处的 count 长度子串移动到 count
个字符之后，腾出空间。</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">if (!doneMoveFollowingChars &amp;&amp; chunk.m_ChunkLength &lt;&#x3D; DefaultCapacity * 2 &amp;&amp; chunk.m_ChunkChars.Length - chunk.m_ChunkLength &gt;&#x3D; count)
&#123;                                                                                                                                     
    for (int i &#x3D; chunk.m_ChunkLength; i &gt; indexInChunk; )                                                                             
    &#123;                                                                                                                                 
        --i;                                                                                                                          
        chunk.m_ChunkChars[i + count] &#x3D; chunk.m_ChunkChars[i];                                                                        
    &#125;                                                                                                                                 
    chunk.m_ChunkLength +&#x3D; count;                                                                                                     
    return;                                                                                                                           
&#125;                                                                                                                                     </code></pre>
<p>其他情况下会构造一个容量可容纳 count 字符的新 StringBuilder 作为当前
chunk 的前一个 chunk，对预计算出的插入位置
<strong>indexInChunk</strong>，将当前chunk的插入位置前内容通过
<code>ThreadSafeCopy</code> 移动到前一个 chunk 中，再将 chunk
和插入位置传出到方法外部，让外部从指定位置开始插入字符串内容。</p>
<p>方法 <code>ReplaceInPlaceAtChunk</code> 将指定的 char* value, int
count 内容通过 ThreadSafeCopy 写入到指定 chunk 中，并且在当前 chunk
无法容纳所有内容时，能够通过索引向后查找下一个 chunk，继续后续的 replace
操作。</p>
<p>不过注意这个操作可行性建立在传入的 chunk 是实际 StringBuilder 的前向
chunk 的基础上，因为 <code>Next()</code> 实际是先得到传入 chunk 的
offset+length，再通过最尾部 chunk 向前查找 offset 的形式实现的。</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int lengthInChunk &#x3D; chunk.m_ChunkLength - indexInChunk;                      
Contract.Assert(lengthInChunk &gt;&#x3D; 0, &quot;index not in chunk&quot;);                   
                                                                             
int lengthToCopy &#x3D; Math.Min(lengthInChunk, count);                           
ThreadSafeCopy(value, chunk.m_ChunkChars, indexInChunk, lengthToCopy);       
                                                                             
&#x2F;&#x2F; Advance the index.                                                        
indexInChunk +&#x3D; lengthToCopy;                                                
if (indexInChunk &gt;&#x3D; chunk.m_ChunkLength)                                     
&#123;                                                                            
    chunk &#x3D; Next(chunk);                                                     
    indexInChunk &#x3D; 0;                                                        
&#125;                                                                            
count -&#x3D; lengthToCopy;                                                       
if (count &#x3D;&#x3D; 0)                                                              
    break;                                                                   
value +&#x3D; lengthToCopy;                                                       </code></pre>
<h3 id="replace">Replace</h3>
<p>Replace 操作用于将 StringBuilder 中的所有 oldValue 替换为 newValue
字符串，实现细节有以下：</p>
<ul>
<li>以每个 chunk 为单位搜索匹配的字符串，当此 chunk
结束或搜索目标长度完成时，才会一次性进行 replace 操作，replace
操作依赖方法 <code>ReplaceAllInChunk</code></li>
<li>每次 replace
操作后字符串长度变化，要找到下一个chunk依赖上述提及的方法
<code>FindChunkForIndex</code></li>
<li>再搜索匹配的字符串过程中，方法内部开辟一个 int[] 数组
<strong>replacements</strong> 用于记录需匹配字符在 chunk
中的下标，同时记录当前 chunk 中匹配的个数
replacementsCount，以保证这个数组在多次 replace
操作间能复用，不需要重新开辟。</li>
<li>int[] 数组 replacements 的增长速度为
<code>length = 1.5 * length + 4</code>，在起始阶段为更快一些</li>
</ul>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; Push it on my replacements array (with growth), we will do all replacements in a                        
&#x2F;&#x2F; given chunk in one operation below (see ReplaceAllInChunk) so we don&#39;t have to slide                    
&#x2F;&#x2F; many times.                                                                                             
if (replacements &#x3D;&#x3D; null)                                                                                  
    replacements &#x3D; new int[5];                                                                             
else if (replacementsCount &gt;&#x3D; replacements.Length)                                                         
&#123;                                                                                                          
    int[] newArray &#x3D; new int[replacements.Length * 3 &#x2F; 2 + 4];     &#x2F;&#x2F; grow by 1.5X but more in the begining
    Array.Copy(replacements, newArray, replacements.Length);                                               
    replacements &#x3D; newArray;                                                                               
&#125;                                                                                                          
replacements[replacementsCount++] &#x3D; indexInChunk;                                                          
indexInChunk +&#x3D; oldValue.Length;                                                                           
count -&#x3D; oldValue.Length;                                                                                  </code></pre>
<div class="note warning"><p>在设计自己的数据容器时，可以参考此处的容器增长速度。阅读多个数据容器源码后，会发现
1.5x
是一个较常见的增长速度，当然如果追求极致空间利用率，肯定还是需要结合实际业务场景进行调优。</p>
</div>
<h3 id="remove">Remove</h3>
<p>Remove 操作用于将指定位置 startIndex 位置后 length
长度的内容移除，实现细节有以下：</p>
<ul>
<li>作为一个优化策略，若传入的参数表明要移除所有内容，那么直接通过设置
property <code>Length = 0</code> 的方式来清空整个 StringBuilder
关联的多个 chunks</li>
<li>其他一般情况下的实现细节在方法
<code>Remove(int startIndex, int count, out StringBuilder chunk, out int indexInChunk)</code>
中。</li>
<li>先用一个从后向前的 chunk 遍历找到删除范围的起始 chunk，以及终止
chunk。这里在遍历的过程中还会顺带更新每个 chunk 的
offset，因为马上前序的 chunk 就要发生 remove 操作了。</li>
<li>如果删除的起始和终止并不在同一个 chunk 中，那么先将起始 chunk 的有效
<strong>m_ChunkLength</strong>
调整到删除范围的起始（这样被删除的内容虽然还在数组里，实际会被视为无效内容），再将终止
chunk 的前序 chunk 直接链接到起始 chunk 上，并调整终止 chunk 的
offset，相应地从 <strong>m_ChunkLength</strong>
中减去被移除的长度。</li>
<li>最后将终止 chunk 中末端的未删除内容，使用
<code>ThreadSafeCopy</code> 向前移动到先前被删除内容的位置（“sliding the
characters down”）。</li>
<li>这里源码中还考虑了起始 chunk 和终止 chunk 是用一个 chunk
的情况，这样终止 chunk
中的未删除内容就不能直接移动到起始处，而是要移动到此 chunk
中的原删除内容起始处了。</li>
</ul>
<h2 id="其他">其他</h2>
<h3 id="基于-appendformat-的-string.format">基于 AppendFormat 的
string.Format</h3>
<p>见方法实现，实际依赖方法实现
<code>StringBuilder.AppendFormat</code></p>
<p>注意 <code>StringBuilderCache.Acquire</code> 方法中访问的静态变量
<strong>CachedInstance</strong> 被标记为 [ThreadStatic]</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; ndp\clr\src\BCL\system\String.cs:3054

public static String Format(IFormatProvider provider, String format, params Object[] args) &#123;
    if (format &#x3D;&#x3D; null || args &#x3D;&#x3D; null)
        throw new ArgumentNullException((format &#x3D;&#x3D; null) ? &quot;format&quot; : &quot;args&quot;);
    Contract.Ensures(Contract.Result&lt;String&gt;() !&#x3D; null);
    Contract.EndContractBlock();

    StringBuilder sb &#x3D; StringBuilderCache.Acquire(format.Length + args.Length * 8);
    sb.AppendFormat(provider,format,args);
    return StringBuilderCache.GetStringAndRelease(sb);
&#125;

&#x2F;&#x2F; ndp\clr\src\BCL\system\text\stringbuildercache.cs:50

public static StringBuilder Acquire(int capacity &#x3D; StringBuilder.DefaultCapacity)
&#123;
    if(capacity &lt;&#x3D; MAX_BUILDER_SIZE)
    &#123;
        StringBuilder sb &#x3D; StringBuilderCache.CachedInstance;
        if (sb !&#x3D; null)
        &#123;
            &#x2F;&#x2F; Avoid stringbuilder block fragmentation by getting a new StringBuilder
            &#x2F;&#x2F; when the requested size is larger than the current capacity
            if(capacity &lt;&#x3D; sb.Capacity)
            &#123;
                StringBuilderCache.CachedInstance &#x3D; null;
                sb.Clear();
                return sb;
            &#125;
        &#125;
    &#125;
    return new StringBuilder(capacity);
&#125;</code></pre>
<p>平时使用时容易忽视的一个细节是，实际进行字符串格式化时可传入
IFormatProvider，这个参数会被一路传入到方法
<code>StringBuilder.AppendFormat</code>
内部，用于调整字符串格式化行为：</p>
<ol type="1">
<li>如果希望格式化行为不被地区文化影响，可以使用
<code>CultureInfo.InvariantCulture</code>，相应的，使用当前地区文化格式输出是
<code>CultureInfo.CurrentCulture</code>。不过对于需要考虑地区文化相关字符串输出格式的应用来说，一般会自己写一套相应地区对应输出格式，还得考虑用户的地区语言设置，也许
CurrentCulture 不是那么常用。</li>
<li>在 <code>AppendFormat</code> 中，若提供了 IFormatProvider
参数，则会通过其获取 <strong>I</strong>CustomFormatter
类型对象，并在解析格式占位符（如“{0}”）后，将占位符，参数，以及 provider
一同传递给 <code>ICustomFormatter.Format</code> 获得结果字符串。</li>
<li>否则，<code>AppendFormat</code> 中会尝试将每个格式化参数转换为
IFormattable，并将占位符，provider 一同传递给格式
<code>IFormattable.ToString</code>
得到格式化结果字符串。常见的基元类型都实现了
IFormattable，但一般我们定义的类型，能有一个输出需求信息的 ToString()
就很好了。AppendFormat 在无法将参数转换为 IFormattable
的情况下，也会回退到一般的 object.ToString() 方法。</li>
</ol>
<h2 id="一些收获">一些收获</h2>
<ul>
<li>StringBuilder
的设计实现思路是把拼接过程中的字符串看作块（chunk）的组合，并使用将外部引用的
StringBuilder 视作是最后一个块，前向块都通过内部 m_PreviousChunk
引用，不暴露给外部。</li>
<li>考虑到 AppendFormat 的较复杂实现和潜在内存开辟，在使用 StringBuilder
时也许用普通的 Append 来替代 AppendFormat 可以更好地利用 StringBuilder
的性能优势。当然可读性也很重要。</li>
<li>高频使用类型自实现的 index 方法时，最好对 index
方法的实现细节有一些了解；同时在实现自己类型的 index
方法时，也要注意代码可读性。</li>
<li>在通用类型的设计完成后，先围绕设计实现一系列基本操作的私有方法，或需求参数较多的公有方法，再考虑易用性，设计传参简单使用便捷的常用公用方法，尽可能少地暴露内部实现细节，减少外围代码使用此通用类型的心智负担。</li>
<li>进行常见字符串操作时，留意输出结果是否需要时文化无关的（InvariantCulture）。</li>
</ul>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script src="/js/lg-thumbnail.min.js"></script><script src="/js/lg-zoom.min.js"></script><script src="/js/lg-fullscreen.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>.NET</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo快速进行博客搭建</title>
    <url>/p/c9e58284d744/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="使用hexo快速进行博客搭建">使用hexo快速进行博客搭建</h1>
<p>之前用wordpress搭建的博客需要折腾的东西太多，编辑器支持也不太好，没有Notion里记笔记来的方便（该说写个笔记两头传本来就麻烦），所以这次用hexo来搭建看看。</p>
<p>部署选择了一键同步生成的网站内容到github
repo上，使用pages来进行网站部署，markdown源文件再自己使用github来同步。</p>
<p>这篇文章主要记录一下搭建网站的过程，还有给搭建的时候看的几个文档链接留个档。</p>
<h2 id="hexo官方文档">hexo官方文档</h2>
<ol type="1">
<li>https://hexo.io/docs/</li>
<li>https://hexo.io/zh-cn/docs/ 中文</li>
</ol>
<h2 id="hexo-常用命令">hexo 常用命令</h2>
<p><strong>hexo new [layout] &lt;title&gt;</strong></p>
<p>创建新文章，使用默认的layout：post</p>
<p><strong>hexo generate</strong></p>
<p>一般会使用缩写<code>hexo g</code>，并且加上<code>-d</code>参数来一键部署到远端（我目前是部署到了github上），也可以加上<code>-w</code>来观察文件变化，或是加上<code>-f</code>来重新生成</p>
<p><strong>hexo server</strong></p>
<p>虽然是部署到远端上，但是也可以在真正提交前先在本地简单地生成部署一下，看下文章显示是否有问题，或者用这个命令来协助debug（带上<code>--log</code>，以及<code>--debug</code>参数）</p>
<p>加上<code>-p</code>来指定部署的端口，以防在特定环境下收到安全组影响</p>
<p><strong>hexo deploy</strong></p>
<p>部署到远端，这个命令也可以加上<code>-g</code>从而在部署之前生成</p>
<p><strong>hexo clean</strong></p>
<p>清除本地生成文件，遇到奇怪显示问题可以考虑先执行一下，再重新generate</p>
<h2 id="部署相关github-pages">部署相关（github-pages）</h2>
<ol type="1">
<li>https://segmentfault.com/a/1190000017986794 一键部署</li>
<li>https://zhuanlan.zhihu.com/p/26625249
自定义域名步骤参考，免去之前使用wordpress自己部署网站时解析的麻烦</li>
<li>https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/about-custom-domains-and-github-pages</li>
</ol>
<p>自定义域名在参考了上述链接后做了一点尝试：</p>
<ol type="1">
<li><p>首先域名还是使用的之前搭建wordpress用的threegates.net</p></li>
<li><p>这里开始需要做的是将域名重定向到github-pages，所以实际上<strong>需要参考的比较权威的文档是上面的链接3</strong></p>
<span id="more"></span></li>
<li><p>github
pages建议的是使用www域，说明了使用www域使pages也会为你进行apex
domain（即不带www的threegates.net）的重定向。</p>
<blockquote>
<p>We recommend always using a <code>www</code> subdomain, even if you
also use an apex domain. When you create a new site with an apex domain,
we automatically attempt to secure the <code>www</code> subdomain for
use when serving your site's content. If you configure a
<code>www</code> subdomain, we automatically attempt to secure the
associated apex domain.</p>
</blockquote></li>
<li><p>参考“Managing a custom domain for your GitHub Pages
site”，首先在gtihub repo的settings-&gt;pages目录下配置Custom
Domain，这里使用<code>www.threegates.net</code></p></li>
<li><p>在阿里云的DNS解析中配置，这里应该将<code>www.threegates.net</code>使用CNAME形式解析到我的<code>kalulas.github.io</code>，且通过dig工具和后续文档可以得知，如果配置了<code>threegates.net</code>到github
pages提供的四个DNS（见下文），github
pages会帮你重定向到网页内容，而<code>www.threegates.net</code>配置到<code>kalulas.github.io</code>之后，后面其实也是解析到github.pages的DNS</p></li>
<li><p>配置如图：<a href="/p/c9e58284d744/aliyun-dns-config.png" class="gallery-item"><img src="/p/c9e58284d744/aliyun-dns-config.png" class="" title="aliyun dns configuration"></a></p></li>
<li><p>dig命令解析结果如下（threegates.net的解析情况也一样）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ dig kalulas.github.io +nostats +nocomments +nocmd
; &lt;&lt;&gt;&gt; DiG 9.11.4-P2-RedHat-9.11.4-26.P2.el7_9.8 &lt;&lt;&gt;&gt; kalulas.github.io +nostats +nocomments +nocmd
;; global options: +cmd
;kalulas.github.io.             IN      A
kalulas.github.io.      3600    IN      A       185.199.109.153
kalulas.github.io.      3600    IN      A       185.199.111.153
kalulas.github.io.      3600    IN      A       185.199.110.153
kalulas.github.io.      3600    IN      A       185.199.108.153</code></pre>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ dig www.threegates.net +nostats +nocomment
; &lt;&lt;&gt;&gt; DiG 9.11.4-P2-RedHat-9.11.4-26.P2.el7_9.8 &lt;&lt;&gt;&gt; www.threegates.net +nostats +nocomment
;; global options: +cmd
;www.threegates.net.            IN      A
www.threegates.net.     600     IN      CNAME   kalulas.github.io.
kalulas.github.io.      3600    IN      A       185.199.109.153
kalulas.github.io.      3600    IN      A       185.199.111.153
kalulas.github.io.      3600    IN      A       185.199.110.153
kalulas.github.io.      3600    IN      A       185.199.108.153</code></pre></li>
<li><p>最后，在第4步中修改Custom
Domain会添加一个文件CNAME到repo的根目录下，但是由于使用了一键部署，实际上同步的目录是~/.../your_site/.deploy_git，可以在这个目录下同步，但是这个目录是由~/.../your_site/source生成而来的，所以得在source下也创建一个CNAME文件，内容就用github为你生成的<code>www.threegates.net</code>即可</p></li>
<li><p>最后，文档提示了可以enforce
HTTPS，这个在后续也加上了，工作正常</p></li>
</ol>
<h2 id="网站主题">网站主题</h2>
<p>当前维护中的next主题传送门：</p>
<ol type="1">
<li>官方文档：https://theme-next.js.org/docs/</li>
<li>github：https://github.com/next-theme/hexo-theme-next</li>
</ol>
<p>当前threegates的hexo是使用npm的方式安装主题并更新的，参考</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cd hexo-site
$ npm install hexo-theme-next</code></pre>
<p>一次在给博客的本地搜索功能debug的时候发现了现在next其实同时存在着多个github项目，和这些项目中指向的多个文档，导致容易阅读到一些与当前版本的不匹配内容...这边还是留意下，以上文中提供的两个链接为参考（当前next版本v8.14.1）。</p>
<figure>
<a href="https://s2.loli.net/2023/01/22/b8hiH1C3gnxD2Yo.png" title="记录于NexT v8.14.1" class="gallery-item"><img src="https://s2.loli.net/2023/01/22/b8hiH1C3gnxD2Yo.png"
alt="记录于NexT v8.14.1" /></a>
<figcaption aria-hidden="true">记录于NexT v8.14.1</figcaption>
</figure>
<p>顺带一提，我发现的停止维护项目有：</p>
<ol type="1">
<li><a href="https://github.com/theme-next/hexo-theme-next" title="" target="">theme-next&#x2F;hexo-theme-next</a>
注意这里用户名是<code>theme-next</code>而不是上文的<code>next-theme</code>...这个仓库release停留在了v7.8.0</li>
<li><a href="https://github.com/iissnan/hexo-theme-next" title="" target="">iissnan&#x2F;hexo-theme-next</a>
这个仓库中文内容很多，但是也已经停止维护，release停留在v5.1.4</li>
</ol>
<h3 id="next-主题配置">NexT 主题配置</h3>
<p>以前我们会将主题的配置内容放在
<code>themes/[theme_name]/_config.yml</code>，又或者放在
<code>node_modules/[theme_module_name]/_config.yml</code>
中，但是这样在升级主题时，我们的配置内容会被覆盖。实际上今年把博客的部署路径从
alicloud 挪到我个人笔记本的尝试中，就遇到了一些相关的问题。</p>
<p>从 hexo 5.0 起，hexo
就提供了将主题配置也放在网站/博客根目录的选择，可以参考<a
href="https://hexo.io/docs/configuration.html#Using-an-Alternate-Config">这篇文章</a>。现在，我们可以选择在根目录下创建一个
<strong>_config.next.yml</strong>
，并将原配置内容复制到这个新的配置文件中即可。</p>
<p>当然 hexo 还提供了其他方案，如在 <strong>_config.yml</strong> 下新增
theme_config 项，在这里为了更清晰的版本历史，我们选择了独立 yml
文件的方式。</p>
<p>当 hexo 在生成网站静态文件时，这些配置项会被合并。优先级顺序为：</p>
<ol type="1">
<li>网站根目录 <strong>_config.yml</strong> 中的 theme_config 项</li>
<li>网站根目录下独立的 <strong>_config.[theme].yml</strong>
配置文件</li>
<li><strong>themes</strong> 目录下的配置文件</li>
</ol>
<h3 id="调整代码配色主题">调整代码配色主题</h3>
<p>threegates 使用的代码配色/高亮引擎是 prism，在 hexo 配置文件
<strong>_config.yml</strong> 中有如下配置</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># hexo 7.0 起需要指定 highlighter
syntax_highlighter: prismjs
# highlight 部分也在这里，不同不重要
prismjs:
  preprocess: false
  line_number: true
  line_threshold: 0 # 可以配置超过多少行才显示行号
  tab_replace: &#39;    &#39;</code></pre>
<p>在主题配置文件 <strong>_config.next.yml</strong> 有如下配置</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">codeblock:
  # Code Highlight theme
  # All available themes: https:&#x2F;&#x2F;theme-next.js.org&#x2F;highlight&#x2F;
  # theme 部分配置可以无视
  # ...
  # prism 块下设置不同颜色主题下的代码配色方案
  prism:
    light: prism-tomorrow
    dark: prism-tomorrow
  # Add copy button on codeblock
  copy_button:
    enable: true
    # Available values: default | flat | mac
    style: default
  # Fold code block
  # NexT 新版本提供的折叠过长代码功能，旧版本配置会在这里因为缺少配置触发一个 Error...
  fold:
    enable: true
    height: 500</code></pre>
<p>如果需要预览配色方案的效果，可以前往<a
href="https://theme-next.js.org/highlight/">这个网站</a></p>
<h3 id="调整内联代码布局">调整内联代码布局</h3>
<p>由于内联代码的 style 为
<code>overflow-wrap: break-word</code>，生成出的博客内容必须保证内联代码块内容在同一行，从而导致部分行的中文内容无法填充完整，且间隔被均等分，看着特别不舒服。</p>
<p>目前的修改方式是手动调整了 next 主题的 css 生成规则文件
<strong>_mixins.styl</strong>，可能会由于后续的 next
主题更新被覆盖，需要注意。</p>
<pre class="line-numbers language-stylus" data-language="stylus"><code class="language-stylus">&#x2F;&#x2F; node_nodules&#x2F;hexo-theme-next&#x2F;source&#x2F;css&#x2F;_mixins.styl
word-wrap() &#123;
    &#x2F;&#x2F; overflow-wrap: break-word; &#x2F;&#x2F; &lt;- 移除
    word-break: break-all; &#x2F;&#x2F; &lt;- 新增
&#125;</code></pre>
<h3 id="样式layout自定义">样式（layout）自定义</h3>
<p>阅读了hexo和NEXT的模板相关文章，简单看了下关联的njx，ejs文件，想通过is_post()或者is_home()的helper方法实现一下仅在文章页显示阅读进度条的效果，但是似乎返回结果不正确，现在在next的github页提了issue还在等回复。</p>
<p>njx中的语法与ejs不完全相同，简单参考了非官方文档：</p>
<ol type="1">
<li>https://carrion.cc/20210201/85bc1840d3ea.html
核对了一下njk中的helper语法</li>
</ol>
<h3 id="图片墙">图片墙</h3>
<p>选用了hexo-light-gallery插件，传送门
https://github.com/lzane/hexo-light-gallery
按照教程安装了hexo-light-gallery，对<code>node_modules/hexo-light-gallery/src/renderer.js</code>
做了一点修改</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; node_modules&#x2F;hexo-light-gallery&#x2F;src&#x2F;renderer.js 
function addTag(data)&#123;
    var config &#x3D; this.config.lightgallery;
    if(!config)&#123;
        return;
    &#125;

    &#x2F;&#x2F; add js
    &#x2F;&#x2F; 这里本来 &#39;&gt;&#39; 在 &#39;&quot;&#39; 前面，会造成结构破坏
    data.content &#x3D; &#39;&lt;div class&#x3D;&quot;.article-gallery&quot;&gt;&#39;+data.content+&#39;&lt;&#x2F;div&gt;&#39;;
    data.content+&#x3D;&#39;&lt;script src&#x3D;&quot;&#39;+config.js+&#39;&quot;&gt;&lt;&#x2F;script&gt;&#39;;

    &#x2F;&#x2F; add css
    var css &#x3D; &#39;&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;&#39;+config.css+&#39;&quot; &#x2F;&gt;&#39;;
    data.content &#x3D; css + data.content;

    &#x2F;&#x2F; add plugins
    var plugins &#x3D; Object.keys(config.plugins);
    for (var plugin of plugins)&#123;
        var jsTag &#x3D; &#39;&lt;script src&#x3D;&quot;&#39;+config.plugins[plugin]+&#39;&quot;&gt;&lt;&#x2F;script&gt;&#39;;
        data.content +&#x3D; jsTag;
    &#125;
&#125;

&#x2F;&#x2F; ...
function render(data)&#123;
    if (ignore(data))&#123;
        return;
    &#125;
    &#x2F;&#x2F; 如果找不到图片标签，就不执行下面的代码，就不会在不需要的地方增加多余内容
    if (!imgRgr.exec(data.content))&#123;
        return;
    &#125;

    wrapImage.call(this,data);
    addTag.call(this,data);
    addRunnableTag.call(this,data);
&#125;;

</code></pre>
<p>在lightgallery提供的插件（插件的插件...）中补充了三个插件：</p>
<ol type="1">
<li>lg-thumbnail: 提供图片的缩略图</li>
<li>lg-zoom: 提供图片缩放功能</li>
<li>lg-fullscreen: 提供图片全屏预览功能</li>
</ol>
<p>三个插件都通过npm下载了.min.js文件，放置于/source/js/下，现在的<strong>_config.yml</strong>如下</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># Plugin: lightgallery https:&#x2F;&#x2F;github.com&#x2F;lzane&#x2F;hexo-light-gallery
lightgallery:
# if you don&#39;t specify the css or js source, the default cdn will be used.
# css: # css source url
# js: #js source url
# sorry that I can not find any cdn hosting following plugins,
# please self-host the plugin js and add url here
  plugins:
    lg-thumbnail: &#x2F;js&#x2F;lg-thumbnail.min.js
    lg-zoom: &#x2F;js&#x2F;lg-zoom.min.js
#   lg-autoplay:
    lg-fullscreen: &#x2F;js&#x2F;lg-fullscreen.min.js
#   lg-pager:
</code></pre>
<h3 id="基于模板进行html生成">基于模板进行html生成</h3>
<p>很在意html中的一些js代码资源标签&lt;script&gt;是怎么在生成时加上的，如图上的这种</p>
<a href="/p/c9e58284d744/image-20211224175532445.png" class="gallery-item"><img src="/p/c9e58284d744/image-20211224175532445.png" class="" title="html中的代码标签示例"></a>
<p>要知道它的生成机制才方便做一些js代码上传，还有cdn上的资源放到本地这样的操作，进行了一些排查大致定位下下面这些信息：</p>
<ol type="1">
<li><strong>index.njk</strong>文件里利用了<code>next_js()</code>这个方法来加载next提供的静态js文件，如
comments.js，utils.js 等等</li>
</ol>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; hexo-site-home&#x2F;node_modules&#x2F;hexo-theme-next&#x2F;layout&#x2F;_scripts&#x2F;index.njk

&#123;%- include &#39;vendors.njk&#39; -%&#125;

&#123;&#123;- next_js(&#39;comments.js&#39;) &#125;&#125;

&#123;&#123;- next_js(&#39;utils.js&#39;) &#125;&#125;
&#123;%- if theme.motion.enable %&#125;
  &#123;&#123;- next_js(&#39;motion.js&#39;) &#125;&#125;
&#123;%- endif %&#125;

&#123;%- if theme.scheme &#x3D;&#x3D;&#x3D; &#39;Muse&#39; or theme.scheme &#x3D;&#x3D;&#x3D; &#39;Mist&#39; %&#125;
  &#123;&#123;- next_js(&#39;schemes&#x2F;muse.js&#39;) &#125;&#125;
&#123;%- endif %&#125;

&#123;&#123;- next_js(&#39;next-boot.js&#39;) &#125;&#125;
&#123;%- if theme.bookmark.enable %&#125;
  &#123;&#123;- next_js(&#39;bookmark.js&#39;) &#125;&#125;
&#123;%- endif %&#125;
&#123;%- if theme.pjax %&#125;
  &#123;&#123;- next_js(&#39;pjax.js&#39;) &#125;&#125;
&#123;%- endif %&#125;
</code></pre>
<p>而在上面代码块的第一行看到了<code>&#123;%- include 'vendors.njk' -%&#125;</code>，找到对应的文件<strong>vendors.njk</strong>下可以看到</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; hexo-site-home&#x2F;node_modules&#x2F;hexo-theme-next&#x2F;layout&#x2F;_scripts&#x2F;vendors.njk

&#123;%- if theme.canvas_ribbon.enable %&#125;
  &lt;script size&#x3D;&quot;&#123;&#123; theme.canvas_ribbon.size &#125;&#125;&quot; alpha&#x3D;&quot;&#123;&#123; theme.canvas_ribbon.alpha &#125;&#125;&quot; zIndex&#x3D;&quot;&#123;&#123; theme.canvas_ribbon.zIndex &#125;&#125;&quot; src&#x3D;&quot;&#123;&#123; theme.vendors.canvas_ribbon.url     &#125;&#125;&quot;&gt;&lt;&#x2F;script&gt;
&#123;%- endif %&#125;

&#123;%- for name in js_vendors() %&#125;
  &#123;&#123; next_vendors(name) &#125;&#125;
&#123;%- endfor %&#125;
</code></pre>
<p><code>&#123;%- for name in js_vendors() %&#125;</code>遍历的就是<code>js_vendors()</code>方法返回的所有js资源标识符</p>
<ol start="2" type="1">
<li><code>js_vendors()</code>这个方法是在<strong>next-vendors.js</strong>中注册的，像prism-core的这些cdn上获取的js资源，先通过配置来决定是否push到返回的vendors列表中，逻辑如下</li>
</ol>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; hexo-site-home&#x2F;node_modules&#x2F;hexo-theme-next&#x2F;scripts&#x2F;helpers&#x2F;next-vendors.js

hexo.extend.helper.register(&#39;js_vendors&#39;, function() &#123;
  const &#123; config, theme &#125; &#x3D; this;
  const vendors &#x3D; [&#39;anime&#39;];
  if (config.prismjs.enable &amp;&amp; !config.prismjs.preprocess) &#123;
    vendors.push(&#39;prism&#39;, &#39;prism_autoloader&#39;);
   if (config.prismjs.line_number) &#123;
     vendors.push(&#39;prism_line_numbers&#39;);
    &#125;
  &#125;
  if (theme.pjax) &#123;
    vendors.push(&#39;pjax&#39;);
  &#125;
  if (theme.fancybox) &#123;
    vendors.push(&#39;jquery&#39;, &#39;fancybox_js&#39;);
  &#125;
  if (theme.mediumzoom) &#123;
    vendors.push(&#39;mediumzoom&#39;);
  &#125;
  if (theme.lazyload) &#123;
    vendors.push(&#39;lazyload&#39;);
  &#125;
  if (theme.pangu) &#123;
    vendors.push(&#39;pangu&#39;);
  &#125;
  return vendors;
&#125;);
</code></pre>
<p>从上文可以看到<code>vendors.njk</code>会遍历js_vendors列表，并且用拿到的每一个vendor_name去调用方法<code>next_vendors</code>，而这个方法就是在<strong>engine.js</strong>中注册的。</p>
<p><code>next_vendors</code>的逻辑就是查找vendor的相应配置，vendors字段中的内容是从主题目录下的<strong>_vendors.yml</strong>这个yaml配置文件中解析出来的。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; hexo-site-home&#x2F;node_modules&#x2F;hexo-theme-next&#x2F;scripts&#x2F;helpers&#x2F;engine.js
&#x2F;&#x2F; ...
hexo.extend.helper.register(&#39;next_vendors&#39;, function(name) &#123;
  const &#123; url, integrity &#125; &#x3D; this.theme.vendors[name];
  const type &#x3D; url.endsWith(&#39;css&#39;) ? &#39;css&#39; : &#39;js&#39;;
  if (type &#x3D;&#x3D;&#x3D; &#39;css&#39;) &#123;
    if (integrity) return &#96;&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;$&#123;url&#125;&quot; integrity&#x3D;&quot;$&#123;integrity&#125;&quot; crossorigin&#x3D;&quot;anonymous&quot;&gt;&#96;;
    return &#96;&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;$&#123;url&#125;&quot;&gt;&#96;;
  &#125;
  if (integrity) return &#96;&lt;script src&#x3D;&quot;$&#123;url&#125;&quot; integrity&#x3D;&quot;$&#123;integrity&#125;&quot; crossorigin&#x3D;&quot;anonymous&quot;&gt;&lt;&#x2F;script&gt;&#96;;
  return &#96;&lt;script src&#x3D;&quot;$&#123;url&#125;&quot;&gt;&lt;&#x2F;script&gt;&#96;;
&#125;);
</code></pre>
<ol start="3" type="1">
<li>所以如果想加一个js文件资源引用，可以考虑作为一个静态资源加入项目，并在<strong>index.njk</strong>就利用<code>next_js()</code>加载；也可以考虑在<strong>next-vendors.js</strong>代码中将这个js文件的标识符push到<code>vendors</code>里面，然后再到theme（也就是我这里使用的NexT）的<strong>_vendors.yml</strong>文件里面去注册这个标识符对应的文件路径，版本等，这样想要通过cdn加载js文件也方便。</li>
<li>实际上针对上述方法二，这个<strong>_vendors.yml</strong>是可以使用这个项目
<a href="https://github.com/next-theme/plugins" title="" target="">next-theme-plugins</a>
生成的，我自己试过也成功了。不过对于一些小改动（比如为prism添加一个prism-download-button.js），自己做下<strong>_vendors.yml</strong>的修改，加入一个条目也是很简单的，不需要安装那么多依赖项。</li>
</ol>
<h2 id="资源文件夹">资源文件夹</h2>
<p>网站需要显示一些像网站图标和用户画像，还有文章中的截图这样的资源，参考hexo文档，最后采用的方式是将配置项<code>post_asset_folder</code>设置为true，这会让hexo在新建post时为这个post新建一个同名资源文件夹。然后使用<a
href="https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a>
3.1.0
的特性，在文章中直接使用markdown图片格式，图片链接直接填写图片文件名，hexo会将资源请求重定向到post的同名资源文件夹中。</p>
<p>值得一提的是也可以在其他post中使用相对路径来索引到这些资源，为post之间共享资源提供了思路。</p>
<p><strong>_config.yml</strong>配置形式如下：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">post_asset_folder: true
marked:
  prependRoot: true
  postAsset: true</code></pre>
<h2 id="hexo以及next的更新">hexo以及next的更新</h2>
<p>从各自的官方文档或者npm都能查看到当前的最新版本，据说NexT是每个月都会发布新版本的，遇到问题都可以留意一下是不是最新版本（当然也要做好回退的准备，更新hexo和next时都记得备份<strong>_config.yml</strong>）。</p>
<p>贴一下npm对应package的链接:</p>
<ol type="1">
<li><a href="https://www.npmjs.com/package/hexo" title="" target="">hexo</a>
<p>npm package</p></li>
<li><a href="https://www.npmjs.com/package/hexo-theme-next" title="" target="">hexo-theme-next</a>
<p>npm package</p></li>
</ol>
<p>执行npm命令来检查packages是否有新版本：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cd hexo-site
$ npm outdated</code></pre>
<p>使用npm进行package更新（当然，hexo本身也是一个package），并使用参数<code>--save</code>将改动保存到package.json：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cd hexo-site
$ npm update &lt;package-name&gt; --save</code></pre>
<p>或者使用npm-check-updates，来将package.json更新到最新版本，再一次性全部安装最新版</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ npm i npm-check-updates -g # 如果你没有安装过npm-check-updates
$ ncu # 检查版本更新，类似npm outdated，ncu是npm-check-updates的别名
$ ncu -u # 更新package.json
$ ncu package_name [-u] # 仅检查单个&#x2F;多个包的更新，添加参数来应用到 package.json
$ npm install # npm按照更新后的package.json进行安装</code></pre>
<p>输出如下：</p>
<figure>
<a href="https://s2.loli.net/2023/01/22/eLjDP1XYNJ6o73t.png" title="使用npm-check-updates进行npm package更新" class="gallery-item"><img src="https://s2.loli.net/2023/01/22/eLjDP1XYNJ6o73t.png"
alt="使用npm-check-updates进行npm package更新" /></a>
<figcaption aria-hidden="true">使用npm-check-updates进行npm
package更新</figcaption>
</figure>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script src="/js/lg-thumbnail.min.js"></script><script src="/js/lg-zoom.min.js"></script><script src="/js/lg-fullscreen.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>]]></content>
      <categories>
        <category>博客搭建</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>games101-lecture14 笔记</title>
    <url>/p/9f45e6ee4d77/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="today">Today</h1>
<ul>
<li>Acceleration 加速结构：使用AABB来加速光线追踪
<ul>
<li>Uniform grids</li>
<li>Spatial partitions</li>
</ul></li>
<li>Basic radiometry（辐射度量学）
<ul>
<li>进阶：不同于Whitted-Style的光线追踪</li>
</ul></li>
</ul>
<h1 id="光线追踪加速结构">光线追踪加速结构</h1>
<h2 id="均匀网格方案uniform-grids">均匀网格方案：Uniform grids</h2>
<p><strong>预处理：构建加速网格</strong></p>
<p>找一个包围盒，在包围盒中构建均匀网格，记录每一个与物体相交的网格</p>
<p><strong>光线与场景求交</strong></p>
<p>射出一道光线，让光线与格子求交，若格子内存在物体，再让光线与物体求交：光线与格子求交是快速的，而与实际物体求交是很慢的，通过这样的理念来优化</p>
<p><strong>经验告诉我们</strong></p>
<p>当格子数等于C * 对象数时，结果会比较好；三维空间下常数C可以取27</p>
<p><strong>缺陷</strong></p>
<p>当细节物品在空间中分布不均匀时，存在大规模集中、大规模空白：”Teapot
in a stadium” problem</p>
<p>*在一些场景下还是好用的，仍有在使用</p>
<h2 id="空间划分-spatial-partitions">空间划分 Spatial partitions</h2>
<figure>
<a href="https://s2.loli.net/2023/09/17/QPXy1Yma5cLDHVo.png" title="空间划分树结构" class="gallery-item"><img src="https://s2.loli.net/2023/09/17/QPXy1Yma5cLDHVo.png"
alt="空间划分树结构" /></a>
<figcaption aria-hidden="true">空间划分树结构</figcaption>
</figure>
<span id="more"></span>
<p><strong>Oct-Tree
八叉树</strong>：三维空间划分为8份，在格子类数量足够少，或者划分次数足够多时不再划分。</p>
<p>想让空间得到划分，但是不想随着维度不断提高子节点指数级增长，发明了KD-Tree。</p>
<p><strong>KD-Tree（本次重点）</strong>：每次对格子只进行一次划分，划分为两个区域；每次进行划分时采取与上一次不同的轴向，可以得到尽可能均匀的划分结果。（Root:
axis-x，layer1: axis-y，layer2: axis-z）</p>
<p><strong>BSP-Tree</strong>：同样是空间二分方法，区别在于不是水平竖直地进行划分</p>
<aside>
⚠️
同样像上文的Uniform-Grids，空间划分是在光线追踪前的预处理，先建立KD-tree
</aside>
<figure>
<a href="https://s2.loli.net/2023/09/17/DXlbzgTZG3AHxYL.png" title="KD-tree划分结果" class="gallery-item"><img src="https://s2.loli.net/2023/09/17/DXlbzgTZG3AHxYL.png"
alt="KD-tree划分结果" /></a>
<figcaption aria-hidden="true">KD-tree划分结果</figcaption>
</figure>
<h3 id="kd-trees-数据结构">KD-Trees 数据结构</h3>
<p>中间节点存储（A，B，C）：</p>
<ul>
<li>划分使用的轴（x, y, z）</li>
<li>划分的位置（在轴向上的什么地方划分）</li>
<li>所有子节点指针</li>
<li>注意中间节点不存储对象（objects）</li>
</ul>
<p>叶子节点存储（1，2，3）：</p>
<ul>
<li>对象的列表存储</li>
</ul>
<h2 id="遍历kd-tree进行求交">遍历KD-Tree进行求交</h2>
<p>如果光线与中间节点代表的区域相交，就意味着光线也要与中间节点划分出的子节点判定相交；递归此过程，最后达到一个叶子节点，就和叶子节点中的所有对象求交。</p>
<h3 id="进阶问题">进阶问题</h3>
<p><strong>如何判定对象与包围盒的相交关系</strong></p>
<p>需要考虑三角形与盒子的求交</p>
<p>空间划分涉及的问题，如何判断对象是否在某个划分的格子内？</p>
<p>或者，某个划分出来的各自内有哪些对象？</p>
<p>虽然有现成的算法，但是不容易写对，在一些情境下容易犯错。</p>
<p><strong>对象重复出现在不同的划分格子中</strong></p>
<figure>
<a href="https://s2.loli.net/2023/09/17/2mgejXkSHtpMG9s.png" title="重复出现在不同分区中的物体" class="gallery-item"><img src="https://s2.loli.net/2023/09/17/2mgejXkSHtpMG9s.png"
alt="重复出现在不同分区中的物体" /></a>
<figcaption aria-hidden="true">重复出现在不同分区中的物体</figcaption>
</figure>
<p>如图中的这个圆，出现在分区3，4，5内，即这三个分区内会重复出现这个圆</p>
<h2 id="object-partitions-bounding-volumn-hierarchybvh">Object
Partitions &amp; Bounding Volumn Hierarchy(BVH)</h2>
<p>解决了上述KD-Tree的两个问题，目前图形学更受欢迎的结构。</p>
<p>划分的不是空间，而是把物体分为两个部分；如下例，把一个盒子内的三角形分成了两个部分（基于某种标准），之后再分别计算两个部分的包围盒。</p>
<figure>
<a href="https://s2.loli.net/2023/09/17/32mh5ERYDCQy4ZG.png" title="BVH示例" class="gallery-item"><img src="https://s2.loli.net/2023/09/17/32mh5ERYDCQy4ZG.png"
alt="BVH示例" /></a>
<figcaption aria-hidden="true">BVH示例</figcaption>
</figure>
<p>特性：</p>
<ul>
<li>一个物体只可能出现在一个格子（分区）里</li>
<li>求所有三角形包围盒算法也很简单，不用计算三角形和盒子的相交关系</li>
<li>每个分区可能有相交：关于怎么将其划分为两个部分，很有讲究，有相关的研究</li>
</ul>
<p>详解做法：</p>
<ol type="1">
<li>找到一个包围盒</li>
<li>递归地将其内部的对象分为两个子集</li>
<li>重新计算子集地包围盒</li>
<li>适当地停止（子集数量足够少，划分次数足够多）</li>
<li>将物体存储在每一个叶子节点中</li>
</ol>
<p>如何划分一个节点/分区：</p>
<ul>
<li>选择一个划分的维度</li>
<li>经验谈
#1：沿着分区里最长的轴向划分，让它变短，更容易形成均匀分区</li>
<li>经验谈
#2：取”中间”的物体：在即将划分的轴向上，进行排序（若划分x轴，则对x坐标进行排序），取中位数序号（n/2）的物体进行划分，可以让两个子分区的数量接近，从而让树的深度更小，搜索更快
<ul>
<li><strong>无序数组中求第i大的数</strong>，实际上可以不需要排序<span
class="math inline">\(O(nlgn)\)</span>：快速选择算法 <span
class="math inline">\(O(n)\)</span> →
快速排序算法的启发，算法中Partition做完后，只对其中一边进行操作</li>
</ul></li>
</ul>
<h3 id="bvh的数据结构">BVH的数据结构</h3>
<p>中间节点存储：</p>
<ul>
<li>包围盒</li>
<li>子节点的指针</li>
</ul>
<p>叶子节点存储：</p>
<ul>
<li>包围盒</li>
<li>包含对象的列表</li>
</ul>
<h2 id="两类划分的比较">两类划分的比较</h2>
<h3 id="空间划分kd-tree">空间划分：KD-tree</h3>
<ul>
<li>将空间划分为不重叠的两个分区</li>
<li>一个物体可能存在于多个分区内</li>
</ul>
<h3 id="物体划分bvh">物体划分：BVH</h3>
<ul>
<li>将对象划分为不相交的子集</li>
<li>不同集合的包围盒可能在空间上重叠</li>
</ul>
<p>因为实现容易，效率也不错，BVH得到了更大的应用</p>
<p>加速结构完成后，光线和场景的求交就能在很短的时间内完成</p>
<h1 id="辐射度量学-radiometry">辐射度量学 Radiometry</h1>
<h2 id="动机-motivation">动机 motivation</h2>
<p>为什么需要辐射度量学？</p>
<p>来自过去的疑问：</p>
<ul>
<li>Blinn-Phong模型中的光线强度 <span
class="math inline">\(I=10\)</span>，单位是？</li>
<li>Whitted style的光线追踪看起来是正确结果吗？</li>
</ul>
<p>Blinn-Phong模型有许多简化，人为设置的内容，而辐射度量学可以对光的行为提供精确描述</p>
<h2 id="内容">内容</h2>
<ul>
<li>测度系统与光照的单位</li>
<li>对光的空间属性的精确描述
<ul>
<li>光照的若干属性：Radiant flux, intensity, irradiance, radiance</li>
</ul></li>
<li>通过物理上正确的方式（a physically correct
manner）来进行光照计算</li>
</ul>
<aside>
ℹ️ 学习方式的分享：WHY, WHAT, then
HOW。先是为什么学，再是学的是什么东西，最后是具体的原理，实现/应用方式
</aside>
<h3 id="radiant-energy-and-flux-power">Radiant Energy and Flux
(Power)</h3>
<p>Radiant energy：电磁辐射的能量，单位焦耳（J）</p>
<p><span class="math display">\[
\begin{equation}Q[\mathrm{~J}=\text { Joule }]\end{equation}
\]</span></p>
<p>Radiant flux(<strong>power</strong>)：单位时间的能量，energy per unit
time，得到功率，单位瓦特（W），图形学使用的另一个单位（<strong>lumen
流明</strong>）</p>
<p><span class="math display">\[
\begin{equation}\Phi =\frac{\mathrm{d} Q}{\mathrm{~d}
t}[\mathrm{~W}=\mathrm{Watt}][\mathrm{lm}=\text { lumen
}]^*\end{equation}
\]</span></p>
<p>另一种flux的理解：单位时间内通过感光平面的光子数量</p>
<p><strong>其他的重要物理量</strong></p>
<ul>
<li>光源辐射出的能量：Radiant Intensity</li>
<li>表面接收到的能量：Irradiance</li>
<li>光线沿着射线的传输：Radiance</li>
</ul>
<h3 id="radiant-intensity">Radiant Intensity</h3>
<p>定义：power per uint solid angle，每单位立体角的功率，单位
<strong>candela</strong></p>
<p><span class="math display">\[
\begin{equation}\left[\frac{\mathrm{W}}{\mathrm{sr}}\right]\left[\frac{\mathrm{lm}}{\mathrm{sr}}=\mathrm{cd}=\text
{ candela }\right]\end{equation}
\]</span></p>
<p><strong>什么是立体角？</strong></p>
<figure>
<a href="https://s2.loli.net/2023/09/17/wI8arSMgVsCc7Ll.png" title="单位立体角" class="gallery-item"><img src="https://s2.loli.net/2023/09/17/wI8arSMgVsCc7Ll.png"
alt="单位立体角" /></a>
<figcaption aria-hidden="true">单位立体角</figcaption>
</figure>
<p>角度的定义，弧长除以半径，弧度制。</p>
<p><strong>立体角</strong>：弧度在三维空间的延伸。在三维空间的球中找一个锥，这个锥在球上有一个球表面积，将这个面积除以球半径的平方。因为球表面积是
<span class="math inline">\(4\pi{r}^2\)</span>，所以球有<span
class="math inline">\(4\pi\)</span>立体角（steradians）</p>
<p>单位立体角（Differential Solid Angles）：</p>
<p><span class="math display">\[
\begin{equation}\begin{aligned}\mathrm{d} A &amp; =(r \mathrm{~d}
\theta)(r \sin \theta \mathrm{d} \phi) \\&amp; =r^2 \sin \theta
\mathrm{d} \theta \mathrm{d} \phi\end{aligned}\end{equation}
\]</span></p>
<p><span class="math display">\[
\begin{equation} \mathrm{d} \omega=\frac{\mathrm{d} A}{r^2}=\sin \theta
\mathrm{d} \theta \mathrm{d} \phi \end{equation}
\]</span></p>
<p>为什么是面积微分<span class="math inline">\(\mathrm{d} A\)</span>
的一个因数是 <span class="math inline">\(r \sin \theta \mathrm{d}
\phi\)</span>，可以看蓝线这个圆上的弧</p>
<figure>
<a href="https://s2.loli.net/2023/09/17/2oKzTQVYgqm5ilL.png" title="球表面面积微分" class="gallery-item"><img src="https://s2.loli.net/2023/09/17/2oKzTQVYgqm5ilL.png"
alt="球表面面积微分" /></a>
<figcaption aria-hidden="true">球表面面积微分</figcaption>
</figure>
<p><strong>回头看Intensity的定义</strong></p>
<p>intensity，即为power在某一个方向的微分。所以如果对于均匀的点光源，有以下：</p>
<p><span class="math display">\[
\begin{equation} I = \frac{\Phi}{4\pi}\end{equation}
\]</span></p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script src="/js/lg-thumbnail.min.js"></script><script src="/js/lg-zoom.min.js"></script><script src="/js/lg-fullscreen.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>]]></content>
      <categories>
        <category>计算机图形学</category>
        <category>RayTracing</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>RayTracing</tag>
        <tag>空间划分</tag>
      </tags>
  </entry>
  <entry>
    <title>使用SSH进行远端仓库身份验证</title>
    <url>/p/6f279d447649/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="使用ssh进行github身份验证">使用ssh进行GitHub身份验证</h2>
<h3 id="生成ssh-key">生成ssh key</h3>
<p>使用ssh
key进行连接/身份校验，需要先生成公私密钥，将公钥放到对应代码托管平台上，并在连接时使用相应的私钥。github目前推荐的keygen签名算法，以及<a
href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">密钥对生成方式</a>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;
&gt; ...</code></pre>
<p>生成公私密钥对后，将公钥放到对应代码托管平台上看起来像是下面这样。在进行ssh连接时，默认会使用唯一的私钥进行校验</p>
<a href="/p/6f279d447649/github-ssh-example.png" class="gallery-item"><img src="/p/6f279d447649/github-ssh-example.png" class="" title="github用户信息页的Authentication Keys"></a>
<p>同时，可以将github的public
key存放到自己设备的<code>~/.ssh/known_hosts</code>下，就不会在初次使用ssh连接github时需要手动校验</p>
<p><a
href="https://docs.github.com/cn/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints">GitHub
的 SSH 密钥指纹 - GitHub Docs</a></p>
<div class="note info"><p>😅 手动校验时会输出下述类似内容，你可能已经见过了…</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; The authenticity of host &#39;[ssh.github.com]:443 ([140.82.112.36]:443)&#39; can&#39;t be established.&gt; ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF&#x2F;zLDA0zPMSvHdkr4UvCOqU...</code></pre>
</div>
<span id="more"></span>
<h3 id="ssh-config-配置">ssh config 配置</h3>
<p>在一台设备上使用ssh-keygen生成多个公私密钥，将公钥放到对应代码托管平台上，再通过编辑<code>~/.ssh/config</code>来决定什么情况下使用哪一个私钥进行校验。</p>
<p>在一些情况下，还需要编辑.git目录下的config文件，来指定fetch /
push时使用的url。</p>
<p>生成多个公私钥对之后，使用config如此配置</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text"># Default GitHub
Host github.com # 使用&#96;ssh -T username@host&#96;中匹配的&#96;host&#96;会被解析为下面的HostName
 HostName github.com
 User git
 PreferredAuthentications publickey
 IdentityFile ~&#x2F;.ssh&#x2F;id_ed25519 # 对应的私钥

# Work GitHub 第二个账号
Host work.github.com # 同理，这里用&#96;work.github.com&#96;匹配此规则，会被解析为github.com
 HostName github.com
 User git
 PreferredAuthentications publickey
 IdentityFile ~&#x2F;.ssh&#x2F;id_rsa_work # 指定对应的私钥</code></pre>
<p>测试配置是否成功</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ssh -T git@github.com
Hi stefano! You&#39;ve successfully authenticated, but GitHub does not provide shell access.

$ ssh -T git@work.github.com
Hi stefano! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></pre>
<p>参考：</p>
<p><a
href="https://stackoverflow.com/questions/3225862/multiple-github-accounts-ssh-config">https://stackoverflow.com/questions/3225862/multiple-github-accounts-ssh-config</a></p>
<h2 id="问题解决通过https的ssh连接">问题解决：通过HTTPS的SSH连接</h2>
<p>在命令行执行<code>ssh -T git@github.com</code>时可能得到下述的输出结果</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh: connect to host github.com port 22: Connection timed out</code></pre>
<p>这个问题可能是由于所在设备防火墙禁用了ssh连接（我也怀疑可能是因为墙导致github.com解析失败，因为同样使用port22的我自己的gitea是可以使用ssh连接/验证的，而我使用的clash只设置了http
/ https的代理）。</p>
<p>这个问题可以参考stackoverflow或者官方的解决方案：</p>
<p><a
href="https://stackoverflow.com/questions/15589682/ssh-connect-to-host-github-com-port-22-connection-timed-out">ssh:
connect to host github.com port 22: Connection timed out</a></p>
<p><a
href="https://docs.github.com/en/authentication/troubleshooting-ssh/using-ssh-over-the-https-port">Using
SSH over the HTTPS port - GitHub Docs</a></p>
<div class="note info"><p>💡 443是https使用的端口，顺带一提，http使用的端口是80。</p>
<p>核心思路是github也部署了<code>ssh.github.com</code>这个域名，并借用443端口来建立ssh连接，因为大多数设备环境是不会禁用443端口的。</p>
</div>
<p>在命令行执行以下命令来测试是否可以使用此解决方案：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ssh -T -p 443 git@ssh.github.com
&gt; Hi USERNAME! You&#39;ve successfully authenticated, but GitHub does not
&gt; provide shell access.</code></pre>
<p>如果得到了上述输出，现在你可以通过以下命令来clone你的仓库了：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git clone ssh:&#x2F;&#x2F;git@ssh.github.com:443&#x2F;YOUR-USERNAME&#x2F;YOUR-REPOSITORY.git
&gt; ...</code></pre>
<h3 id="通过ssh-config建立基于https的ssh连接">通过ssh
config建立基于https的ssh连接</h3>
<p>想要更便利地使用443端口来建立与github的ssh连接，可以使用编辑<code>~/.ssh/config</code>的方式，在配置文件中加入/调整下述内容</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Host github.com
 Hostname ssh.github.com # 注意这里是另一个github域名
 Port 443 # 使用443端口
 User git</code></pre>
<p>现在，你可以像之前一样使用ssh连接GitHub.com了</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ssh -T git@github.com
&gt; Hi USERNAME! You&#39;ve successfully authenticated, but GitHub does not
&gt; provide shell access.</code></pre>
<p>P.S. gitlab也有类似的解决方案，可以参考：<a
href="https://about.gitlab.com/blog/2016/02/18/gitlab-dot-com-now-supports-an-alternate-git-plus-ssh-port/">gitlab使用https建立ssh连接</a></p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script src="/js/lg-thumbnail.min.js"></script><script src="/js/lg-zoom.min.js"></script><script src="/js/lg-fullscreen.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>]]></content>
      <categories>
        <category>工具使用指南</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内存管理（基础概念）</title>
    <url>/p/0a6e6f8be357/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><p>翻译自：<a
href="https://perfetto.dev/docs/case-studies/memory#heapprofd">https://perfetto.dev/docs/case-studies/memory#heapprofd</a></p>
<p>想看一下项目在真机上的表现，所以工作之余用了Perfetto来做项目的性能测试。阅读官方文档的时候发现了这一章节介绍了Linux内存管理的一些基础概念，所以就简单翻译了一下。</p>
<hr />
<aside>
ℹ️
在开始之前提醒一下，KB和KiB实际是不同的单位，一般是用KB指1,000byte，而KiB指1,024byte
</aside>
<p>从内核的角度，内存被划分为等大小4KiB的块，这些块被称为页（pages）。</p>
<p>这些页被组织于连续的虚拟空间中，此空间称为VMA（Virtual Memory
Area）。</p>
<p>当一个进程通过 mmap()
系统调用请求内存时，VMA就会被创建。一般情况下，应用不会直接调用mmap()，而是通过内存分配器间接调用，像是
C 的 <code>malloc()</code>, C++ 的 <code>operator new()</code> 或是 Java
的 <code>new X()</code> 等等。</p>
<p>VMA可以被分为两种类型：文件后备页（file-backed）与匿名页（anonymous）。</p>
<span id="more"></span>
<h2 id="文件后备页file-backed-vmas"><strong>文件后备页（File-backed
VMAs）</strong></h2>
<p>文件在内存中的一种视图。它们可以通过将文件描述符传入<code>mmap()</code>来获得。内核会通过传入的文件来处理VMA上发生的缺页错误，所以读VMA上的指针，就和对文件进行
read() 操作是等价的了。当执行新的进程，加载动态链接库，安卓框架加载.dex
库和APK中的资源文件时，文件后备页都会被访问。</p>
<h2 id="匿名页anonymous-vmas"><strong>匿名页（Anonymous
VMAs）</strong></h2>
<p>不被任何文件备用的内存空间。内存分配器就是通过这种方式从内核请求动态内存的。匿名页可以通过调用
<code>mmap(… MAP_ANONYMOUS …)</code> 来获取。</p>
<p>当应用试图对VMA进行读写操作时，物理内存只会被以页的粒度（granularity）进行分配。设想你在页上分配了32MiB的大小，但只对其中的一个字节做了读写操作，那么你的进程实际上只会增加4KiB的内存占用。虽然你的进程确实增加了32MiB的虚拟没存，但它的常驻（resident）物理内存只会增加4KiB。</p>
<p>当优化程序的内存使用时，我们一般着眼于减少它们在物理内存中的占用（footprint）。因为在现代的设备平台上，过高的虚拟内存占用一般不需要我们过分关注（除非过多的占用导致虚拟地址空间不足，这在64位系统上是很难发生的）。</p>
<p>我们将一个进程驻留在物理内存上的内存称为它的<strong>RSS</strong>（Resident
Set Size常驻集大小）。尽管如此，常驻内存也存在着不同。</p>
<p>从内存消耗的角度来看，在VMA中独立的页可能存在以下状态：</p>
<ul>
<li><strong>Resident</strong>：此页被映射到物理内存页上。常驻页可能有以下两种状态：
<ul>
<li><strong>Clean</strong>（仅对文件后备页）：页上的内容与硬盘（外存，on-disk）上的内容一致。当内存压力大时，内核可以更轻易地移除clean状态的页。因为当需要这些页时，内核只要读取它们相应的文件，就能重建它们的内容。</li>
<li><strong>Dirty</strong>：页上的内容与硬盘上的内容不同，或者（更常见的情况）此页没有硬盘上的备份（匿名页）。dirty状态的页不能够被移除，因为这将导致数据丢失。不过它们可以被移出到硬盘，或者ZRAM上。</li>
</ul></li>
<li><strong>Swapped</strong>：脏页能够被写入到硬盘上的swap文件（大多数linux桌面发布版），或者进行压缩（在安卓和CrOs上通过<strong>ZRAM</strong>进行）。此页会保持swapped状态，直到虚拟地址的缺页错误发生，这时候，此页会重新被带回主存。</li>
<li><strong>Not
present</strong>：此页从未发生缺页错误，且此页为clean状态，稍后将被移除。</li>
</ul>
<p>一般来说减少dirty内存的占用量是更重要的，因为它们不能像clean内存那样被回收重用。在安卓设备上，即时它被转移到ZRAM，它仍然会占用（吃掉）部分的系统内存。所以在
<code>dumpsys meminfo</code> 的例子中，我们会格外关注 <em>Private
Dirty</em>。</p>
<p><strong>Shared</strong>
内存能被映射到多个进程中。这意味着不同进程的VMA可能会指向同一块物理内存。一个常见的例子是通用库（举例
libc.so，framwork.dex）的文件后备内存，或者更罕见的一个例子是，一个进程执行了
<code>fork()</code>，而子进程继承了来自它的 dirty 内存。</p>
<p>这就引入了<strong>PSS</strong>（Proportional Set Size
比例分配集大小，Proportional
等比分配的）的概念。在<strong>PSS</strong>中，多个进程占用的Resident状态内存会被等比地进行分配。如果我们将4KiB页映射到四个进程，那么每个进程的<strong>PSS</strong>仅会新增1KiB。</p>
<h2 id="回顾">回顾</h2>
<ul>
<li>动态分配的内存，像是通过 C的 <code>malloc()</code>,
C++的 <code>operator new()</code> 或者
Java的 <code>new X()</code> 进行分配内存总是 匿名 且 dirty
的，除非它从未被使用过。</li>
<li>如果内存在一段时间内没有被读写，为了减轻内存压力，它会被换出到ZRAM上并且进入到swapped状态。</li>
<li>Resident（且dirty）或是swapped状态的匿名内存总是耗费资源的，如无必要，需要尽可能避免。</li>
<li>来自代码（java代码，原生代码）的文件映射内存，库以及资源文件几乎总是clean状态。Clean状态的内存一样会带来系统内存开销，但通常应用开发者对它没有太大控制权。</li>
</ul>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script src="/js/lg-thumbnail.min.js"></script><script src="/js/lg-zoom.min.js"></script><script src="/js/lg-fullscreen.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>]]></content>
      <categories>
        <category>计算机科学</category>
        <category>操作系统</category>
        <category>内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>通关后简单地评价一下P5R</title>
    <url>/p/a31f36d806f9/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="写在前面">写在前面</h2>
<p>从最早17年看<a
href="https://www.bilibili.com/video/BV1ux411k7Pk?spm_id_from=333.999.0.0">狗头人玩女神异闻录5</a>，到17下半年自己攒钱买了显示器和缩水版的ps4slim在寝室里自己玩，再到19年皇家版游戏发售找代购入了收藏版，我终于在22年年初换了工作之后忙里偷闲地把它作为psn平台上的第一个白金游戏通关了。</p>
<a href="/p/a31f36d806f9/platinum-award.jpg" class="gallery-item"><img src="/p/a31f36d806f9/platinum-award.jpg" class="" title="其实也得谢谢皇家版是一款相对容易白金的游戏"></a>
<p>前前后后五年间跟这个系列之间的故事自然也不少了，虽然至今为止也不能说自己是一个很合格的系列粉丝——并不是那种真的和系列一起长大的玩家，除了通关了第五代游戏和在系列上花了不少钱其实也没有什么拿的出手的粉丝证明，但是还是想在这里简单地记录一下皇家版与我之间的故事，并以不成熟的测评人身份说说我对皇家版的看法。</p>
<p><strong>注意：本文可能含有大量剧透，请尚未以任何形式通关《女神异闻录》《女神异闻录5皇家版》的读者自行选择是否继续阅读。</strong></p>
<span id="more"></span>
<h2 id="不得了的演唱会和增强版">不得了的演唱会和增强版</h2>
<h3 id="在线观赏低清演唱会现场">在线观赏低清演唱会现场</h3>
<p>19年4月的时候，p5r和p5s宣布在演唱会的前后两天宣布发售，大二在读的我自然也没什么办法跑去岛国演唱会现场，就充了niconico收费会员在线上同步视听，当时糟糕的梯子+niconico悲剧的直播体验结合起来，整场演唱会基本就是只能挂在后台听的水平。不过day1第一天p5r公布的时候，还是能大概只有256p的画面里看出现场观众的兴奋（当然，我也）。</p>
<p>相较day1放出的加强版预告，day2公布的是一个光荣开发的系列衍生割草游戏p5s，自然就没能激起多大水花，而且现在回想起来，当时放出pv也是得背锅的——没把该作即时战斗的乐趣体现出来，同时对新角色也只给了一个很诡异的特写（其实后面玩过的大家都知道索菲亚超可爱）。</p>
<p>来商店感受一下索菲亚的可爱和p5系列作之中也算得上带感的bgm，<a
href="https://www.bilibili.com/video/BV14T4y1J7ws?from=search&amp;seid=10262646871642464225&amp;spm_id_from=333.337.0.0">传送门
-&gt;</a></p>
<p>当时兴头上的我自然是找到能代购店的第一时间就下单了。虽然当时心里也清楚加强版的大多剧情和无印版（也就是最早发售的非加强版）没什么区别，但也想着能够体验一下初见的乐趣，也许能带来更大的感触也说不定。</p>
<a href="/p/a31f36d806f9/unbox.jpg" class="gallery-item"><img src="/p/a31f36d806f9/unbox.jpg" class="" title="现在想起来这一箱送的东西除了cd还真没啥有用的"></a>
<p>然而虽然日文版如约在19年的11月送达了宿舍，当时我已经在为毕业去向苦恼了，而且日文版没什么差异的开头剧情也让我没能特别抽出空来玩。结果一直到20年中文版发售，这时候我甚至已经下单了中文版，却依然没能正式地开始游戏，只是零星地玩了一点点。而这时候，一些关于皇家版的中文评价就开始扩散开来了...</p>
<p>这里就会扯到我这几年对atlus发过的一些牢骚，其中第一点就是希望他们<strong>不要再把日文版和非日文版分开时段发售了</strong>，这样想要日语苦手的玩家想在不被剧透，不被他人的主观评价影响的情况下享受初见的乐趣，几乎是一件不可能的事。</p>
<h3 id="那年评论版的回忆录">那年评论版的回忆录</h3>
<p>皇家版发售之后无论是国内国外，评论都不能说是特别乐观，当时感触由其深的是在国内的一些主流游戏媒体上，评论已经清一色是“P5R也就图一乐”的走向了（有关注的人可能知道随后紧跟的便是“真续作还得看我P5S”），普遍认为P5R有强推主人公与明智CP嫌疑（1），女主过于路人化（2），新增剧情太短、前部分的剧情又与无印版无二（3），想进入皇家版剧情路线必须与特定角色建立COOP令人不快（4）等等。其中第一点和第三点应该是我所浏览过的众多评论中最突出的两种声音。</p>
<p>事情发展到这个阶段已经是20年的上半年了，这时我毕业出路也算大致定了下来，虽然多少被剧透了一点*，但也是有足够时间正式地开始初见游戏攻略了。在网友们的声讨之下，我其实是对是否要进行亲自游玩有些犹豫的：虽然对假设存在的适量卖腐并不反感，而且对ATLUS加强版的套路已经有些了解，但是如果皇家版的游戏过程反而让我对五代留下的记忆变得微妙了，那让我选择简单地云一下新剧情也未尝不可。</p>
<a href="/p/a31f36d806f9/game-of-the-year.jpg" class="gallery-item"><img src="/p/a31f36d806f9/game-of-the-year.jpg" class="" title="明年一定玩得杂一点！明年！"></a>
<p>好在一些官方游戏媒体给出了还比较中肯的评价，最后皇家版的销量也是一个还不错的水平。同时在反复循环了官方放出的pv和战斗配乐后，最后还是决定玩了！也谢谢跳槽后的公司比较人性化的年假方案和工作节奏，从金城殿堂开始到最后的丸喜殿堂这100小时应该都是在2021年下半年完成的！</p>
<p>一点：指新学期只有一个殿堂，殿堂的BOSS是丸喜，还有加强版结局达成的几种方式。</p>
<h2 id="h玩下来的感想">140h玩下来的感想</h2>
<p>结果真的一周目通关时，存档显示的游戏时长是140小时。</p>
<p>怎么会是90小时呢？我怎么就信了一些测评说的90小时能够基本流程通关呢？还说跳过动画应该能更快通关，到底是以什么形式通关的呢？</p>
<a href="/p/a31f36d806f9/mona-shock.jpg" class="gallery-item"><img src="/p/a31f36d806f9/mona-shock.jpg" class="" title="你怎么会一周目就玩了140h呢"></a>
<p>虽然有一些怨言，其实玩到一半时我多少也感觉到对游戏的Persona培养系统明显比初见P5时要更为上心了，会去尽可能将特性、属性和技能进行配合，让每个P（人格面具
/
Persona）的定位更明确，同时也会想要去合成获取每个属性的最高级P，去达成人格面具的100%完成率；而且我在一周目就对没将所有可COOP角色满COOP，以及错过了一些路边NPC对话耿耿于怀，这一周目也尽可能参考着攻略回避了这些惨剧。</p>
<p>真的玩下来，还是觉得应验了自己一直以来的原则，就是对有足够重要意义的事情，还是得要亲自体验才行，在这些事情上我永远不会混淆他人的评价与自己的看法。现在还能想起来的，皇家版游玩过程中的感触应该就是下面这些吧：</p>
<h3 id="我认为的加分项">+ 我认为的加分项</h3>
<a href="/p/a31f36d806f9/pic-in-chatroom.jpg" class="gallery-item"><img src="/p/a31f36d806f9/pic-in-chatroom.jpg" class="" title="包括这个聊天栏里面的配图我也挺中意的"></a>
<ol type="1">
<li><p>新增加的系统从个人角度上确实找不到缺点，都是正向改良：包括伙伴战斗时的SHOW-TIME，新增的TECHNICAL机制，天鹅绒房间的合体警报，还有易用性功能如对低等级阴影的秒杀跳过战斗，这些无疑都是让我能重新打下完整一周目的助力。</p></li>
<li><p>感觉得出来皇家版在很多地方提高了玩家培养角色的效率，也给了玩家更多的行动机会，虽然体感上会觉得日常部分玩起来更忙了，但是确实能减少很多未能达到五维要求、达成满COOP的挫败感。</p></li>
<li><p>虽然新增的大场景只有吉祥寺一个，但功能性设施很多，常驻的剧情npc也还比较丰富，这一点上可以看出制作组的用心，这里姑且是可以表扬的。</p></li>
<li><p>皇家版后新增的两个怪盗团改心任务都有比较复杂的接取机制和攻略机制，同伴对于这些任务也有一些很能体现个性的个人看法，同时在游戏场景中也能发现跟这些任务有关的NPC在改心前后发生对应改变，能体会到和先前的一些流程化改心任务的不同（当然也有可能是我扎堆下印象空间导致了改心任务没什么实感...是的话我道歉）</p>
<a href="/p/a31f36d806f9/shot.JPEG" class="gallery-item"><img src="/p/a31f36d806f9/shot.JPEG" class="" title="射爆！"></a></li>
<li><p>丸喜的剧情我个人觉得虽然没有太多惊喜，圆还是圆得上来，还是算合格的，最后结局的几段演出也能感受出来用了心，虽然对殴桥段个人觉得土了点....但是一些丸喜的现实还是映射出了一个大家幸福的假象世界，提出了一个还算有趣的想法，尤其是对明智角色刻画也起到了很重要作用（当时是让我觉得，哇明智那你很勇啊）</p>
<a href="/p/a31f36d806f9/sekai-tree.JPEG" class="gallery-item"><img src="/p/a31f36d806f9/sekai-tree.JPEG" class="" title="丸喜殿堂这棵树我看了好一会儿"></a></li>
<li><p>虽然我没有吃学妹这种一直要别人看她的人设但是一些服装武器设计和小动作还是挺戳的。</p></li>
<li><p>MY PALACE这个有点收集系统 /
成就系统味道的玩法也还挺对我胃口的。</p></li>
</ol>
<h3 id="我认为的扣分项">- 我认为的扣分项</h3>
<ol type="1">
<li><p><strong>增强版这个做法很烂。ATLUS还是得你出来背锅。</strong>我个人还是宁愿你全部做完再晚几年出，正好21年也没什么大作跟你抢年度最佳搞不好就GOTY了呢？我在这一周目里多次感觉郁闷都和“增强版很烂”有关:</p>
<ol type="1">
<li><p>前面的剧情要重复打一遍比较劝退，是因为你这是增强版游戏</p></li>
<li><p>学妹虽然人设还可以但是前期怎么安排都像路人，伙伴们对学妹的存在认识在早先阶段低到不可思议也是因为你这是增强版游戏，周可和学妹的互动完全像网友写的同人文，与主线同步发生在无人知晓的时空</p>
<a href="/p/a31f36d806f9/on-the-phone.JPEG" class="gallery-item"><img src="/p/a31f36d806f9/on-the-phone.JPEG" class="" title="我还挺喜欢学妹这个造型的"></a></li>
<li><p>剧情变成怪盗团最后任务推倒会长老姐 -&gt; 怪盗团最后任务干掉狮童
-&gt; 怪盗团最后任务干翻圣杯 -&gt; 怪盗团最后人物干爆邪神 -&gt;
怪盗团最后任务夺回现实，这一波接一波的最终回到最后剧情本应给我的触动至少少了一半，这也是因为你这是增强版游戏又加了个尾巴。特别是作为剧情最后的尾巴，虽然不够深刻也好，打倒一致认可的邪恶要比和亦正亦邪的存在战斗要让人爽快一些</p></li>
</ol></li>
<li><p>角色COOP讲完话回家再打一通电话这个设定感觉挺奇怪的，有些时候电话内容还和当日发生的COOP内容微妙地对不太上，挺容易给人出戏的感觉。</p></li>
<li><p>我还是不太喜欢印象空间这种有点roguelike要素的刷级地图，可能是在这种随机生成内容中，创作者的设计感体现地还是不够多造成的吧，这点可以当作是我个人的问题了。</p></li>
</ol>
<h3 id="所以这周目选择了哪位呢...">所以这周目选择了哪位呢...</h3>
<p>我一周目选择的是阿真（新岛真）。当时可能多少也受了一些其他人游戏实况或者同人作品的影响，但是实际体验下来还是每太能感受到阿真的魅力，反而是阿春（奥村春）那种身为大小姐其实偶尔也会使坏，背地里有一些小算盘其实还有点戳。</p>
<a href="/p/a31f36d806f9/no-turning-back.jpg" class="gallery-item"><img src="/p/a31f36d806f9/no-turning-back.jpg" class="" title="已经无法回头了"></a>
<p>无奈阿春的出场还是完，虽然皇家版加长了游戏流程，角色的刻画还是有点抱歉，对于怪盗团中唯一一个因为改心事件丧失亲人的成员还是没有太多篇幅来展开，而且一些官方配图里的阿春真的有点一言难尽！</p>
<p>最后还是选择了双叶啦。虽然是与三次元无缘的性格，还是能让千疮百孔的社畜得到治愈呢。而且悠木碧配的双叶确实挺到位的，现在平日追番看到悠木碧配的角色都会额外留意一下。</p>
<a href="https://cdn.jsdelivr.net/gh/kalulas/image-hosting/images/persona5-royal-futaba-best-girl.jpg" class="gallery-item"><img src="https://cdn.jsdelivr.net/gh/kalulas/image-hosting/images/persona5-royal-futaba-best-girl.jpg" class="" title="双叶天下第一"></a>
<h2 id="遗憾和一些展望">遗憾和一些展望</h2>
<p>要说这一次游玩的遗憾那也还是有的，就是目前的可支配时间应该也没有充足到可以让我二周目以至于全Award（MY
PALACE中的游戏内置成就系统），以及虽然很认真地在收集游戏中的彩蛋，一些印象空见任务的游戏场景相关内容和各大场景中的常驻npc小故事我应该还是没有全覆盖。不过感觉第五代的故事也已经让我翻来覆去地差不多了，我也最好在这里实实在在地和游戏中的大家告别要好，为此还特意买了采集卡录了游戏尾声周可回老家的一段视频，<a
href="https://www.bilibili.com/video/BV1NP4y1J7JY?spm_id_from=333.999.0.0">传送门-&gt;</a>。</p>
<a href="https://s2.loli.net/2023/01/22/od73WjMJ9Ga1e5z.jpg" class="gallery-item"><img src="https://s2.loli.net/2023/01/22/od73WjMJ9Ga1e5z.jpg" class="" title="呜呜虽然我没能上车谢谢大家来送我"></a>
<p>发这篇文章的时候ATLUS也正像挤牙膏一样地公布着25周年相关的情报，如果能有P3的重置也好，毕竟是我完全没有接触过的故事，但果然还是会想要P6啊...对ATLUS的几点期待其实也都写在上面了，无非就是（1）不要搞不同语言的分时段发售，请全语言同步发售（2）不要搞加强版，我可以多等几年。不过这可是那个ATLUS啊，等了那么多次情报和相关发布会，我也大概明白ATLUS的行事风格了，如果还是沿袭“优良传统”，那我应该也能看开吧。</p>
<a href="/p/a31f36d806f9/taxi.jpg" class="gallery-item"><img src="/p/a31f36d806f9/taxi.jpg" class="" title="丸喜这一身还挺帅..."></a>
<p>上一次自发地写这么长的技术无关文章可能还是大二！或者是高中校刊时期了！在厦门老家用不太适合工作的平价青轴键盘，很痛苦呢。以上是一篇完全出自我私心，纪念用的文章，写的时候没有考虑那么多，导致一些遣词造句可能会让读者感到困惑，如果带来了阅读上的困难还请多多谅解。</p>
<a href="/p/a31f36d806f9/fin.jpg" class="gallery-item"><img src="/p/a31f36d806f9/fin.jpg" class="" title="结束啦"></a>
<p>感谢阅读到这里的你，我们下篇文章再见！</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script src="/js/lg-thumbnail.min.js"></script><script src="/js/lg-zoom.min.js"></script><script src="/js/lg-fullscreen.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>]]></content>
      <categories>
        <category>电玩咖</category>
        <category>女神异闻录</category>
      </categories>
      <tags>
        <tag>通关纪念</tag>
        <tag>游戏测评</tag>
        <tag>女神异闻录</tag>
      </tags>
  </entry>
  <entry>
    <title>关于配置代码生成器的构想</title>
    <url>/p/ab7a58fcc8d2/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h3 id="需求">需求</h3>
<p>目前项目组的开发工作流中，读取表格配置需要重复较多机械性的工作：首先是字段的名称和类型规定上有一定的心智负担，在多种使用渠道（如client，server）下可能要认为进行多次同步，其次是完成读表代码也比较模式化，理论上这些工作都可以由工具提供辅助并最终由工具生成代码。</p>
<h3 id="功能概览">功能概览</h3>
<ol type="1">
<li>将表格的所有字段在工具中显示，由用户来自定义表格属性：字段的类型，用途和默认值</li>
<li>工具能够将表格属性以json形式序列化，以json文件形式进行持久化存储</li>
<li>工具能够依据表格属性以及用户自定义的代码模板来生成读表代码</li>
</ol>
<h3 id="定义">定义</h3>
<p>表名：即配置文件的文件名</p>
<p>字段：即配置表中有实际用途的一列</p>
<p>读表代码：并不提供从资源文件中读取配置数据的功能，仅提供从配置数据解析出对应类型字段的功能</p>
<span id="more"></span>
<h3 id="工具需求文档">工具需求文档</h3>
<p>csv只是配置的一种形式，希望能兼容所有表格类型的配置</p>
<ol type="1">
<li>ConfigCodeGenLib：以dll的形式提供基础功能，包括
<ol type="1">
<li>指定表格的字段可以有有哪些用途（usage）和类型（type），包括值类型与容器类型</li>
<li>指定生成代码模板目录和生成代码目录，生成读表代码时从这些目录读取</li>
<li>传入配置文件（csv等）路径，生成表名到字段的属性列表的映射</li>
<li>在不提供json文件时，仅所有字段的属性都设置为初始值</li>
<li>在提供json文件时，从json文件中读出字段的客制化属性</li>
<li>提供表名可以获取字段属性列表，对字段属性进行读写（编辑器支持）</li>
<li>可以将表格的配置属性以json形式持久化</li>
</ol></li>
<li>ConfigEditor：依赖ConfigCodeGenLib的图形化工具，提供功能包括
<ol type="1">
<li>提供配置目录（json索引），生成所有表格配置的选取列表</li>
<li>选取表格后，显示字段的编辑界面</li>
<li>保存字段属性的编辑结果，生成json配置文件</li>
<li>生成特定用途（usage）下的生成代码（由 Visual Studio
提供的<strong>TextTransform</strong>以及T4 Text Template支持）</li>
</ol></li>
</ol>
<h3 id="开发记录">开发记录</h3>
<p>github传送门：https://github.com/kalulas/ConfigCodeGen</p>
<p>libenv.json用于初始化library，appsettings.json用于初始化应用</p>
<h4 id="configcodegenlib">ConfigCodeGenLib</h4>
<p>.Net Standard 2.0 Library</p>
<ol type="1">
<li>Configuration：静态类，用于根据json文件配置工具环境</li>
<li>ConfigManager：单例模式，用于根据配置文件和json文件生成运行时数据</li>
</ol>
<h4 id="configcodegenconsole">ConfigCodeGenConsole</h4>
<p>.Net 6.0 调试Library用的Console</p>
<h4 id="configeditor">ConfigEditor</h4>
<p>.Net 6.0 基于<a
href="https://docs.avaloniaui.net/">Avalonia</a>的图形化编辑器</p>
<h4 id="配置形式说明">配置形式说明</h4>
<p>config.json</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;
    &quot;DataValueType&quot;: [&quot;int&quot;, &quot;float&quot;, &quot;boolean&quot;, &quot;string&quot;], &#x2F;&#x2F; 支持的值类型
    &quot;DataCollectionType&quot;: [&quot;none&quot;, &quot;array&quot;, &quot;list&quot;], &#x2F;&#x2F; 支持的容器类型
    &quot;ConfigJsonPath&quot;: &quot;ConfigJson\\&quot;, &#x2F;&#x2F; 相对路径，在该目录下存放描述配置的json
    &quot;CodeTemplatePath&quot;: &quot;CodeTemplate\\&quot;, &#x2F;&#x2F; 相对路径，在该目录下代码生成模板
    &quot;ConfigUsageType&quot;:&#123; &#x2F;&#x2F; 用户的自定义生成类型
        &quot;client&quot;:&#123; 
            &quot;CodeTemplateName&quot;: &quot;csharp.txt&quot;, &#x2F;&#x2F; 代码模板名
            &quot;TargetPath&quot;: &quot;Generated-C#\\&quot;, &#x2F;&#x2F; 生成代码目录
            &quot;TargetFileType&quot;: &quot;.cs&quot; &#x2F;&#x2F; 生成后缀名
        &#125;,
        &quot;server&quot;:&#123;
            &quot;CodeTemplateName&quot;: &quot;go.txt&quot;,
            &quot;TargetPath&quot;: &quot;Generated-go\\&quot;,
            &quot;TargetFileType&quot;: &quot;.go&quot;
        &#125;
    &#125;
&#125;</code></pre>
<p>table.json（配置文件对应json）</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;
    &quot;ConfigName&quot; : &quot;AutoPickupConfig&quot;,
    &quot;Usage&quot;      : [
    ],
    &quot;Attributes&quot; : [
        &#123;
            &quot;AttributeName&quot; : &quot;Id&quot;,
            &quot;ValueType&quot;     : &quot;&quot;,
            &quot;CollectionType&quot; : &quot;&quot;,
            &quot;Usage&quot;          : [
            ]
        &#125;,
        &#123;
            &quot;AttributeName&quot; : &quot;Desc&quot;,
            &quot;ValueType&quot;     : &quot;&quot;,
            &quot;CollectionType&quot; : &quot;&quot;,
            &quot;Usage&quot;          : [
            ]
        &#125;,
        &#x2F;&#x2F; ...
    ]
&#125;</code></pre>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script src="/js/lg-thumbnail.min.js"></script><script src="/js/lg-zoom.min.js"></script><script src="/js/lg-fullscreen.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>]]></content>
      <categories>
        <category>开发设计稿</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>游戏开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Protocol Buffers 编码</title>
    <url>/p/783e3028351b/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="protocol-buffers-编码">Protocol Buffers 编码</h1>
<p>reference:</p>
<ul>
<li><a
href="https://www.zhihu.com/question/585411183">https://www.zhihu.com/question/585411183</a></li>
<li><a
href="https://protobuf.dev/programming-guides/encoding/">https://protobuf.dev/programming-guides/encoding/</a></li>
</ul>
<p>本文翻译自<a
href="https://protobuf.dev/programming-guides/encoding/">官方文档</a>，补充了部分前置知识与帮助理解的示例。</p>
<h2 id="简介">简介</h2>
<p>Protocol Buffers (a.k.a., <em>protobuf</em>) are Google's
language-neutral, platform-neutral, extensible mechanism for serializing
structured data.</p>
<p>Protocol Buffers
是Google由推出的，跨语言、跨平台的用于序列化数据结构的可拓展机制 /
协议。</p>
<h2 id="序列化格式">序列化格式</h2>
<p>Protobuf的编码基于变种的Base128，下面先简单介绍Base64，Base128以及ZigZag编码。</p>
<h3 id="base64编码">Base64编码</h3>
<p>reference: <a
href="https://www.zhihu.com/question/585411183">https://www.zhihu.com/question/585411183</a></p>
<p>Base64编码的设计初衷是为了让数据在设备间传输时，目标机器能够正确地“理解”字节流中的内容：字节流中的内容均可以通过ascii字符正常显示。</p>
<span id="more"></span>
<p>举例：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 输入下述字节流
0b10100010 0b00001001 0b11000010 0b11010011
&#x2F;&#x2F; 以6bits为单位进行分组，并在最后补0
0b101000 0b100000 0b100111 0b000010 0b110100 0b110000
&#x2F;&#x2F; 接着每一组6bits都在高位补0
0b00101000 0b00100000 0b00100111 0b00000010 0b00110100 0b00110000</code></pre>
<p>附图Base64编码对照表</p>
<figure>
<a href="https://s2.loli.net/2024/03/06/oFcVihdBrNn9JDL.png" title="TheBase64Alphabet" class="gallery-item"><img src="https://s2.loli.net/2024/03/06/oFcVihdBrNn9JDL.png"
alt="TheBase64Alphabet" /></a>
<figcaption aria-hidden="true">TheBase64Alphabet</figcaption>
</figure>
<p>最后在按照6bits一组划分后，再以<code>(pad)=</code>
根据4字节对齐，得到最终编码结果。编码结束后，任意字符流就都能用数字、字母以及
+ / = 符号表示了，这些都是可以被正常显示的 ascii
字符，ascii字符在绝大多数计算机和操作系统都被良好支持了，可被正确地复制、传播、解析。</p>
<p>*到这里就能意识到，Base64编码并不是自己以前想的什么“Based on
64”，而实编码后的结果仅有64个可视的ascii字符。</p>
<h3 id="base128编码">Base128编码</h3>
<p>Base64编码存在的一个问题就在于对每6比特进行补零，这样在最理想的情况下（即无末尾补零，也无末尾4字节padding）也只有75%的空间利用率。</p>
<p>按照Base64的思路，可以将字节流按照7bits进行分组，然后同样对低位补0，补足一组8bits，再进行末尾4字节padding。</p>
<p>但是问题在于，使用Base128会导致实际需要的字符有128+1个，而ascii字符集只有128个可用字符。同时，ascii字符中还包含了一些不可正常打印的控制字符，所以Base128未能完全替换Base64，而是以一些变种存在。</p>
<h3 id="zigzag编码">ZigZag编码</h3>
<p>ZigZag编码法将正数与负数穿插排列，一个用例是在Base128Varint中的使用，用于避免负数带有过多的高位1。</p>
<ul>
<li>所有的正数 <code>p</code> 将被编码为
<code>2 * p</code>（全体偶数）</li>
<li>所有的负数 <code>n</code> 将被编码为 <code>2 * |n| - 1</code></li>
</ul>
<p>给出一个 ZigZag 法下的例子：</p>
<table>
<thead>
<tr class="header">
<th>Signed Original</th>
<th>Encoded As</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>-1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>1</td>
<td>2</td>
</tr>
<tr class="even">
<td>-2</td>
<td>3</td>
</tr>
<tr class="odd">
<td>…</td>
<td>…</td>
</tr>
<tr class="even">
<td>0x7fffffff</td>
<td>0xfffffffe</td>
</tr>
<tr class="odd">
<td>-0x80000000</td>
<td>0xffffffff</td>
</tr>
</tbody>
</table>
<p>给出 ZigZag
法的位计算公式，对32位带符号数<code>n</code>有（注意这里的n使用是负数的二进制补码表示）：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">(n &lt;&lt; 1) ^ (n &gt;&gt; 31)</code></pre>
<p>对64位带符号数有：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">(n &lt;&lt; 1) ^ (n &gt;&gt; 63)</code></pre>
<h3 id="base128-varints">Base128 Varints</h3>
<p>*确实是Varint，表示边长int，不是Variant</p>
<p>Varints are a method of serializing integers using one or more bytes.
Smaller numbers take a smaller number of bytes.</p>
<p><strong>特性</strong></p>
<ol type="1">
<li>只能对部分类型的数据进行编码，不适用于所有字节流</li>
<li>编码后的字节可以不存在于ascii表中，因为应用场景不同，不需要考虑是否能够正常打印</li>
</ol>
<p><strong>编码方式</strong></p>
<p>对Base128 varint处理后的每个字节，低7位用于储存数据，最高位（most
significant
bit，简称msb）用于表示此字节后续是否还有内容，当msb为1时表示后续还有数据，为0时表示当前字节已是最后一字节。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 以int类型数值300为例
0b100101100 0x012C
-&gt; 0b[1]0101100 0b[0]0000010</code></pre>
<p>protobuf的varints最多可以编码8字节数据，因为现代计算机最高也是支持处理64位整型。</p>
<h2 id="支持的数据类型-wire-type">支持的数据类型 wire type</h2>
<p>protocol buffer
的消息是一系列的键值对，而序列化的binary信息使用<strong>字段序号（field
number）</strong>作为key，每个字段的名字和声明类型（指在特定语言中的类型，而不是wire
type，wire
type是可以在binary信息中找到的）只有在解码端可以通过消息体的类型定义（.proto，或.proto生成文件）获得。</p>
<p>当信息被编码时，每一个键值对都被转换为一条
<strong><em>记录(record)</em></strong>，包含下述内容：</p>
<ol type="1">
<li>wire_type</li>
<li>字段序号（field number）</li>
<li>有效负载（payload）</li>
</ol>
<p>每个wiretype都告诉解析器（parser）后续的负载有多大，或者说后续的负载该如何解析。</p>
<p>支持的六种wire_type如以下所示：</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 9%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="header">
<th>ID</th>
<th>Name</th>
<th>Used For</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>VARINT</td>
<td>int32, int64, uint32, uint64, sint32, sint64, bool, enum</td>
</tr>
<tr class="even">
<td>1</td>
<td>I64</td>
<td>fixed64, sfixed64, double</td>
</tr>
<tr class="odd">
<td>2</td>
<td>LEN</td>
<td>string, bytes, embedded messages, packed repeated fields</td>
</tr>
<tr class="even">
<td>3</td>
<td>SGROUP</td>
<td>group start (deprecated)</td>
</tr>
<tr class="odd">
<td>4</td>
<td>EGROUP</td>
<td>group end (deprecated)</td>
</tr>
<tr class="even">
<td>5</td>
<td>I32</td>
<td>fixed32, sfixed32, float</td>
</tr>
</tbody>
</table>
<p>每条记录中的标签（tag）都使用字段序号，以及wire_type通过以下公式计算得到，这个标签本身也使用VARINT格式。也就是说每个字段的起始varint，低三位表示wire_type，而剩余内容表示字段序号。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">(field_number &lt;&lt; 3) | wire_type</code></pre>
<p>可以得到tag内容为 <code>field_number * 8 + wire_type</code>
的二进制表示</p>
<p>举例有下述输入
<code>0x0008 0x9601</code>，以小端考虑，读取前三位就能得到wire_type为0，再读取高位内容便能得到字段序号为1。接下来以wire_type
0类型VARINT解析后续内容<code>0x9601</code>，边能得到payload内容为数值150。</p>
<p>最大支持的 field_number 时？值得研究一下。</p>
<h3 id="更多整型类型">更多整型类型</h3>
<p><strong>Enum &amp; Bool</strong></p>
<p>枚举和布尔类型都被作为int32处理，他们也使用VARINT wire_type
进行编码</p>
<p><strong>Signed Integers</strong></p>
<p>varints
被视作无符号的整型，所以在处理带符号整型有不同的行为：如果带符号数使用二进制补码表示负数，负数的最高位将总是1。如果直接按照上述的方式转换为varint，负数将占用整整10个字节，这也是varint的最大长度。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 举例数值sint64 -5的二进制补码表示负数
&#x2F;&#x2F; 原码（little-endian high -&gt; low）
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000101
&#x2F;&#x2F; -5 的二进制补码
11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111011
&#x2F;&#x2F; 按7bits分组
1 1111111 1111111 1111111 1111111 1111111 1111111 1111111 1111111 1111011
&#x2F;&#x2F; 分组8bits补全，10 bytes in total
[0]0000001 [1]1111111 [1]1111111 [1]1111111 [1]1111111 [1]1111111 [1]1111111 [1]1111111 [1]1111111 [1]1111011</code></pre>
<p>（复习一下，使用二进制补码取负数的方式为：相应正数取二进制反码 + 1 /
或者 ~0 - (positive) + 1）</p>
<p><code>sintN</code> 使用 “ZigZag”
法取代二进制补码进行负数的编码，这种编码法将正数与负数穿插排列，如此一来，负数的编码结果就不会因为高位的1占用过多字节了。</p>
<p>当 <code>sint32</code> 和 <code>sint64</code>
解析后，值会被重新解码会原先的带符号（二进制补码）形式。需要注意的是，在
<strong>protoscope</strong> 中，使用 <strong>z</strong>
后缀即表示该值使用ZigZag法编码，例 <code>-500z == 999</code> 。</p>
<p><strong>非变长数字</strong></p>
<p>非变长的数值类型很简单，<code>double</code> 与 <code>fixed64</code>
都使用 wire_type <code>I64</code>，对应的 <code>float</code> 与
<code>fixed32</code> 都使用 wire_type
<code>I32</code>，前者解析器将读取8字节数据，对应的后者读取4字节数据。</p>
<p>使用<code>i64</code>后缀，或者<code>i32</code>后缀来将数值标记为对应的wire_type。</p>
<h3 id="scalar-value-types">Scalar Value Types</h3>
<p>see <a
href="https://protobuf.dev/programming-guides/proto2/#scalar">https://protobuf.dev/programming-guides/proto2/#scalar</a></p>
<h2 id="长度分割记录-record">长度分割记录 Record</h2>
<p>wire_type(2) 为类型 LEN，在tag后存了一个 varint
表示的整数表示后续有多少字节内容。距离字符串”testing”，编码为以下结果。</p>
<pre class="line-numbers language-none"><code class="language-none">12 07 [74 65 73 74 69 6e 67]</code></pre>
<p>tag 中的 <code>12</code>
转换为二进制表示为<code>00010 010</code>，有wire_type
2，再往后读一字节即可得到后续字串的长度为7字节。</p>
<p>同样的， bytes 类型字段也使用这种形式进行编码。</p>
<h3 id="嵌套消息体">嵌套消息体</h3>
<p>子消息体同样使用 <code>LEN</code> wire
type。子消息体的编码结果会如同上述字串的内容存储在varint长度标志后。这同样要求了通信双端对于消息体的结构要有认知，否则就只知道字节数，而不知道如何应当解析（反序列化）为什么对象。</p>
<h2 id="可选与重复元素-optional-and-repeated">可选与重复元素 Optional
and Repeated</h2>
<p>对于Optional字段，如果字段未被设置，那么字段将在编码时被跳过。</p>
<p>对于Repeated字段，编码时将会为这个集合中的每一个元素编码一个相同的tag。同时留意，同一个repeated字段的元素在编码结果中不一定连续，他们只需要保证相对位置不出错。</p>
<p>如对以下结构体</p>
<pre class="line-numbers language-none"><code class="language-none">message Test4 &#123;
  optional string d &#x3D; 4; &#x2F;&#x2F; 设置为 &quot;hello&quot;
  repeated int32 e &#x3D; 5; &#x2F;&#x2F; 设置为 &#123;1, 2, 3&#125;
&#125;</code></pre>
<p>则编码结果可能为</p>
<pre class="line-numbers language-none"><code class="language-none">4: &#123;&quot;hello&quot;&#125;
5: 1
5: 2
5: 3</code></pre>
<p>也可能为</p>
<pre class="line-numbers language-none"><code class="language-none">5: 1
5: 2
4: &#123;&quot;hello&quot;&#125;
5: 3</code></pre>
<h3 id="oneofs">Oneofs</h3>
<p>标识为Oneofs的字段间共享存储空间，设置其中的任一字段将清空其他字段内容，但除此之外并不影响编码逻辑，与上述内容一致</p>
<h3 id="last-one-wins">Last One Wins</h3>
<p>一般来说，编码的信息中不应该出现非 repeated
字段的重复实例，但Parser通过提供Merge方法处理了这种情况，这也让合并多条信息成为可能。</p>
<p>Parser的Merge行为准则是接收最后一次的值结果，具体行为：</p>
<ol type="1">
<li>值类型字段，后来的覆盖前面的</li>
<li>repeated 字段，内容将被连接</li>
<li>嵌套消息体，递归执行Merge操作</li>
</ol>
<p>此规则的直接结果是两条消息的字节流连接后进行解码，与各自解码后再对结果实例进行Merge操作，将得到一样的结果，即</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">MyMessage message;
message.ParseFromString(str1 + str2);</code></pre>
<p>等同于</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">MyMessage message, message2;
message.ParseFromString(str1);
message2.ParseFromString(str2);
message.MergeFrom(message2);</code></pre>
<h3 id="packed-repeated-fileds">Packed Repeated Fileds</h3>
<p>除 string bytes 外的任何 scalar type（可简单理解为值类型） 可被声明为
packed。proto2 中 packed 需要显式使用 <code>[packed=true]</code>
声明，proto3中为默认值。</p>
<p>packed 的 repeated 字段不再每个元素独立一条记录，而是编码到同一条
<code>LEN</code>
记录中。解码时会将长度标识符后续的字节流一个一个按照声明的类型进行解码，下一元素的起始位置取决于前一元素的长度。</p>
<p>举例下述结构体，其中字段 f 填充值为 3，270，86942</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">message Test5 &#123;
  repeated int32 f &#x3D; 6 [packed&#x3D;true];
&#125;</code></pre>
<p>可以得到有以下编码结果</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">3206038e029ea705 &#x2F;&#x2F; hex
3206 03(3) 8e02(270) 9ea705(86942)
00110(field_number&#x3D;6) 010(LEN) 0000 0110(length&#x3D;6bytes) 0000 0011 ...</code></pre>
<p>注意尽管在编码的结果中，声明为packed的同一字段不应重复出现，但parser依然视其为合法输入，且需要处理此情况。处理方式为将重复出现的
key-value pair 中value内的元素相连组合。</p>
<p>同时，parser需要支持在消息体字段被声明为packed下，也能解析接收到的非packed字节内容。反之要求仍然成立。通过如此要求parser，使用者在不破坏前向、后向兼容性的情况下，向现有的字段新增或去除
packed 标记。</p>
<h3 id="maps">Maps</h3>
<p>maps常被用于字典/映射，Maps实际是特殊的repeated 字段，考虑将
key=value pair 作为嵌套结构体Entry，然后使用 reapted 属性声明，编码为
<code>LEN</code> 类型的连续记录即可。</p>
<p>举例结构体</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">message Test6 &#123;
  map&lt;string, int32&gt; g &#x3D; 7;
&#125;</code></pre>
<p>将被编码为</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">message Test6 &#123;
  message g_Entry &#123;
    optional string key &#x3D; 1;
    optional int32 value &#x3D; 2;
  &#125;
  repeated g_Entry g &#x3D; 7;
&#125;</code></pre>
<p>考虑非 packed 的编码结果为：</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[7|LEN][single_entry_length]&#123;[1|LEN][length][key][2|VARINT][value]&#125;
[7|LEN][single_entry_length]&#123;[1|LEN][length][key][2|VARINT][value]&#125;...</code></pre>
<p>map 同样可以声明（或默认为）packed。</p>
<h2 id="字段顺序-field-order">字段顺序 Field Order</h2>
<p><code>.proto</code>
文件并没有对字段序号的顺序进行要求，且顺序并不影响消息体的序列化行为。</p>
<p>消息体被序列化时，序列化器并不能以确定的顺序对已知的、或未知的字段进行写入（序列化），这取决于具体实现。因此，protol
buffer 的序列化器必须在任何的读入顺序下都能够解析字段。</p>
<h3 id="影响-implications">影响 Implications</h3>
<ul>
<li>不要假定序列化信息的字节输出是稳定的。对于那些拥有一个 bytes
字段用于携带另一个消息体的大消息体特别要注意这点。</li>
<li>对同一个消息体实例的多次序列化操作，并不保证能够有相同的字节输出，即序列化操作并不拥有确定性。
<ul>
<li>确定性只有在同一个版本的protocol buffer
可执行程序下可以办证，不同版本间可能有不同（原文为“Deterministic
serialization only guarantees the same byte output for a particular
binary”）。</li>
</ul></li>
<li>因此有 protocol buffer 的消息体实例 foo，其复数次
<code>SerializeAsString()</code> 输出，以及相应的 <code>Hash/CRC</code>
结果等均不能保证相等</li>
<li>在下述情景中，逻辑相等的 protocol buffer 消息体实例 <code>foo</code>
与 <code>bar</code> 可能有不同的序列化输出：
<ul>
<li>对 <code>bar</code> 进行序列化的服务器使用了另一种语言的
proto实现</li>
<li>对 <code>bar</code> 进行序列化的服务器更新了 proto 实现</li>
<li>对 <code>bar</code> 进行序列化时，一些新增字段被处理为 unknown</li>
<li><code>bar</code> 中存在非确定性字段</li>
<li><code>bar</code> 中存在 bytes
类型字段，其内容为另一个消息体的序列化结果</li>
<li><code>foo</code> 与 <code>bar</code>
是多个相同消息体实例以不同顺序相连接的结果</li>
</ul></li>
</ul>
<h2 id="编码大小限制">编码大小限制</h2>
<p>序列化结果必须小于 2GiB，许多 proto
实现会拒绝序列化，或者解析超过这个限制的消息体。</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script src="/js/lg-thumbnail.min.js"></script><script src="/js/lg-zoom.min.js"></script><script src="/js/lg-fullscreen.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>]]></content>
      <categories>
        <category>计算机科学</category>
        <category>信息论</category>
      </categories>
      <tags>
        <tag>编码方案</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学中的四元数</title>
    <url>/p/d376051877fb/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="四元数与欧拉角">四元数与欧拉角</h1>
<p>以下内容主要是参考了<a
href="https://github.com/Krasjet/quaternion">Krasjet</a>关于四元数的介绍《四元数与三维旋转》：<a href="/p/d376051877fb/quaternion.pdf" title="“点这里阅读《四元数与三维旋转》”">“点这里阅读《四元数与三维旋转》”</a></p>
<p>会记录一些阅读过程中遇到的结论性内容，系统学习主要还是参考原文档为主</p>
<h2 id="复数">复数</h2>
<h3 id="复数相乘与2d旋转">1.3 复数相乘与2D旋转</h3>
<p>与复数 <span class="math inline">\(z=a+bi\)</span> 相乘代表着<span
class="math inline">\(\begin{bmatrix}a &amp; -b \\b &amp; a
\end{bmatrix}\)</span>
矩阵所作出的变换，将矩阵中的每一个元素都除以模长，可以得到以下变换：</p>
<p><span class="math display">\[
\begin{bmatrix}a &amp; -b \\b &amp; a \end{bmatrix} =
\sqrt{a^2+b^2}*\begin{bmatrix}\frac{a}{\sqrt{a^2+b^2}}&amp;\frac{-b}{\sqrt{a^2+b^2}}\\\frac{b}{\sqrt{a^2+b^2}}&amp;\frac{a}{\sqrt{a^2+b^2}}\end{bmatrix}
\]</span></p>
<a href="/p/d376051877fb/complex-plane.png" class="gallery-item"><img src="/p/d376051877fb/complex-plane.png" class="" title="复平面上的复数z"></a>
<p>从复平面观察可以得到，<span
class="math inline">\(\|z\|=\sqrt{a^2+b^2}\)</span> 且有 <span
class="math inline">\(\theta=\arctan(\frac{b}{a})\)</span>
，原本的矩阵转换为了两个变换矩阵的复合，其中左边的<span
class="math inline">\(\begin{bmatrix}\|z\|&amp;0\\0&amp;\|z\|\end{bmatrix}\)</span>是缩放矩阵，而右边的<span
class="math inline">\(\begin{bmatrix}\cos(
\theta)&amp;-\sin(\theta)\\\sin(\theta)&amp;\cos(\theta)\end{bmatrix}\)</span>则是2D旋转矩阵。</p>
<span id="more"></span>
<h3 id="旋转的复合">1.4 旋转的复合</h3>
<p><span class="math display">\[
\begin{aligned}z_{net}&amp;=(\cos(\theta)+i\sin(\theta))(\cos(\phi)+i\sin(\phi))\\&amp;=\cos(\theta+\phi)+i\sin(\theta+\phi)\end{aligned}
\]</span></p>
<p>对两个2D旋转进行复合时，所得的变换 <span
class="math inline">\(z_{net}\)</span>
仍是一个旋转，而且与施加的次序无关。这个等效变换的旋转角是两个旋转角之和。</p>
<h2 id="三维空间中的旋转">2 三维空间中的旋转</h2>
<p><strong>轴角式(Axis-angle)</strong> 旋转：给定旋转的转轴向量<span
class="math inline">\(\vec{u}=(x,y,z)^T\)</span>以及旋转的角度<span
class="math inline">\(\theta\)</span>，但实际在三维空间中表示方向只需要两个自由度（或者说两个变量），即与两个坐标轴的夹角，转轴向量可以除以模长转换为特定方向上的单位向量。</p>
<h3 id="旋转的分解">2.1 旋转的分解</h3>
<p>首先将要旋转的向量在垂直和平行于转轴的方向上进行分解，有<span
class="math inline">\(\vec{v}=\vec{v_\parallel}+\vec{v_\perp}\)</span>
，分别进行旋转后再相加就能得到旋转后的结果。</p>
<p>根据正交投影公式，可以得出</p>
<p><span class="math display">\[
\begin{aligned}\vec{v_\parallel}&amp;=proj_{\vec{u}}(\vec{v})\\&amp;=\frac{\vec{u}\cdot\vec{v}}{\vec{u}\cdot\vec{u}}\vec{u}\\&amp;=(\vec{u}\cdot\vec{v})\vec{u}\end{aligned}
\]</span></p>
<p>又由于<span
class="math inline">\(\vec{v}=\vec{v_\|}+\vec{v_\perp}\)</span>，可以得到垂直于转轴方向有</p>
<p><span class="math display">\[
\begin{aligned}\vec{v_{\perp}}&amp;=\vec{v}-\vec{v_{\parallel}}\\&amp;=\vec{v}-(\vec{u}\cdot\vec{v})\vec{u}\end{aligned}
\]</span></p>
<h3 id="垂直分量的旋转">2.3 垂直分量的旋转</h3>
<p>在与<span
class="math inline">\(\vec{u}\)</span>垂直平面上的分量旋转角度<span
class="math inline">\(\theta\)</span>，可对结果进行下述表示，先构造一个正交于转轴向量和<span
class="math inline">\(\vec{v_{\perp}}\)</span>的向量<span
class="math inline">\(\vec{w}\)</span>：</p>
<p><span class="math display">\[
\vec{w}=\vec{u}\times\vec{v_\perp}
\]</span></p>
<p>可以得到正交于旋转轴<span
class="math inline">\(\vec{u}\)</span>的分量<span
class="math inline">\(\vec{v_\perp}\)</span>，旋转角度<span
class="math inline">\(\theta\)</span>后得到的<span
class="math inline">\(\vec{v_\perp^\prime}\)</span>：</p>
<p><span class="math display">\[
\begin{aligned}\vec{v_\perp^\prime}&amp;=\cos{\theta}\vec{v_\perp}+\sin{\theta}\vec{w}\\&amp;=\cos{\theta}\vec{v_\perp}+\sin{\theta}(\vec{u}\times\vec{v_\perp})\end{aligned}
\]</span></p>
<h3 id="vecv的旋转">2.4 <span
class="math inline">\(\vec{v}\)</span>的旋转</h3>
<p>根据上述公式可以得到以下推导，得到3D旋转公式，也称<strong><em>Rodrigues’
Rotation Formula</em></strong>：</p>
<p><span class="math display">\[
\begin{equation}\begin{aligned}\vec{v^\prime}&amp;=\vec{v^\prime_\parallel}+\vec{v_\perp^\prime}\\&amp;=\vec{v_\parallel}+\cos{\theta}\vec{v_\perp}+\sin{\theta}(\vec{u}\times\vec{v_\perp})\\&amp;=(\vec{u}\cdot\vec{v})\vec{u}+\cos{\theta}(\vec{v}-(\vec{u}\cdot\vec{v})\vec{u})+\sin{\theta}(\vec{u}\times\vec{v})\\&amp;=\cos{\theta}\vec{v}+(1-\cos{\theta})(\vec{u}\cdot\vec{v})\vec{u}+\sin{\theta}(\vec{u}\times\vec{v})\end{aligned}\end{equation}
\]</span></p>
<p>其中第二步包含以下推导（叉乘遵守分配律）</p>
<p><span class="math display">\[
\begin{equation}\begin{aligned}\vec{u}\times\vec{v_\perp}&amp;=\vec{u}\times(\vec{v}-\vec{v_\parallel})\\&amp;=\vec{u}\times\vec{v}-\vec{u}\times\vec{v_\parallel}（\vec{u}平行于\vec{v_\parallel}，结果为0）\\&amp;=\vec{u}\times\vec{v}\end{aligned}\end{equation}
\]</span></p>
<h2 id="四元数">四元数</h2>
<p>所有四元数<span
class="math inline">\(q\in\mathbb{H}\)</span>都可以表现成下述形式，有时四元数也写作w，x，y，z的形式，w是常数项，x，y，z分别是i，j，k维度上的系数（记住w是常数项就行）</p>
<p><span class="math display">\[
\begin{equation}\begin{aligned}q=a+bi+cj+dk(a,b,c,d\in\mathbb{R})\end{aligned}\end{equation}
\]</span></p>
<p>其中有</p>
<p><span class="math display">\[
\begin{equation}i^2=j^2=k^2=ijk=-1\end{equation}
\]</span></p>
<h3 id="标量乘法-四元数乘法">3.1 标量乘法 &amp; 四元数乘法</h3>
<p>四元数与标量的乘法遵守交换律，但四元数之间的乘法比较特殊不遵守交换律，有左乘与右乘的区别，一般情况下左乘结果不等于右乘结果。举例对<span
class="math inline">\(q_1=a+bi+cj+dk\)</span>与<span
class="math inline">\(q_2=e+fi+gj+hk\)</span>之间的乘法有：</p>
<p><span class="math display">\[
\begin{equation}q_1q_2=\begin{bmatrix}a&amp;-b&amp;-c&amp;-d\\b&amp;a&amp;-d&amp;c\\c&amp;d&amp;a&amp;-b\\d&amp;-c&amp;b&amp;a\end{bmatrix}\begin{bmatrix}e\\f\\g\\h\end{bmatrix}\end{equation}
\]</span></p>
<p>进行<span class="math inline">\(q_1\)</span>右乘<span
class="math inline">\(q_2\)</span>有以下</p>
<p><span class="math display">\[
\begin{equation}q_2q_1=\begin{bmatrix}a&amp;-b&amp;-c&amp;-d\\b&amp;a&amp;d&amp;-c\\c&amp;-d&amp;a&amp;b\\d&amp;c&amp;-b&amp;a\end{bmatrix}\begin{bmatrix}e\\f\\g\\h\end{bmatrix}\end{equation}
\]</span></p>
<h3 id="graßmann积">3.1.6 Graßmann积</h3>
<p>对以上<span class="math inline">\(q_1\)</span>以及<span
class="math inline">\(q_2\)</span>有两者的乘积</p>
<p><span class="math display">\[
\begin{equation}\begin{aligned}q_1q_2=&amp;(ae-(bf+cg+dh))+\\&amp;(be+af+ch-dg)i+\\&amp;(ce+ag+df-bh)j+\\&amp;(de+ah+bg-cf)k\end{aligned}\end{equation}
\]</span></p>
<p>若给出以<span
class="math inline">\(\vec{i}、\vec{j}、\vec{k}\)</span>为基的向量<span
class="math inline">\(\vec{v}=\begin{bmatrix}b\\c\\d\end{bmatrix}\)</span>以及<span
class="math inline">\(\vec{u}=\begin{bmatrix}f\\g\\h\end{bmatrix}\)</span>，有以下</p>
<p><span class="math display">\[
\begin{equation}\begin{aligned}\vec{v}\cdot\vec{u}&amp;=bf+cg+dh\\\vec{v}\times\vec{u}&amp;=\left|\begin{matrix}\vec{i}&amp;\vec{j}&amp;\vec{k}\\b&amp;c&amp;d\\f&amp;g&amp;h\end{matrix}\right|\\&amp;=(ch-dg)\vec{i}-(bh-df)\vec{j}+(bg-cf)\vec{k}\end{aligned}\end{equation}
\]</span></p>
<p>最后可以得到Graßmann积结果，有对任意四元数<span
class="math inline">\(q_1=\begin{bmatrix}s,\vec{v}\end{bmatrix},
q_2=\begin{bmatrix}t,\vec{u}\end{bmatrix}\)</span>可以得到结果：</p>
<p><span class="math display">\[
\begin{equation}q_1q_2=\begin{bmatrix}st-\vec{v}\cdot\vec{u},
s\vec{u}+t\vec{v}+\vec{v}\times\vec{u}\end{bmatrix}\end{equation}
\]</span></p>
<p>需要留意这里的到的结果是一个四元数，前者是标量，后者是一个以<span
class="math inline">\(\vec{i}、\vec{j}、\vec{k}\)</span>为基的三维向量</p>
<h3 id="纯四元数">3.1.7 纯四元数</h3>
<p>纯四元数是仅有虚部的四元数，因为纯四元数仅由虚部的3D向量决定，所以可以将任意的3D向量转换为纯四元数。对3D向量<span
class="math inline">\(\vec{v}\)</span>，有对应的纯四元数：</p>
<p><span class="math display">\[
\begin{equation}v=\begin{bmatrix}0, \vec{v}\end{bmatrix}\end{equation}
\]</span></p>
<p>可以思考一下对于纯四元数来说Graßmann积（14）会得到什么结果</p>
<h3 id="逆与共轭">3.1.8 逆与共轭</h3>
<p>对四元数<span class="math inline">\(q\)</span>，它的逆为<span
class="math inline">\(q^{-1}\)</span>，相乘积为1，这里注意复习下四元数不遵守交换律</p>
<p>同样对四元数<span class="math inline">\(q = a+bi+cj+dk\)</span>
有共轭为 <span class="math inline">\(q^* =
a-bi-cj-dk\)</span>，四元数<span
class="math inline">\(q\)</span>与共轭<span
class="math inline">\(q^*\)</span>相乘得到结果为四元数模长的平方<span
class="math inline">\({\|q\|}^2\)</span>，同时这个特殊的运算是遵守交换律的</p>
<p>最后，根据逆的定义可以推导得到一种寻找四元数的逆的方式，即：</p>
<p><span class="math display">\[
\begin{equation}q^{-1}=\frac{q^*}{\|q\|^2}\end{equation}
\]</span></p>
<h2 id="四元数与3d旋转">3.2 四元数与3D旋转</h2>
<p>接下来的内容就是将先前推导过的3D旋转公式（14），用<strong>四元数的计算</strong>和<strong>纯四元数</strong>的方式进行表达，这里开始搬运的内容会减少，请主要以阅读原pdf为主。</p>
<p>对旋转向量<span
class="math inline">\(\vec{v}\)</span>在垂直方向上的分量旋转<span
class="math inline">\(\theta\)</span>后的结果<span
class="math inline">\(\vec{v_\perp^\prime}\)</span>，替换为<strong>纯四元数</strong>的形式有：</p>
<p><span class="math display">\[
\begin{equation}\begin{aligned}v_\perp^\prime&amp;=\cos{\theta}v_\perp+\sin{\theta}(uv_\perp)\\&amp;=(\cos{\theta}+\sin{\theta}u)v_\perp\\&amp;=qv_\perp\\q&amp;=\begin{bmatrix}\cos{\theta},\sin{\theta}\vec{u}\end{bmatrix}\end{aligned}\end{equation}
\]</span></p>
<p>这里的<span
class="math inline">\(q\)</span>是一个单位四元数，根据（16）可以得到<span
class="math inline">\(q^{-1}=q^\star\)</span></p>
<p>对平行于旋转轴的<span
class="math inline">\(\vec{v_\parallel}\)</span>，旋转后的保持不变，四元数表达形式：<span
class="math inline">\(v_\parallel^\prime=v_\parallel\)</span></p>
<p><span class="math display">\[
\begin{equation}\begin{aligned}v^\prime&amp;=v_\parallel^\prime+v_\perp^\prime\\&amp;=v_\parallel+qv_\perp\\&amp;=1\cdot{v_\parallel}+qv_\perp\\&amp;=pp^{-1}v_\parallel+ppv_\perp（令p^2=q,p=[cos(\frac{1}{2}\theta),sin(\frac{1}{2}\theta)\vec{u})]）\\&amp;=p{v_\parallel}p^*+p{v_\perp}p^*\\&amp;=p(v_\parallel+v_\perp)p^*\\&amp;=pvp^*\end{aligned}\end{equation}
\]</span></p>
<p>其中第四步涉及到一个引理证明，第五涉及到两个引理证明，这里就不进行搬运了。</p>
<p>最后我们可以得到四元数型，一般情况的3D旋转公式，对任意向量<span
class="math inline">\(\vec{v}\)</span>沿以单位向量定义的旋转轴<span
class="math inline">\(\vec{u}\)</span>旋转<span
class="math inline">\(\theta\)</span>度后得到的<span
class="math inline">\(\vec{v^\prime}\)</span>可以通过四元数乘法得到，令<span
class="math inline">\(v=\begin{bmatrix}0,\vec{v}\end{bmatrix},
q=\begin{bmatrix}\cos({\frac{1}{2}\theta}),\sin({\frac{1}{2}\theta})\vec{u}\end{bmatrix}\)</span>，有</p>
<p><span class="math display">\[
\begin{equation}v^\prime=qvq^*=qvq^{-1}\end{equation}
\]</span></p>
<h2 id="d旋转的矩阵形式">3.3 3D旋转的矩阵形式</h2>
<p>对左乘一个四元数<span
class="math inline">\(q=a+bi+cj+dk\)</span>等同于下面这个矩阵</p>
<p><span class="math display">\[
\begin{equation}L(q)=\begin{bmatrix}a&amp;-b&amp;-c&amp;-d\\b&amp;a&amp;-d&amp;c\\c&amp;d&amp;a&amp;-b\\d&amp;-c&amp;b&amp;a\\\end{bmatrix}\end{equation}
\]</span></p>
<p>同样的，右乘q等同于这个矩阵</p>
<p><span class="math display">\[
\begin{equation}R(q)=\begin{bmatrix}a&amp;-b&amp;-c&amp;-d\\b&amp;a&amp;d&amp;-c\\c&amp;-d&amp;a&amp;b\\d&amp;c&amp;-b&amp;a\\\end{bmatrix}\end{equation}
\]</span></p>
<p>对先前的<span
class="math inline">\(q=\begin{bmatrix}\cos({\frac{1}{2}\theta}),\sin({\frac{1}{2}\theta})\vec{u}\end{bmatrix}\)</span>，可以转换成<span
class="math inline">\(a=\cos(\frac{1}{2}\theta),
b=\sin(\frac{1}{2}\theta)u_x,c=\sin(\frac{1}{2}\theta)u_y,d=\sin(\frac{1}{2}\theta)u_z,
q=a+bi+cj+dk\)</span>，我们就能得到</p>
<p><span class="math display">\[
\begin{equation}qvq^*=\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;1-c^2-2d^2&amp;2bc-2ad&amp;2ac+abd\\0&amp;2bx+2ad&amp;1-2b^2-2d^2&amp;2cd-2ab\\0&amp;2bd-2ac&amp;2ab+2cd&amp;1-2b^2-2c^2\end{bmatrix}v\end{equation}
\]</span></p>
<p>注意了，这里的<span
class="math inline">\(v\)</span>是纯四元数，等式左侧也是四元数的形式下的3D旋转</p>
<p>由于我们知道<span
class="math inline">\(v=\begin{bmatrix}0,\vec{v}\end{bmatrix}\)</span>，所以上述矩阵的最外圈不会进行任何变换，可以将它压缩成3x3的矩阵，3D旋转的矩阵形式不如四元数形式简单，且占用更多空间，但是预计算好的矩阵对于大批量的变换是更有效率的。</p>
<p><span class="math display">\[
\begin{equation}\vec{v^\prime}=\begin{bmatrix}1-c^2-2d^2&amp;2bc-2ad&amp;2ac+abd\\2bx+2ad&amp;1-2b^2-2d^2&amp;2cd-2ab\\2bd-2ac&amp;2ab+2cd&amp;1-2b^2-2c^2\end{bmatrix}\vec{v}\end{equation}
\]</span></p>
<h2 id="todo-你可能还会需要">TODO 你可能还会需要</h2>
<p>四元数欧拉角之间的变换：<a
href="http://zhaoxuhui.top/blog/2018/03/13/RelationBetweenQ4&amp;R&amp;Euler.html#5%E6%AC%A7%E6%8B%89%E8%A7%92%E8%BD%AC%E5%9B%9B%E5%85%83%E7%B4%A0">http://zhaoxuhui.top/blog/2018/03/13/RelationBetweenQ4&amp;R&amp;Euler.html#5欧拉角转四元素</a></p>
<p>让你快速变换的网站工具：</p>
<p><a
href="https://quaternions.online/">https://quaternions.online/</a></p>
<h2 id="万向节死锁">万向节死锁</h2>
<p>包含了万向节死锁的部分问题，以Unity为例的回答</p>
<p><a
href="https://www.zhihu.com/question/321381903/answer/667753991">为什么Unity3d旋转默认采用了有万向节死锁的欧拉角，而不用四元数？</a></p>
<p><a
href="https://krasjet.github.io/quaternion/bonus_gimbal_lock.pdf">bonus_gimbal_lock.pdf</a></p>
<p>个人向的梳理总结：</p>
<p><strong>万向节死锁（Gimbal
Lock）</strong>，是指在将一个旋转拆分成<strong>物体自身</strong>三个正交坐标轴，并按照<strong>固定次序</strong>旋转的情况下，存在特殊情况使得其中的两次旋转变换实际上变换的是同一个轴（<strong>外部轴</strong>/<strong>世界坐标轴</strong>）。</p>
<a href="/p/d376051877fb/GimbalLock.gif" class="gallery-item"><img src="/p/d376051877fb/GimbalLock.gif" class="" title="用Unity做的演示，可以看到y轴旋转90°后z轴正方向和原先的x轴正方向一致"></a>
<p>注意：物体自身的坐标轴正方向会随着物体的旋转而改变，而外部轴/世界坐标轴正方向是始终不变的，不随着物体旋转而改变。在连续的旋转变换中，下面给出的旋转矩阵针对的“轴”，要以外部轴/世界坐标轴的方式去理解。</p>
<p>从数学上给出示例进行解释，首先对于x、y、z轴上的旋转，有下述旋转矩阵</p>
<p><span class="math display">\[
\begin{equation}R_x(\theta)=\begin{bmatrix}1&amp;0&amp;0\\0&amp;\cos{\theta}&amp;-\sin{\theta}\\0&amp;sin{\theta}&amp;\cos{\theta}\end{bmatrix}\end{equation}
\]</span></p>
<p><span class="math display">\[
\begin{equation}R_y(\theta)=\begin{bmatrix}\cos{\theta}&amp;0&amp;\sin{\theta}\\0&amp;1&amp;0\\-\sin{\theta}&amp;0&amp;\cos{\theta}\end{bmatrix}\end{equation}
\]</span></p>
<p><span class="math display">\[
\begin{equation}R_z(\theta)=\begin{bmatrix}\cos{\theta}&amp;-sin{\theta}&amp;0\\\sin{\theta}&amp;\cos{\theta}&amp;0\\0&amp;0&amp;1\end{bmatrix}\end{equation}
\]</span></p>
<p>我们固定按照x、y、z轴的顺序进行旋转，并假设沿x轴旋转任意度，沿y轴旋转90°，再沿z轴旋转任意度，可以得到如下结果：沿物体y轴旋转后，物体z轴变换到了原来物体x轴的方向（即同一个世界轴方向）。也就是说<strong>三次旋转变换仅仅覆盖了两个外部轴/世界轴的旋转</strong>，一个自由度就这样丢失了，这也就导致了Gimbal
Lock的现象。</p>
<p>将变换用公式进行理解：</p>
<p><span class="math display">\[
\begin{equation}\begin{aligned}E(\alpha,\frac{\pi}{2},\beta)&amp;=R_z(\beta)R_y(\frac{\pi}{2})R_x(\alpha)\\&amp;=\begin{bmatrix}0&amp;\sin({\alpha-\beta})&amp;\cos({\alpha-\beta})\\0&amp;\cos({\alpha-\beta})&amp;-\sin({\alpha-\beta})\\-1&amp;0&amp;0\\\end{bmatrix}\\&amp;=R_y(\frac{\pi}{2})R_x(\alpha-\beta)\end{aligned}\end{equation}
\]</span></p>
<p>*补充解释在一些旋转描述中可能看到的术语：pitch是俯仰角，围绕x轴转动；yaw是偏航角，围绕y轴转动；roll是翻滚角，围绕z轴转动。起源于航空术语，想象一架飞机，头部指向z轴正方向，左机翼指向x轴正方向，可能会易于理解。</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script src="/js/lg-thumbnail.min.js"></script><script src="/js/lg-zoom.min.js"></script><script src="/js/lg-fullscreen.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>复数</tag>
        <tag>四元数</tag>
        <tag>万向节死锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity IL2CPP 编码限制</title>
    <url>/p/24d663e5b3a4/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="参考">参考</h2>
<ol type="1">
<li><a
href="https://docs.unity3d.com/2018.4/Documentation/Manual/ScriptingRestrictions.html">unity
documentation-Scripting restrictions 2018.4</a></li>
<li><a
href="https://docs.unity3d.com/2022.3/Documentation/Manual/ScriptingRestrictions.html">unity
documentations-Scripting restrictions 2022.3</a></li>
</ol>
<p>内容相差不大，2022.3在2018.4的基础上做了一些补充，并去除了一个关于泛型虚方法例子。</p>
<h2 id="ahead-of-time编译aot">Ahead-of-time编译（AOT）</h2>
<p>一些平台不允许运行时的代码生成（运行时开辟内存用于存放可执行的机器指令）。因此，一切依赖于just-in-time（JIT）的托管代码（managed
code）在这些平台上都无法运行。为此，你需要把所有的托管代码都进行AOT编译。在一般情况下，这个限制不会带来什么影响。但在AOT编译的平台上，也存在着一些需要额外注意的要点。</p>
<span id="more"></span>
<h3 id="自省反射-reflection">自省/反射 Reflection</h3>
<p>在AOT平台，反射仍然是支持的。但如果编译器不能够推断出一段代码会被反射执行，那么这段代码在运行时可能就不会存在，更多内容可以参考<a
href="https://docs.unity3d.com/2022.3/Documentation/Manual/ManagedCodeStripping.html">Managed
Code Stripping</a>一文。</p>
<h3 id="system.reflection.emit">System.Reflection.Emit</h3>
<p>在AOT的平台上无法实现任何在<code>System.Reflection.Emit</code>命名空间下的方法。其余<code>System.Reflection</code>命名空间下的内容都可以正常执行，只要如上所说，编译器能够推断出这段代码会被通过反射执行。</p>
<h3 id="序列化">序列化</h3>
<p>AOT平台如果在序列化或者反序列化的过程使用了反射，那么有可能会遇到问题。如果一个类型或者方法只在序列化或者反序列化的过程中通过反射被获取到，那么AOT编译器就无法推断出需要为这个类型或者方法生成相应的代码。</p>
<h3 id="泛型类型与方法">泛型类型与方法</h3>
<p>对于泛型类型和方法，编译器必须判断出那些泛型实例被使用了，因为不同的泛型实例可能需要不同的生成代码。举例来说，<code>List&lt;int&gt;</code>和<code>List&lt;double&gt;</code>所需要的的生成代码就是不同的。不过，由于IL2CPP会在引用类型间共用代码，所以<code>List&lt;object&gt;</code>和<code>List&lt;string&gt;</code>就会共用一份生成代码。</p>
<p>在下列的这些情况中，IL2CPP很可能无法在编译期间生成所需的代码：</p>
<ol type="1">
<li><p>运行时创建泛型实例：<code>Activator.CreateInstance(typeof(SomeGenericType&lt;&gt;).MakeGenericType(someType));</code></p></li>
<li><p>通过泛型实例调用一个静态方法：<code>typeof(SomeGenericType&lt;&gt;).MakeGenericType(someType)).GetMethod(“AMethod”).Invoke(null, null);</code></p></li>
<li><p>调用一个静态的泛型方法：<code>typeof(SomeType).GetMethod(“GenericMethod”).MakeGenericMethod(someType).Invoke(null, null);</code></p></li>
<li><p>一些在编译期间无法被推断出的对泛型虚方法的调用，在2018.4的文档中给出了这样一个例子</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using UnityEngine;
using System;

public class AOTProblemExample : MonoBehaviour, IReceiver
&#123;
    public enum AnyEnum 
    &#123;
        Zero,
        One,
    &#125;

    void Start() 
    &#123;
        &#x2F;&#x2F; Subtle trigger: The type of manager *must* be
        &#x2F;&#x2F; IManager, not Manager, to trigger the AOT problem.
        IManager manager &#x3D; new Manager();
        manager.SendMessage(this, AnyEnum.Zero);
    &#125;

    public void OnMessage&lt;T&gt;(T value) 
    &#123;
        Debug.LogFormat(&quot;Message value: &#123;0&#125;&quot;, value);
    &#125;
&#125;

public class Manager : IManager 
&#123;
    public void SendMessage&lt;T&gt;(IReceiver target, T value) &#123;
        target.OnMessage(value);
    &#125;
&#125;

public interface IReceiver
&#123;
    void OnMessage&lt;T&gt;(T value);
&#125;

public interface IManager 
&#123;
    void SendMessage&lt;T&gt;(IReceiver target, T value);
&#125;</code></pre>
<p>你会得到这样的报错：</p>
<blockquote>
<p>ExecutionEngineException: Attempting to call method
'AOTProblemExample::OnMessage&lt;AOTProblemExample+AnyEnum&gt;' for
which no ahead of time (AOT) code was generated. at
Manager.SendMessage[T] (IReceiver target, .T value) [0x00000] in
&lt;filename unknown&gt;:0 at AOTProblemExample.Start () [0x00000] in
&lt;filename unknown&gt;:0</p>
</blockquote></li>
<li><p>涉及高度嵌套的泛型值类型方法调用，如
<code>Struct&lt;Struct&lt;Struct&lt;...&lt;Struct&lt;int&gt;&gt;&gt;&gt;</code></p></li>
</ol>
<p>IL2CPP为了支持上述这些情况，生成了能够支持任何类型参数的泛型代码。不过这份代码执行起来会更慢，因为它不能就类型的大小或者值类型、引用类型的差异来做出假设。如果你需要一份执行效率更高的泛型生成代码，你需要这样做：</p>
<ul>
<li><p>如果泛型参数永远是引用类型，为它加上<code>where:class</code>的限制。这样IL2CPP就会生成一个使用引用类型的fallback方法，它不会带来额外的性能损耗。</p></li>
<li><p>如果泛型参数永远是值类型，加上<code>where:struct</code>限制，这将启用一些优化策略，但因为值类型的大小可能不同，生成的代码执行起来仍然会更慢一些。</p></li>
<li><p>新增一个<code>UsedOnlyForAOTCodeGeneration</code>方法，并且为你希望IL2CPP生成的泛型类型、泛型方法加上引用。这个方法不需要被调用，也不应该被调用。下述的例子保证了<code>GenericType&lt;MyStruct&gt;</code>会被生成。</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public void UsedOnlyForAOTCodeGeneration()
&#123;
    &#x2F;&#x2F; Ensure that IL2CPP will create code for MyGenericStruct
    &#x2F;&#x2F; using MyStruct as an argument.
    new GenericType&lt;MyStruct&gt;();

    &#x2F;&#x2F; Ensure that IL2CPP will create code for SomeType.GenericMethod
    &#x2F;&#x2F; using MyStruct as an argument.
    new SomeType().GenericMethod&lt;MyStruct&gt;();

    public void OnMessage&lt;T&gt;(T value) 
    &#123;
        Debug.LogFormat(&quot;Message value: &#123;0&#125;&quot;, value);
    &#125;

    &#x2F;&#x2F; Include an exception so we can be sure to know if this
    &#x2F;&#x2F; method is ever called.
    throw new InvalidOperationException(
        &quot;This method is used for AOT code generation only. &quot; +
        &quot;Do not call it at runtime.&quot;);
&#125;</code></pre></li>
</ul>
<p>需要注意的是，当“Faster(smaller)
builds”设置项启用时，只有一份完全共用的泛型代码会被生成并编译。这回较少生成的方法数量，减少编译时长与包体大小，但会带来运行时的性能开销。</p>
<h3 id="从原生层native-code调用托管层managed方法">从原生层（native
code）调用托管层（managed）方法</h3>
<p>在AOT平台上，那些需要被转译（marshaled？不确定如何翻译比较准确）为C方法指针以便于从原生层调用的托管层方法，有一些限制：</p>
<ul>
<li><p>托管方法必须是一个静态方法</p></li>
<li><p>托管方法必须要有<code>[MonoPInvokeCallback]</code>
Attribute</p></li>
<li><p>如果这个托管方法是泛型的，那么便需要使用<code>[MonoPInvokeCallback(Type)]</code>重载来声明哪些具体的类型需要被使用。Type必须要是带有正确泛型参数数量的泛型实例。对一个方法使用复数个<code>[MonoPInvokeCallback]</code>是可能的，如下例：</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; Generates reverse P&#x2F;Invoke wrappers for NameOf&lt;long&gt; and NameOf&lt;int&gt;
&#x2F;&#x2F; Note that the types are only used to indicate the generic arguments.
[MonoPInvokeCallback(typeof(Action&lt;long&gt;))]
[MonoPInvokeCallback(typeof(Action&lt;int&gt;))]
private static string NameOfT&lt;T&gt;(T item) 
&#123;
    return typeof(T).Name;
&#125;</code></pre></li>
</ul>
<h2 id="线程不支持">线程不支持</h2>
<p>一些平台不支持对线程的使用，所以一切使用了<code>System.Threading</code>命名空间的托管层代码都会在运行时出错。同时，一些.NET类库隐式地依赖了线程。一个依赖线程支持的常见例子就是<code>System.Timers.Timer</code>类。</p>
<h2 id="异常过滤器">异常过滤器</h2>
<p>IL2CPP支持异常过滤器，不过异常过滤语句和catch块的次序可能会存在不同，因为IL2CPP使用C++的异常来实现托管层异常。一般情况下这不会被注意到，除非有过滤器阻止了对字段的写操作。</p>
<h2 id="其他">其他</h2>
<ul>
<li>IL2CPP不支持运行时对<code>MarshalAs</code>以及<code>FieldOffset</code>
Attributes 的反射</li>
<li>IL2CPP不支持C#的<code>dynamic</code>关键字，因为它需要JIT编译</li>
<li>IL2CPP不支持<code>Marshal.Prelink</code>或<code>Marshal.PrelinkAll</code>
API方法</li>
<li>IL2CPP不支持<code>System.Diagnostics.Process</code> API方法</li>
</ul>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script src="/js/lg-thumbnail.min.js"></script><script src="/js/lg-zoom.min.js"></script><script src="/js/lg-fullscreen.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>]]></content>
      <categories>
        <category>游戏开发</category>
        <category>引擎脚本后端</category>
      </categories>
      <tags>
        <tag>游戏开发</tag>
        <tag>Unity</tag>
        <tag>IL2CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>向搜索引擎提交hexo站点sitemap</title>
    <url>/p/e620710b2f05/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1
id="向搜索引擎提交hexo站点sitemap">向搜索引擎提交hexo站点sitemap</h1>
<h2 id="简介">简介</h2>
<p>为自己的站点创建sitemap，并通过搜索引擎提供的后台工具进行提交，可以增强个人网站的曝光率。这里简单记录一下hexo要如何生成sitemap，并提交到各大搜索引擎上。</p>
<h2 id="生成sitemap">生成sitemap</h2>
<ol type="1">
<li><p>进入到个人hexo博客<code>_config.yml</code>同级目录下，使用npm安装<code>hexo-generator-sitemap</code>以及<code>hexo-generator-baidu-sitemap</code>，命令如下</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install hexo-generator-sitemap --save
npm install hexo-generator-baidu-sitemap --save</code></pre></li>
<li><p>安装完成后，编辑博客的配置文件<code>_config.yml</code>，加入以下内容</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># For generating google &#x2F; bing &#x2F; baidu sitemap↓
Plugins:
- hexo-generator-sitemap
- hexo-generator-baidu-sitemap

baidusitemap:
  path: baidusitemap.xml # 百度用的sitemap生成在public根目录的此文件内
sitemap:
  path: sitemap.xml # 其他sitemap生成在public根目录的此文件内</code></pre></li>
</ol>
<span id="more"></span>
<ol start="3" type="1">
<li><p>回到个人博客根目录，执行<code>hexo g -d</code>
生成并部署（threegates是部署在github-pages上的），观察到以下输出则为生成成功</p>
<a href="/p/e620710b2f05/image-20221211173054833.png" class="gallery-item"><img src="/p/e620710b2f05/image-20221211173054833.png" class="" title="命令数据结果"></a></li>
<li><p>等待github部署完成后，访问个人博客站点<code>url/sitemap.xml</code>能访问到对应xml内容即生成成功</p></li>
</ol>
<h2 id="提交sitemap">提交sitemap</h2>
<p>几大常用搜索引擎对应的站点管理员后台，提交sitemap位置如下：</p>
<ol type="1">
<li><p>Google：<a href="https://search.google.com/search-console">Google
Search Console</a> 需要先注册自己的站点资源，提交位置如下</p>
<a href="/p/e620710b2f05/image-20221211173607448.png" class="gallery-item"><img src="/p/e620710b2f05/image-20221211173607448.png" class="" title="image-20221211173607448"></a></li>
<li><p>Bing：<a href="https://www.bing.com/webmasters/">Webmaster
Tools</a> 同上，提交位置在</p>
<a href="/p/e620710b2f05/image-20221211173724782.png" class="gallery-item"><img src="/p/e620710b2f05/image-20221211173724782.png" class="" title="image-20221211173724782"></a></li>
<li><p>百度：<a
href="https://ziyuan.baidu.com/linksubmit/index">搜索资源平台</a>
使用的是<strong>普通收录</strong>下的sitemap方法，也类似上面两种，填写xml文件地址即可</p>
<a href="/p/e620710b2f05/image-20221211173911628.png" class="gallery-item"><img src="/p/e620710b2f05/image-20221211173911628.png" class="" title="image-20221211173911628"></a></li>
</ol>
<h2 id="结语">结语</h2>
<p>threegates的sitemap已经上传到上述几个搜索平台上了，未来几天会关注一下搜索得到的结果如何，如果有不错的结果再到这篇博客里同步一下。</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script src="/js/lg-thumbnail.min.js"></script><script src="/js/lg-zoom.min.js"></script><script src="/js/lg-fullscreen.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>]]></content>
      <categories>
        <category>博客搭建</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>TableCraft is finally here!</title>
    <url>/p/fc631eddaa53/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="tablecraft-is-finally-here">TableCraft is finally here!</h1>
<h2 id="tablecraft-发布">TableCraft 发布！</h2>
<p>从21年起经过两年断断续续的开发，TableCraft终于发布了<a
href="https://github.com/kalulas/TableCraft/releases/tag/v1.0.0">v1.0.0</a>版本，并开始提供给项目组同事使用了。这篇文章会介绍从最初立项到最终发布TableCraft的设计发生了怎样的变化，TableCraft现阶段存在的一些问题，以及未来的发展目标。</p>
<span id="more"></span>
<h2 id="起始">起始</h2>
<p>开发TableCraft的初衷是为了让自己能从手写读表代码的痛苦中解放出来：重复而机械的工作，除了徒增出错的风险没有任何意义。</p>
<p>在这几年的项目开发过程中，程序组也出于缩短启动时间，减少解析配置表的内存分配、内存占用，推进过几次读表代码的优化，如多线程读取解析，csv格式配置转为binary格式。概括下来，手写读表代码除了累人，自行实现的读表代码提供了过高的自由度，还会带来额外的问题：</p>
<ul>
<li>不同配置表中相同数值类型字段的读取行为可能不一致（空字符串代表false？true？），配置负责人难以形成习惯，配置错误风险高。</li>
<li>将csv格式转换为binary格式可能丢失部分信息，使得难以生成、甚至无法生成对应的binary读表代码。</li>
<li>不同的配置表之间可能存在依赖，使得多线程优化工作难以展开。</li>
<li>开发者自身水平问题导致读表代码效率差，资源占用多。</li>
</ul>
<p>同时正所谓由奢入俭难，在先前项目组体验过多端一致（C++，C#，Lua，应用于客户端运行时，客户端编辑器，服务器）的配置表读取库，与配置表编辑、代码生成工具后，每次手写读表代码都是一种煎熬。于是在21年末的一个稍稍有空的周末，TableCraft的开发工作开始了。</p>
<h2 id="经由">经由</h2>
<p>TableCraft最初的设计构想如下：</p>
<ol type="1">
<li>兼容常见的配置文件格式</li>
<li>为配置文件设计元数据文件，补全生成读表代码所需的描述信息</li>
<li>提供读表代码的文本形式模板（Template）文件，而不将读表代码内容硬编码到工具中，目的有：
<ol type="1">
<li>工具可跨项目组使用，减少重复开发工作量</li>
<li>考虑到读表代码发生改变的频率较高，将代码模板化可以减少重复编译</li>
</ol></li>
<li>将配置文件与元数据文件、代码模板文件结合，生成各种语言的读表代码</li>
<li>提供单独的library文件，可开发命令行脚本用于构建任务，也可开发图形化工具用于日常开发使用</li>
</ol>
<p>有了基本目标之后，21年末就着手以C#进行核心dll的开发（也就是这时我发布了
<a href="https://www.threegates.net/p/ab7a58fcc8d2/" title="" target="">关于配置代码生成器的构想</a>），但卡在了两点上：</p>
<ol type="1">
<li>若要实现读表代码模板化，意味着需要设计自己的模板语法，以及模板文件编译器；虽说不至于无从下手，但工作量比预期的大很多。</li>
<li>对使用什么GUI开发框架没有下定主意，当时甚至想过使用ImGUI</li>
</ol>
<p>由于项目组的工作也繁忙起来，TableCraft的开发工作就暂且搁置了。但现在回想起来，也庆幸当时及时停手了，才能在后来找到更为成熟的解决方案。看来有些时候闷头干活真的不可取，放下执念，沉下心学点东西才是卓越之路啊。</p>
<p>23年在写博客的时候发现，支持markdown格式的博客框架其实都应用了类似的模板（Template）技术，使用用户提交的markdown文本，根据一些预设好的规则，来生成出最终的静态html页面。这时候我才意识到，搜索的关键字应该是模板（Template）。</p>
<p>果不其然，.NET 中也有类似的解决方案，称作
<a href="https://learn.microsoft.com/en-us/visualstudio/modeling/code-generation-and-t4-text-templates?view=vs-2022" title="" target="">T4 Text Template</a>，也不是什么新鲜技术了，甚至在开发时还是借用了第三方库才实现了兼容
.net6。</p>
<p>而GUI框架的选取上，则是采用了项目组前辈推荐的
<a href="https://docs.avaloniaui.net/" title="" target="">Avalonia UI</a>。现在回想起来，其实应该从WPF开始体验的好，直接入手
AvaloniaUI 可能缺失了一些比较的过程，不过不得不承认选取AvaloniaUI
大大提高了开发速度。</p>
<p>最终，TableCraft以这样的形式呈现了出来：</p>
<ol type="1">
<li>核心库 nuget: <a href="https://www.nuget.org/packages/TableCraft.Core" title="" target="">TableCraft.Core</a></li>
<li>核心库 github page: <a href="https://github.com/kalulas/TableCraft.Core" title="" target="">TableCraft.Core</a></li>
<li>基于Avalonia的可视化编辑器 github page: <a href="https://github.com/kalulas/TableCraft" title="" target="">TableCraft(Editor)</a></li>
</ol>
<h2 id="缺陷">缺陷</h2>
<p>在TableCraft正式投入使用的这一段时间内，对工具的反思也在持续进行中。</p>
<p>从具体实现的角度，TableCraft存在以下几点问题：</p>
<ol type="1">
<li>受游戏开发经验的影响使用了LitJson库，实际上对于现代的.net
应用开发，使用标准的Newtonsoft.Json会更好一些。</li>
<li>配置文件分散且配置方式比较原始。</li>
</ol>
<p>而从设计思路的角度来看，TableCraft可能存在一些更严重的问题：</p>
<ol type="1">
<li>TableCraft不可避免地硬编码了配置表元数据的json格式，对于使用工具的用户来说，了解并使用此json格式是不可避免的。如果出现目前元数据不能满足的需求，实际上还是根据项目的需求扩展
TableCraft.Core。</li>
<li>TableCraft虽然设计了数据源文件（Source）以及描述文件（Decorator）的接口类型，但实际上若要支持新的文件类型，还是需要额外的开发量，这也是很难避免的。不同项目所需要的支持的文件类型可能不同，理想情况是可以使用插件形式来做支持，如果做成
all-in-one 就有些臃肿了。</li>
<li>T4 Text Template
并不是普及度很广的解决方案，虽然可以使用C#进行编码，但有一定学习成本。并且即使是在IDE里进行编写Template(.txt)文件，体验也比不上直接编辑源文件。这点可能会对模板文件的维护带来负面影响。</li>
</ol>
<p>结合上述问题看，对于一个没有任何现成解决方案的新项目开发组来说，如果对硬编码读表代码没有太大抵触，自行设计元数据格式，并自行开发配置文件编辑器，生成读表代码，实际上工作量也不比使用TableCraft大多少。而实际上，配置解决方案在同一开发组/公司的项目间一般都会进行流通，所以相信大多数新项目也都会有现成的解决方案。</p>
<p>所以TableCraft的完工虽然可喜可贺，但考虑到上述问题，想要看到TableCraft“流行起来”可能还是有相当难度的。但或许也正是完成了TableCraft，才让我意识到了上面这些问题，从这个角度来看，23年的上半年也可以当作是没有白费了。</p>
<h2 id="展望">展望</h2>
<p>那么TableCraft是否还会有新内容上传呢？答案是肯定的，虽然时间上给不出什么保证（笑）。接下来我将目前能想到的一些可以开展的工作记录在这里，会按照实现成本从低到高的次序排序：</p>
<ol type="1">
<li>考虑到未来配置表的数量可能会变得很多，配置表浏览列表和字段浏览列表会新增一个搜索框。</li>
<li>会在TableCraft中新增一个弹出窗口来配置appsetting.json中的内容。</li>
<li>版本控制相关更隐私的账号密码内容可能还是写进注册表的好。</li>
<li>如果要做成看起来更完善的工具，考虑用installer的形式来安装，还需要工具的发布与更新检测。</li>
</ol>
<p>最后要补充的一个内容也是来自日常工作中的体会：在这几年的工作中没少听策划同事关于配表的抱怨，实际上在需要让配置表满足多环境、多地区、多用途需求的情况下，想要减少重复配置量、减少配置错误属实是很困难的一件事。</p>
<p>在这种环境下，经常会诞生出很多奇怪的配置表机制，例如配置表的其中一列是比特位，此行仅在特定地区、特定环境生效；或者在某某条件下，一张小表能够合并到原先的同名大表中；在某某条件下，去读A路径的配置表而不读B路径的配置表。</p>
<p>因此，配置表<strong>编辑器</strong>的开发看上去就非常必要了。设想中的配置表编辑器应该有这些功能：</p>
<ol type="1">
<li>字段类型检查。类型检查是减少配置问题的重中之重。</li>
<li>主键和外键。数据库中的概念在这里依然有用，使用外键更好地支持配置表的跳转与KeyExist检查。</li>
<li>配置表的声明，同时创建元数据进行描述。一个“配置表”不再与一个文件一一对应，而是一组文件的抽象：可以是不同环境（客户端，后台服务器...）下的配置表，也可以是同意环境下不同地区的配置表。</li>
<li>原型模式的支持，即可声明基于配置表A的配置表B。配置表B的数据是基于A的增删改，配置表B只需要编辑改动，也只储存改动数据。而在Build阶段后，运行时，配置表B将有基于A的完整配置数据。</li>
<li>配置数据的导出。有了上述的配置表元数据描述这就很好办了，运行时要用csv，json，binary都可以。</li>
</ol>
<p>不过自然，开发这些功能也要不少工作量，也不是可以不和项目组沟通一个人闷头做的，所以目前也只停留在“想想而已”的阶段。或许未来在一些别的项目组干活会发现他们已经有现成的工具了呢（我觉得是应该要有的）。</p>
<p>那么这篇文章也就到此告一段落啦，希望我们不久后还会再见！</p>
<p>2024新年快乐！</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script src="/js/lg-thumbnail.min.js"></script><script src="/js/lg-zoom.min.js"></script><script src="/js/lg-fullscreen.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>游戏开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>《The Way to Go》Chapter13 错误处理与测试</title>
    <url>/p/e22df32995f4/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="chapter-13-错误处理与测试">Chapter 13 错误处理与测试</h1>
<h2 id="错误处理与测试">错误处理与测试</h2>
<ol type="1">
<li><p>Go通常在函数和方法中返回错误对象作为返回值，如果返回nil则没有错误发生</p></li>
<li><p>永远不要忽略错误，否则可能会导致程序崩溃！调用函数后必须检查错误</p></li>
<li><p>为了让代码更清晰，应该使用包含错误值变量的if 符合语句</p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">if value, err :&#x3D; pack1.Func1(param1); err !&#x3D; nil &#123;
    fmt.Printf(&quot;Error %s in pack1.Func1 with parameter %v&quot;, err.Error(), param1)
    return    &#x2F;&#x2F; or: return err
&#125; else &#123;
    &#x2F;&#x2F; Process(value)
&#125;</code></pre></p></li>
</ol>
<span id="more"></span>
<h2 id="错误处理">错误处理</h2>
<ol type="1">
<li><p>使用errors包来创建一个错误类型对象，附带上错误信息</p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">err :&#x3D; errors.New(&quot;math - square root of negative number&quot;)</code></pre></p></li>
<li><p>自定义一个错误结构，除了低层级错误信息还附带一些额外信息；在不同错误可能发生的场景下，对错误使用类型断言/类型判断(type-switch)</p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; PathError records an error and the operation and file path that caused it.
type PathError struct &#123;
    Op string    &#x2F;&#x2F; &quot;open&quot;, &quot;unlink&quot;, etc.
    Path string  &#x2F;&#x2F; The associated file.
    Err error  &#x2F;&#x2F; Returned by the system call. 低层级错误信息
&#125;

&#x2F;&#x2F;  err !&#x3D; nil
if e, ok :&#x3D; err.(*os.PathError); ok &#123;
    &#x2F;&#x2F; remedy situation
&#125;</code></pre></p></li>
</ol>
<h2 id="运行时异常和panic">运行时异常和panic</h2>
<ol type="1">
<li>当发生了需要将程序停止的错误时，使用<code>panic()</code>产生一个中止程序的运行时错误。</li>
<li>传递任意类型的参数给<code>panic()</code>，会在程序终止的信息中被打印出来。</li>
<li><code>panic()</code>所在函数的后一行代码不会执行，但panic会把执行控制权交还给上层，并执行每层的defer，这个过程叫做<code>panicking</code></li>
</ol>
<h2 id="从panic中恢复recover">从panic中恢复（recover）</h2>
<p><code>recover</code>只能在<code>defer</code>修饰的函数中使用，如果发生了panic，那么<code>defer</code>修饰的函数会执行，且<code>recover</code>将得到对应的错误值，否者将返回nil并且没有其他效果</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func protect(g func()) &#123;
    defer func() &#123;
        log.Println(&quot;done&quot;)
        &#x2F;&#x2F; Println executes normally even if there is a panic
        if err :&#x3D; recover(); err !&#x3D; nil &#123;
            log.Printf(&quot;run time panic: %v&quot;, err)
        &#125; &#x2F;&#x2F; 这里之后执行protect()之后的指令
    &#125;()
    log.Println(&quot;start&quot;)
    g() &#x2F;&#x2F;   possible runtime-error
&#125;</code></pre>
<h2
id="自定义包中的错误处理和panicking">自定义包中的错误处理和panicking</h2>
<p>应该遵守的最佳实践：</p>
<ol type="1">
<li>在包内部，总是应该从panic中recover，不允许显式的超出包范围的panic()</li>
<li>向包的调用者返回错误值（而不是panic）</li>
</ol>
<h2 id="go中的单元测试和基准测试">Go中的单元测试和基准测试</h2>
<p>测试使用的工具是gotest，使用名为<code>testing</code>的包，测试代码和包中的业务代码是分开的，<code>_test</code>代码与程序不会被普通的Go编译器编译，只有gotest会编译所有的程序。</p>
<p>使用<code>go test</code>来编译测试程序，对于通过的测试会打印PASS，对于<code>go test -test.bench=.*</code>会运行基准测试，调用N次并展示N次的值和执行的平均时间。</p>
<h2 id="性能调试分析并优化go程序">性能调试：分析并优化Go程序</h2>
<ol type="1">
<li><p>unix命令行中可以使用<code>time</code>命令，输出程序的执行时间和内存占用等</p></li>
<li><p>使用Go中的<code>testing</code>包进行基准测试，使用-cpuprofile /
-memprofile 标志向指定文件写入CPU或内存使用情况报告</p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">go test -x -v -cpuprofile&#x3D;prof.out -file x_test.go</code></pre></p></li>
<li><p>可以在程序中引入 <code>runtime/pprof</code>
包，这个包以pprof可视化工具需要的格式写入运行时报告数据。gopprof是Google
pprofC++
分析器的一个轻微变种，如果开启此性能分析，Go程序会以大约每秒100次的频率阻塞。为实现性能分析，你可以像下面这样添加代码：</p></li>
</ol>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var cpuprofile &#x3D; flag.String(&quot;cpuprofile&quot;, &quot;&quot;, &quot;write cpu profile to file&quot;)

func main() &#123;
    flag.Parse()
    if *cpuprofile !&#x3D; &quot;&quot; &#123;
        f, err :&#x3D; os.Create(*cpuprofile)
        if err !&#x3D; nil &#123;
            log.Fatal(err)
        &#125;
        pprof.StartCPUProfile(f)
        defer pprof.StopCPUProfile()
    &#125;
...</code></pre>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script src="/js/lg-thumbnail.min.js"></script><script src="/js/lg-zoom.min.js"></script><script src="/js/lg-fullscreen.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>《The Way to Go》Chapter14 协程</title>
    <url>/p/4aa7a9cb350b/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="chapter-14">Chapter 14</h1>
<h2
id="协程goroutine与通道channel">协程（goroutine）与通道（channel）</h2>
<p>Go为构建并发程序的基本代码块是协程与通道，需要语言、编译器和runtime支持。Go语言提供的垃圾回收器对并发编程至关重要（？）。</p>
<p>原则：<strong>不要通过共享内存来通信，而通过通信来共享内存。</strong></p>
<span id="more"></span>
<h2 id="并发并行和协程">并发、并行和协程</h2>
<ol type="1">
<li>复习：进程的复数线程是共享同一地址空间的一起工作的执行体，只有在多核、多处理器上并发程序才能做到并行。</li>
<li>Go中，并发处理的部分被称为
<code>goroutines（go协程）</code>，在协程与操作系统线程之间无一对一的关系；协程是根据一个/多个线程的可用性，映射在它们之上的。“协程调度器”在<strong>Go运行时</strong>完成这个工作。</li>
<li>协程是轻量的，比线程更轻。在堆中创建协程，且协程对栈进行了分割，从而动态增加缩减内存的使用。</li>
<li>协程通过关键字go调用（执行一个函数或方法）来实现，调用后即会分配出独立的栈，开始同时进行的计算过程（并发
/ 并行）；协程的栈会根据需要进行伸缩，不会出现栈溢出（？）</li>
<li>main函数也被看作是一个go协程</li>
<li>当main函数返回的时候，程序退出，不会等待任何非main协程的结束，所以在服务器程序中，一般会给每个请求启动一个协程，而server函数使用一个无限循环来保持运行状态</li>
</ol>
<h3 id="使用-gomaxprocs">使用 GOMAXPROCS</h3>
<ol type="1">
<li>设置环境变量，或者使用<code>runtime.GOMAXPROCS(n)</code>
来设置允许运行时使用多少个操作系统线程，如果未设置<code>GOMAXPROCS</code>，则所有协程会共享同一个线程。</li>
<li>经验：对n个核心的情况设置GOMAXPROCS为n-1来获得最佳性能</li>
<li>可以遵循的规则：协程的数量 &gt; 1 + GOMAXPROCS &gt; 1</li>
</ol>
<h3 id="go协程与协程">Go协程与协程</h3>
<p>Go协程与其他语言中的协程有两点不同：</p>
<ol type="1">
<li>Go协程意味着并行，但协程一般来说不是这样的</li>
<li>Go协程通过通道channel来通信；协程通过让出（await）和恢复（async）操作来通信</li>
</ol>
<h2 id="协程间的信道">协程间的信道</h2>
<ol type="1">
<li><p>Go将<strong>通道(channel)</strong>作为一种特殊的类型，用于发送类型化数据的管道，由其负责协程之间的通信。在<strong>任何给定时间</strong>，一个数据被设计为<strong>只有一个协程可以对其访问</strong>，所以不会发生数据竞争</p></li>
<li><p>通道也是<strong>引用类型</strong>，通道的声明与实例化方式</p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">var ch1 chan string
ch1 &#x3D; make(chan string)
&#x2F;&#x2F; 精简形式
ch1 :&#x3D; make(chan string)</code></pre></p></li>
<li><p>使用操作符<code>&lt;-</code>
来表示数据的传输，<code>ch &lt;- int1</code>
表示用通道<code>ch</code>发送变量<code>int1</code>，<code>int2 = ← ch</code>
表示，从通道<code>ch</code>中取出数据，赋值给<code>int2</code></p></li>
<li><p>通道的发送和接收都是<strong>原子操作</strong>，它们互不干扰地完成</p></li>
</ol>
<h3 id="通道阻塞">通道阻塞</h3>
<p>默认情况下通道是<strong>同步</strong>且<strong>无缓冲</strong>的 →
发送/接收操作在对方处理完之前是阻塞的：</p>
<ol type="1">
<li>如果通道中的数据无人接收，就无法再给通道传入其他数据，发送者阻塞；发送操作会等待到通道重新变为可用状态，即通道中没有数据
/ 通道为空的情况 →
即发完之后如果通道没有被接收者处理清空，发送操作阻塞</li>
<li>如果通道中没有数据，接收者阻塞；接收操作会等待到通道重新变为可用状态，即通道中有数据
/ 通道已满的情况 →
即接收完之后如果通道没有被发送者塞满，读取操作阻塞</li>
</ol>
<p>不带缓冲的通道传递有点像两个人传递东西，如果传出去没有对方接走，人就离开了（不阻塞），东西就会掉下去。传出去必须要等到对方接走，自己才能继续做其他事情，所以是同步的。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func f1(in chan int) &#123;
    fmt.Println(&lt;-in)
&#125;

func main() &#123;
    out :&#x3D; make(chan int)
    out &lt;- 2
    go f1(out) &#x2F;&#x2F; out 中的 2 无人接收，main协程中的&#39;go f1(out)&#39;被阻塞
&#125;</code></pre>
<h3 id="同步通道-使用带缓冲的通道">同步通道-使用带缓冲的通道</h3>
<p>不带缓冲的通道容量是0，通信要双方都准备好了才能进行，容量1和无缓冲绝对是不一样的。</p>
<p>拓展make命令来设置通道容量，用于提供缓存</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">buf :&#x3D; 100
ch1 :&#x3D; make(chan string, buf) &#x2F;&#x2F; buf 是通道可以容纳元素的个数</code></pre>
<p>容量大于0的通道就是异步的了，对于发送操作来说，在发送到通道满载之前不会阻塞；对于接收操作来说，在接收到通道变空之前也不会阻塞；</p>
<h3 id="信号量模式">信号量模式</h3>
<p>可以在协程结束时往通道中放置一个值作为处理结束的信号，而在<code>main()</code>协程中等待从这个通道中取得值，来保证<code>main</code>不会提前结束</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type Empty interface &#123;&#125;
var empty Empty
...
data :&#x3D; make([]float64, N)
res :&#x3D; make([]float64, N)
sem :&#x3D; make(chan Empty, N)
...
&#x2F;&#x2F; 开始N个协程
for i, xi :&#x3D; range data &#123;
    go func (i int, xi float64) &#123;
        res[i] &#x3D; doSomething(i, xi)
        sem &lt;- empty
    &#125; (i, xi)
&#125;
&#x2F;&#x2F; 等待所有的协程结束
for i :&#x3D; 0; i &lt; N; i++ &#123; &lt;-sem &#125;</code></pre>
<h3 id="使用带缓冲通道实现信号量">使用带缓冲通道实现信号量</h3>
<p>声明空接口类型，并声明信号量</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type Empty interface &#123;&#125;
type semaphore chan Empty</code></pre>
<p>将可用资源的数量 <code>N</code>来初始化信号量 <code>semaphore</code>：<code>sem = make(semaphore, N)</code></p>
<p>便可定义P操作与V操作</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; acquire n resources
func (s semaphore) P(n int) &#123;
    e :&#x3D; new(Empty)
    for i :&#x3D; 0; i &lt; n; i++ &#123;
        s &lt;- e
    &#125;
&#125;

&#x2F;&#x2F; release n resources
func (s semaphore) V(n int) &#123;
    for i:&#x3D; 0; i &lt; n; i++&#123;
        &lt;- s
    &#125;
&#125;</code></pre>
<h3 id="通道的方向">通道的方向</h3>
<p>可以通过注解来表示通道只发送或者只接收数据，如下</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func source(ch chan&lt;- int)&#123;
    for &#123; ch &lt;- 1 &#125;
&#125;

func sink(ch &lt;-chan int) &#123;
    for &#123; &lt;-ch &#125;
&#125;</code></pre>
<p>通道在创建时都是双向的，它们创建后被用于分配给有方向的通道变量</p>
<h2 id="关闭通道">关闭通道</h2>
<ol type="1">
<li><p>通道可以被显式地关闭，只有接收者确定不会提供新的值才需要关闭通道</p></li>
<li><p>只有发送者需要关闭通道，对于接收者来说关闭通道没有意义</p></li>
<li><p>通过逗号ok模式来检测通道是否被关闭</p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">v, ok :&#x3D; &lt;-ch
if !ok &#123;
  break
&#125;
process(v)</code></pre></p></li>
<li><p>使用for-range来读取通道，会自动检测通道是否关闭</p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">for input :&#x3D; range ch &#123;
    process(input)
&#125;</code></pre></p></li>
</ol>
<h2 id="使用select切换协程">使用select切换协程</h2>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">select &#123;
case u:&#x3D; &lt;- ch1:
        ...
case v:&#x3D; &lt;- ch2:
        ...
        ...
default: &#x2F;&#x2F; no value ready to be received
        ...
&#125;</code></pre>
<ol type="1">
<li>从不同并发执行的协程中获取值可以通过<code>select</code>完成，它选择处理列出的多个通道其中一个：
<ul>
<li>如果通道都阻塞了，会等待直到其中一个可以处理</li>
<li>如果有多个通道可以处理，会随机选择出一个</li>
<li>如果没有通道可以处理并且有<code>default</code>语句，那么<code>default</code>语句将执行</li>
</ul></li>
<li>在无限循环中使用一个<code>select</code>语句，来实现一种监听模式。在此模式下，使用<code>break</code>来使循环退出</li>
</ol>
<h2 id="通道超时和计时器ticker">通道、超时和计时器（Ticker）</h2>
<ol type="1">
<li><p>在工厂函数 <code>time.NewTicker</code>中以 <code>Duration</code> 类型的参数传入：<code>func NewTicker(dur) *Ticker</code>，时间间隔单位纳秒</p></li>
<li><p>使用<code>time.Tick()</code>来返回一个指定时间间隔发送时间的通道</p></li>
<li><p>定时器<code>Timer</code>和计时器<code>Ticker</code>类似，但定时器只发送一次时间，使用<code>time.After(d Duration)</code>
来返回一个通道</p></li>
<li><p>场景：从多个数据库同时读取，只需要接收首先到达的答案：这个场景也演示了一个发送数据而不是接收数据的<code>select</code></p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func Query(conns []Conn, query string) Result &#123;
    ch :&#x3D; make(chan Result, 1) 
    for _, conn :&#x3D; range conns &#123; &#x2F;&#x2F; 向多个数据库发起请求
        go func(c Conn) &#123;
            select &#123;
            case ch &lt;- c.DoQuery(query): &#x2F;&#x2F; 如果还没有到达的答案，结果会被放入通道
            default: &#x2F;&#x2F; 否则进入到default语句退出
            &#125;
        &#125;(conn)
    &#125;
    return &lt;- ch &#x2F;&#x2F; 接收者，仅返回第一个到达通道的结果
&#125;</code></pre></p>
<p>注意：使用容量为1的通道ch，这样不会导致第一个结果到达时由于接收者
<code>← ch</code>没有准备好而无法被接收</p></li>
<li></li>
</ol>
<h2 id="新旧模型对比任务和worker">新旧模型对比：任务和worker</h2>
<p>对于任何可以建模为 Master-Worker 范例的问题，一个类似于 worker
使用通道进行通信和交互、Master 进行整体协调的方案都能完美解决。</p>
<p>怎么选择是该使用锁还是通道？</p>
<p>下面列出一个普遍的经验法则：</p>
<ul>
<li>使用锁的情景：
<ul>
<li>访问共享数据结构中的缓存信息</li>
<li>保存应用程序上下文和状态信息数据</li>
</ul></li>
<li>使用通道的情景：
<ul>
<li>与异步操作的结果进行交互</li>
<li>分发任务</li>
<li>传递数据所有权</li>
</ul></li>
</ul>
<p>当你发现你的锁使用规则变得很复杂时，可以反省使用通道会不会使问题变得简单些。</p>
<h2 id="惰性生成器的实现">惰性生成器的实现</h2>
<p>生成器是指被调用时返回一个序列中下一个值的函数，生成器只在需要的时候求值，同时保留相关变量资源，是一项在需要时对表达式进行求值的技术。</p>
<p>可以通过传入匿名函数，将函数的计算结果输出到通道，再返回另一个函数作为生成器，用于将通道中的内容输出。需要生成器结果时调用函数即可。</p>
<h2 id="限制同时处理的请求数">限制同时处理的请求数</h2>
<p>使用带缓冲区的通道可以很容易地实现，其缓冲区容量就是同时处理请求的最大数量。</p>
<p>下述示例当信号通道表示缓冲区已满时，handle()
函数会阻塞且不再处理其他请求。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">package main

const MAXREQS &#x3D; 50

var sem &#x3D; make(chan int, MAXREQS)

func process(r *Request) &#123;
    &#x2F;&#x2F; do something
&#125;

func handle(r *Request) &#123;
    sem &lt;- 1 &#x2F;&#x2F; doesn&#39;t matter what we put in it
    process(r)
    &lt;-sem &#x2F;&#x2F; one empty place in the buffer: the next request can start
&#125;</code></pre>
<h2 id="链式协程">链式协程</h2>
<p>这样的通道表达式也是可行的：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func f(left, right chan int) &#123; left &lt;- 1 + &lt;-right &#125;</code></pre>
<h2 id="在多核心上并行计算">在多核心上并行计算</h2>
<p>如果需要把计算量分配到每一个处理器上，让每一部分与其他部分并行，可以先用带缓冲区的通道，在每一个计算部分完成后发送信号；同时还要通过runtime.GOMAXPROCS(N)限定使用的处理器个数。</p>
<h2 id="使用通道并发访问对象">使用通道并发访问对象</h2>
<p>可以使用协程在后台顺序执行匿名函数来替代使用同步互斥锁。比如在构造函数中启动一个后台协程，然后把对象的读写都实现为匿名函数，让其按顺序处理，有效地将它们序列化从而提供了安全的并发访问。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 构造时开启协程
func NewPerson(name string, salary float64) *Person &#123;
    p :&#x3D; &amp;Person&#123;name, salary, make(chan func())&#125;
    go p.backend()
    return p
&#125;

func (p *Person) backend() &#123;
    for f :&#x3D; range p.chF &#123;
        f()
    &#125;
&#125;

&#x2F;&#x2F; 读写func()
&#x2F;&#x2F; Set salary.
func (p *Person) SetSalary(sal float64) &#123;
    p.chF &lt;- func() &#123; p.salary &#x3D; sal &#125;
&#125;

&#x2F;&#x2F; Retrieve salary.
func (p *Person) Salary() float64 &#123;
    fChan :&#x3D; make(chan float64)
    p.chF &lt;- func() &#123; fChan &lt;- p.salary &#125;
    return &lt;-fChan
&#125;</code></pre>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script src="/js/lg-thumbnail.min.js"></script><script src="/js/lg-zoom.min.js"></script><script src="/js/lg-fullscreen.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>《The Way to Go》阅读笔记</title>
    <url>/p/e842888b11eb/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="chapter1">Chapter1</h1>
<h3 id="go语言的发展目标">go语言的发展目标</h3>
<p>结合静态语言的安全性和高效性，动态语言的易开发性。</p>
<p>注意，go是<strong>静态语言（静态类型语言）</strong>。是类型安全和内存安全的编程语言。通过goroutine来实现并发并行编程，通过channel来实现gorountine之间通信。</p>
<p>像其他静态语言一样执行本地代码，但依旧运行某种意义上的虚拟机进行垃圾回收，不需要开发人员考虑内存管理的问题。</p>
<h3 id="语言的特性">语言的特性</h3>
<p>没有类和继承概念，使用接口（interface）来实现多态性，函数是基本构件</p>
<p>使用静态类型，强类型语言，隐式的类型转换不被允许</p>
<span id="more"></span>
<h1 id="chapter2">Chapter2</h1>
<h2 id="平台与架构">平台与架构</h2>
<p>Go语言有两个版本编译器：Go原生编译器gc和非原生编译器gccgo，Go语言的编译器和链接器都是C语言编写并产生本地代码</p>
<p>Go的<strong>自举</strong>：在 1.4 版本后，Go 编译器实现了自举，即通过
1.4 版本来编译安装之后版本的编译器。</p>
<a href="/p/e842888b11eb/Untitled.png" class="gallery-item"><img src="/p/e842888b11eb/Untitled.png" class="" title="在自己的服务器上编译Go"></a>
<h2 id="go环境变量">Go环境变量</h2>
<ul>
<li>$GOROOT：Go在电脑上的安装位置，一般是$Home/go（注意不要配置成bin目录了，bin目录是添加到path让你方便执行go.exe的…）</li>
<li>$GOPATH：此路径下必须包含src / pkg /
bin三个目录存放源码，包文件和可执行文件</li>
<li>$GOMAXPROCS：用于设置应用程序可使用的处理器个数与核数</li>
</ul>
<h3 id="go-运行时runtime">Go 运行时（runtime）</h3>
<ul>
<li>尽管Go编译器产生的是本地可执行代码，但仍然运行在Go的runtime中，这个runtime負責管理包括内存分配、垃圾回收、栈处理、goroutine、channel、切片、map和反射。Go的runtime嵌入到每一个可执行文件当中，所以可执行文件会比相应的源文件大得多。</li>
</ul>
<h1 id="chapter4">Chapter4</h1>
<h2 id="go程序基本结构和要素">Go程序基本结构和要素</h2>
<p>每个程序都由包（通常简称为
pkg）的概念组成，可以使用自身的包或者从其它包中导入内容。每个Go文件都属于且仅属于一个包，一个包可以由许多.go源文件组成，文件名和包名一般都是不同的。</p>
<p>如果要编译包名不是为main的源文件如pack1，编译后产生的对象文件将会是pack1.a而不是可执行程序。</p>
<p>所有包名应该使用小写字母。</p>
<p>Go标准库位于Go根目录下的子目录pkg，以64位windows为例，标准库位于windows_amd64下。</p>
<a href="/p/e842888b11eb/Untitled_1.png" class="gallery-item"><img src="/p/e842888b11eb/Untitled_1.png" class="" title="windows_amd64目录"></a>
<p><strong>包的导入和搜索</strong></p>
<p>如果包名不是以 <code>.</code>或 <code>/</code>开头，如 <code>"fmt"</code>或者 <code>"container/list"</code>，则
Go 会在全局文件进行查找；如果包名以 <code>./</code>开头，则 Go
会在相对目录中查找；如果包名以 <code>/</code>开头（在 Windows
下也可以这样使用），则会在系统的绝对路径中查找。</p>
<p><strong>可见性规则</strong></p>
<p>包通过这个强制执行的规则决定自身代码是否暴露给外部文件：如果标识符（包括常量、变量、类型、函数名、结构字段等等）以大写字母开头，那么可以被外部包使用，如果以小写字母开头，就对包外不可见，仅在包内可见并且可用。</p>
<p>只有当某个函数需要被外部包调用的时候才使用大写字母开头，并遵循 Pascal
命名法；否则就遵循骆驼命名法，即第一个单词的首字母小写，其余单词的首字母大写。</p>
<h3 id="函数">函数</h3>
<p>每一个可执行程序必须包含main()，是除init()外启动后第一个执行的函数。如果main包的没有包含main函数会引发build
error。main没有参数也没有返回类型。</p>
<p>对相同类型的函数参数，可以这样描述函数</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func Add(param1, param2 int) int &#123;
    &#x2F;&#x2F; ...
&#125;</code></pre>
<h3 id="类型">类型</h3>
<p>使用 var
声明的变量的值会<strong>自动初始化为该类型的零值</strong>。</p>
<p>类型定义了某个变量的值的集合与可对其进行操作的集合。</p>
<p>类型可以是基本类型，如：int、float、bool、string；结构化的（复合的），如：struct、array、slice、map、channel；只描述类型的行为的，如：interface。</p>
<p>结构化的类型没有真正的值，它使用 nil 作为默认值（在 Objective-C 中是
nil，在 Java 中是 null，在 C 和 C++ 中是NULL或 0）。值得注意的是，Go
语言中不存在类型继承。</p>
<h2 id="常量">常量</h2>
<p>常量值必须在编译时能够确定，同时无法在运行过程修改它的值</p>
<h2 id="变量">变量</h2>
<p>使用关键词<code>var</code>来声明一个变量</p>
<p>在<strong>包级别</strong>声明变量</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var a int &#x3D; 5 &#x2F;&#x2F; 显式声明类型
var b &#x3D; 5 &#x2F;&#x2F; 隐式声明类型</code></pre>
<p>在<strong>函数内部</strong>的简短形式，省略var</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func Sample() &#123;
    a :&#x3D; 5
&#125;</code></pre>
<p>交换变量，不用写tmp了</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">a, b &#x3D; b, a</code></pre>
<h3 id="值类型与引用类型">值类型与引用类型</h3>
<p>基本数值类型，字符串，数组，结构都是值类型，内容直接存放在变量分配得的内存上</p>
<p>更复杂的类型（？）使用引用类型保存，变量分配得的内存上，存放“内容所在的地址”</p>
<h3 id="格式字符串">格式字符串</h3>
<p>用来记录一些输出类型（格式化说明符）</p>
<ul>
<li>%v 通用</li>
<li>%t 布尔型</li>
<li>%d 格式化整数（%x和%X用于格式化16进制</li>
<li>%g 格式化浮点型（%f输出浮点数，%e输出科学计数法</li>
<li>%p 显示地址格式</li>
</ul>
<h3 id="init函数">init函数</h3>
<p>不能被人为调用，在包完成初始化（变量全局声明初始化）后自动执行，可以作为另一种初始化途径</p>
<p>初始化以单线程执行，且按照包的依赖关系执行，另一种用途可以在开始执行程序前对数据进行检验修复</p>
<h2 id="基本类型与运算符">基本类型与运算符</h2>
<p>注意go没有隐式类型转换，在类型转换是要注意用显式的方式进行</p>
<h3 id="数字类型">数字类型</h3>
<p>Go 也有基于架构的类型，例如：int、uint 和
uintptr。这些类型的长度都是<strong>根据运行程序所在的操作系统类型所决定</strong>的：</p>
<ul>
<li><code>int</code> 和 <code>uint</code> 在 32 位操作系统上，它们均使用
32 位（4 个字节），在 64 位操作系统上，它们均使用 64 位（8
个字节）。</li>
<li><code>uintptr</code> 的长度被设定为足够存放一个指针即可。</li>
</ul>
<p>Go 语言中没有 float 类型。（Go语言中只有 float32 和
float64）没有double类型。</p>
<p>float32 精确到小数点后 7 位，float64 精确到小数点后 15
位。由于精确度的缘故，你在使用 <code>==</code>
 或者 <code>!=</code>来比较浮点数时应当非常小心。</p>
<h3 id="算术运算符">算术运算符</h3>
<ul>
<li>相对于一般规则而言，Go
在进行字符串拼接时允许使用对运算符 <code>+</code> 的重载，但 Go
本身不允许开发者进行自定义的运算符重载</li>
<li><code>/</code> 对于整数运算而言，结果依旧为整数，例如：<code>9 / 4 -&gt; 2</code>。取余运算符只能作用于整数：<code>9 % 4 -&gt; 1</code>。</li>
<li>你可以将语句 <code>b = b + a</code> 简写为 <code>b += a</code></li>
<li>带有 <code>++</code>和 <code>--</code> 的<strong>只能作为语句，而非表达式</strong>，因此 <code>n = i++</code> 这种写法是无效的，</li>
</ul>
<h3 id="类型别名">类型别名</h3>
<p>给某个类型起另一个名字，新类型不会拥有原类型附带方法，新类型也可自定义方法</p>
<h3 id="字符类型">字符类型</h3>
<p><code>byte</code>类型是 <code>uint8</code> 的别名，对于只占用 1
个字节的传统 ASCII 编码的字符来说</p>
<p><code>\x</code>总是紧跟着长度为 2 的 16 进制数</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var ch byte &#x3D; 65 或 var ch byte &#x3D; &#39;\x41&#39; &#x2F;&#x2F; one byte</code></pre>
<p>Go 同样支持 Unicode（UTF-8），因此字符同样称为 Unicode 代码点或者
runes，并在内存中使用 int 来表示。在书写 Unicode 字符时，需要在 16
进制数之前加上前缀 <code>\u</code> 或者 <code>\U</code>。</p>
<p>因为 Unicode 至少占用 2
个字节，所以我们使用 <code>int16</code> 或者 <code>int</code> 类型来表示。如果需要使用到
4
字节，则会加上 <code>\U</code> 前缀；前缀 <code>\u</code> 则总是紧跟着长度为
4 的 16 进制数，前缀 <code>\U</code> 紧跟着长度为 8 的 16 进制数。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var ch int &#x3D; &#39;\u0041&#39; &#x2F;&#x2F; two bytes
var ch2 int &#x3D; &#39;\u03B2&#39;
var ch3 int &#x3D; &#39;\U00101234&#39; &#x2F;&#x2F; four bytes</code></pre>
<p>包<code>unicode</code>包含的测试字符函数</p>
<ul>
<li>判断是否为字母：<code>unicode.IsLetter(ch)</code></li>
<li>判断是否为数字：<code>unicode.IsDigit(ch)</code></li>
<li>判断是否为空白符号：<code>unicode.IsSpace(ch)</code></li>
</ul>
<h2 id="字符串">字符串</h2>
<p>字符串是UTF-8字符的序列，所以字符串内的字符可能根据需要占用1至4字节，与其他语言不同，好处是减少内存、硬盘空间占用，也不需要进行文本编码解码。</p>
<p>双引号内的转义符照常处理；反引号内的会解释为字符串，会将转义符原样输出</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#96;This is a raw string \n&#96; 中的 &#96;\n\&#96; 会被原样输出。</code></pre>
<ul>
<li>可以进行索引，但索引到的是字节</li>
<li>根据长度限定，而不是特殊字符’\0’</li>
<li>是一种<strong>值类型</strong>，内容不可变，是字节的定长数组</li>
</ul>
<p>字符串与[]byte的转换</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 逆转！
func ReverseString(input string) string &#123;
    c :&#x3D; []byte(input)
    for i :&#x3D; 0; i &lt; len(c)&#x2F;2; i++ &#123;
        other :&#x3D; len(c) - i - 1
        c[i], c[other] &#x3D; c[other], c[i]
    &#125;

    return string(c)
&#125;</code></pre>
<h1 id="chapter5">Chapter5</h1>
<h2 id="if-else-结构">if-else 结构</h2>
<p>特点：条件不需要圆括号，但是语句需要大括号</p>
<p>可以使用初始化语句，在if语句的作用域中声明一个变量，需要在声明语句后面跟上一个分号</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">if val :&#x3D; 10; val &gt; max &#123;
    &#x2F;&#x2F; do something
&#125;</code></pre>
<h2 id="测试多返回值函数的错误">测试多返回值函数的错误</h2>
<p>Go语言函数经常使用两个返回值来表示执行是否成功，通常返回零值、nil、false来表示失败，或者使用一个error类型的变量来代替作为第二个返回值；成功执行的话，error值为nil。</p>
<p>如果判断函数执行一定能成功，可以使用<code>_</code>来接收第二个参数。</p>
<p>有时当错误没有发生时，继续运行就是唯一要做的事情，所以if语句块后面不需要使用else分支（卫语句）</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">value, err :&#x3D; pack1.Function1(param1)
if err !&#x3D; nil &#123;
    fmt.Printf(&quot;An error occured in pack1.Function1 with parameter %v&quot;, param1)
    return err
&#125;
&#x2F;&#x2F; 未发生错误，继续执行：</code></pre>
<h2 id="switch-语句">switch 语句</h2>
<p>与其他语言switch语句的不同之处：</p>
<ol type="1">
<li><p>可以同时测试多个符合条件的值：case val1, val2, val3</p></li>
<li><p>匹配某个分支后，会退出整个switch语句，所以不需要特别使用break来结束</p></li>
<li><p>如果想要执行后续分支的代码，可以使用<code>fallthrough</code>关键字</p></li>
<li><p>switch语句也可以不提供任何被判断的值，然后在每个case分支中进行不同条件的测试，可用于替代测试条件非常多的<code>if-else</code>语句</p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">switch &#123;
    case i &lt; 0:
        f1()
    case i &#x3D;&#x3D; 0:
        f2()
    case i &gt; 0:
        f3()
&#125;</code></pre></p></li>
<li><p>同样的类似if-else结构，也可以在switch后跟上一个初始化语句</p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">switch result :&#x3D; calculate(); &#123;
    case result &lt; 0:
        ...
    case result &gt; 0:
        ...
    default:
        &#x2F;&#x2F; 0
&#125;</code></pre></p></li>
<li></li>
</ol>
<h2 id="for-结构">for 结构</h2>
<ol type="1">
<li>常见的for结构与其他语言一致 for A; B; C { }</li>
<li>没有while结构，存在根据条件判断进行的 for condition {}</li>
<li>无限循环结构形如，for {}</li>
<li>形如foreach的结构，使用<strong>range</strong>关键字，for pos, value
<strong>range</strong> array {}
注意value为集合中对应索引的<strong>值拷贝</strong>，因此它一般只具有只读性质（如果value为指针，则会产生指针的拷贝，依旧可以修改集合中的原值）写操作并不生效</li>
<li>（5.5-5.6） break, continue, goto 没有什么不同</li>
</ol>
<h1 id="chapter6">Chapter6</h1>
<h2 id="函数-介绍">函数-介绍</h2>
<ol type="1">
<li>go中不支持函数重载（函数重载需要多余的类型匹配，影响性能），同名函数将会导致编译报错</li>
<li>函数是一等公民（first-class value），可以赋值给变量</li>
<li>go没有泛型的概念，在注重性能的场合最好为每一个类型单独创建一个函数，使代码可读性更强</li>
</ol>
<h2 id="函数参数与返回值">函数参数与返回值</h2>
<ol type="1">
<li><p>go默认使用按值传递来传递参数，也就是传递参数的副本</p></li>
<li><p>如果希望直接修改参数的值，可以传递参数的地址（&amp;variable），相当于传递一个指针，可以通过这个指针来修改指向地址上的值。</p></li>
<li><p>注意指针也是变量，指针变量的值是另一个变量的地址，所以传递指针也是按值传递。当函数内改变一个占用内存较大的变量时，传递指针不需要赋值变量的值，性能优势就更加明显了。</p></li>
<li><p>使用多重返回值：可以使用命名返回值，或者非命名返回值；<strong>尽量使用命名返回值，使代码更容易读懂</strong></p></li>
<li><p>使用命名返回值时，可以为返回值变量赋值后return，也可以return对应的返回值变量，但以返回的明确值为准</p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func GetX2AndX3_2(input int) (x2 int, x3 int) &#123; &#x2F;&#x2F; 假设输入为10
    x2 &#x3D; input * 2
    x3 &#x3D; input * 3
    &#x2F;&#x2F;return &#x2F;&#x2F; 返回 20，30
    &#x2F;&#x2F;return x2, x3 &#x2F;&#x2F; 同样返回 20，30
    return input, input &#x2F;&#x2F; 返回10，10，x2和x3也被赋值为10
&#125;</code></pre></p></li>
</ol>
<h2 id="传递变长参数">传递变长参数</h2>
<ol type="1">
<li><p>如果函数最后一个参数采用...type的形式，这个函数就可以处理一个变长参数，接收一个类似于切片（slice）的参数，如下，变量 <code>who</code>的值为 <code>[]string&#123;"Joe", "Anna", "Eileen"&#125;</code></p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func Greeting(prefix string, who ...string)
Greeting(&quot;hello:&quot;, &quot;Joe&quot;, &quot;Anna&quot;, &quot;Eileen&quot;)</code></pre></p></li>
<li><p>如果参数存储在slice类型变量<code>slice</code>中，可以通过<code>slice...</code>的形式来传递参数，调用变参函数</p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">slice :&#x3D; []int&#123;7,9,3,5,1&#125;
x &#x3D; min(slice...)</code></pre></p></li>
</ol>
<h2 id="defer-和追踪">defer 和追踪</h2>
<ol type="1">
<li>关键字<code>defer</code>允许将某个语句或函数的执行推迟到函数返回之前（或者说任意位置的<code>return</code>语句之后），类似C#与Java中的finally语句块</li>
<li>注意如果<code>defer</code>的函数a中的某个参数使用了函数b的调用结果，函数b会马上执行而不会等到函数返回前才执行，见<a
href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/examples/chapter_6/defer_tracing2.go">示例
6.11</a></li>
</ol>
<h2 id="将函数作为参数">将函数作为参数</h2>
<p>函数可以作为其他函数的参数进行传递，函数参数的格式如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; strings.IndexFunc
func IndexFunc(s string, f func(c rune) bool) int
&#x2F;&#x2F; 函数返回值是字符串s中第一个使f(c)返回true的unicode字符</code></pre>
<h2 id="闭包">闭包</h2>
<ol type="1">
<li><p>使用匿名函数，例<code>func(x, y int) int &#123; return x+ y &#125;</code>
除了没有名字和声明一个函数是一样的</p></li>
<li><p>这样的一个匿名函数不能独立存在，需要将它赋值于某个变量，再通过这个变量名进行调用；或者直接对这个匿名函数进行调用</p></li>
<li><p>对下述例子中的函数变量，变量代表的是<code>func(int)</code>，变量的值是一个内存地址</p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">    for i :&#x3D; 0; i &lt; 4; i++ &#123;
        g :&#x3D; func(i int) &#123; fmt.Printf(&quot;%d &quot;, i) &#125;
        g(i)
        fmt.Printf(&quot; - g is of type %T and has value %v\n&quot;, g, g)
    &#125;

&#x2F;&#x2F; -- output
0 - g is of type func(int) and has value 0x681a80
1 - g is of type func(int) and has value 0x681b00
2 - g is of type func(int) and has value 0x681ac0
3 - g is of type func(int) and has value 0x681400</code></pre></p></li>
<li><p>闭包：匿名函数被允许去捕捉一些外部状态，例如函数被创建时的状态；又或者说闭包继承了函数声明时的作用域。作用域内的变量被共享到闭包的环境中，可以在闭包中被操作，直到闭包销毁。</p></li>
</ol>
<h2 id="使用闭包调试">使用闭包调试</h2>
<p>使用runtime包中的runtime.Caller来打印当前的执行文件与执行行数</p>
<h1 id="chapter7">Chapter7</h1>
<h2 id="数组与切片-声明和初始化">数组与切片 声明和初始化</h2>
<p>数组：具有相同唯一类型的长度固定的数据项序列，数组长度必须是常量表达式，编译时需要知道数组长度以便分配内存。</p>
<p>数组的声明方式（值类型，声明和初始化可以同时发生）：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var identifier [len]type
&#x2F;&#x2F; 举例一个数组的初始化
func main() &#123;
    var arr1 [5]int &#x2F;&#x2F; 初始化为全0

    for i:&#x3D;0; i &lt; len(arr1); i++ &#123;
        arr1[i] &#x3D; i * 2
    &#125;

    for i:&#x3D;0; i &lt; len(arr1); i++ &#123;
        fmt.Printf(&quot;Array at index %d is %d\n&quot;, i, arr1[i])
    &#125;
&#125;</code></pre>
<p>注意，Go语言中的数组是<strong>值类型</strong>，不像C/C++中是指向首元素的指针，所以把一个数组赋值给另一个时，或者将数组作为参数传入时，都会产生<strong>数组拷贝</strong>。</p>
<p>将一个大数组传递给函数会消耗很多内存，通过传递数组的指针，或者使用数组的<strong>切片</strong>来避免这种情况。</p>
<h3 id="数组常量">数组常量</h3>
<p>如果数组内容已经提前知道，那么可以用数组常量来初始化而不用依次赋值</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var arrAge &#x3D; [5]int&#123;18, 20, 15, 22, 16&#125;
var arrKeyValue &#x3D; [5]string&#123;3: &quot;Chris&quot;, 4: &quot;Ron&quot;&#125; &#x2F;&#x2F; 只有索引3和4被赋予实际的指，其他元素都被设置为空的字符串</code></pre>
<h2 id="切片">切片</h2>
<p>切片（slice）是对数组一个连续片段的引用：</p>
<ol type="1">
<li><p>切片的长度可以在运行时修改，是一个长度可变的数组</p></li>
<li><p>切片提供计算容量的函数<code>cap()</code>，对切片<code>s</code>，<code>cap(s)</code>就是从<code>s[0]</code>到切片来源数组<strong>末尾</strong>的长度，对切片s永远成立：<code>0≤len(s)≤cap(s)</code></p></li>
<li><p>表示同一个数组片段的多个切片之间共享数据，因为是引用，所以不需要使用额外内存</p></li>
<li><p>声明切片以及初始化切片的方式：</p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">var identifier []type &#x2F;&#x2F; 声明，未初始化时为nil
var slice1 []type &#x3D; arr1[start:end] &#x2F;&#x2F; 初始化，不包含末尾索引，左闭右开
var slice2 []type &#x3D; arr1[:] &#x2F;&#x2F; 初始化，包含数组内的所有元素
s :&#x3D; [3]int&#123;1,2,3&#125;[:] &#x2F;&#x2F; （等价于先用 s :&#x3D; [3]int&#123;1, 2, 3&#125; 生成数组, 再使用 s[:] 转成切片）
s :&#x3D; []int&#123;1,2,3&#125; &#x2F;&#x2F; 甚至更精简的形式，类似数组的初始化方式

type intSlice []int &#x2F;&#x2F; 使用type alias，初始化更简单了
s :&#x3D; intSlice&#123;1,2,3&#125; &#x2F;&#x2F; 是 s :&#x3D; intSlice([]int&#123;1,2,3&#125;) 的精简形式</code></pre></p></li>
<li><p>对切片的大小进行操作，切片只能向后移动，向前移动（s2 = s2[-1:]）
会导致编译错误：</p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">slice1 &#x3D; slice1[:len(slice1)-1] &#x2F;&#x2F; 去掉最后一个元素
slice1 &#x3D; slice1[:cap(slice1)] &#x2F;&#x2F; 扩大到大小上限
s2 &#x3D; s2[1:] &#x2F;&#x2F; 可以将 s2 向后移动一位，但是末尾没有移动</code></pre></p></li>
<li><p><strong>不要用指针指向切片</strong>，切片本身就是一个指针，已经是引用类型</p></li>
<li><p>当数组没有定义时，使用make来初始化/创建一个切片（当然同时也创建了相关数组）</p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">var slice1 []type &#x3D; make([]type, len) &#x2F;&#x2F; len 为切片长度
slice1 :&#x3D; make([]type, len) &#x2F;&#x2F; 精简形式
slice1 :&#x3D; make([]type, len, cap) &#x2F;&#x2F; 精简形式, 接收cap为切片容器大小</code></pre></p></li>
<li><p><strong>new</strong>和<strong>make</strong>的区别：</p>
<ol type="1">
<li><code>new(T)</code>为类型T分配一片内存，初始化为0并返回类型*T指针，不会做额外的初始化操作（所以内建类型需要<code>make</code>），适用于值类型如<strong>数组</strong>和<strong>结构体</strong></li>
<li><code>make(T)</code>返回类型T的初始值，只适用于内建引用类型：<code>slice</code>、<code>map</code>与<code>channe</code>，三者在内存中有多个组成部分，需要对内存中的组成部分初始化才能使用，make就是对三者进行初始化的一种操作方式</li>
<li>试图<code>make()</code>一个结构体变量会引发编译错误，还不算太糟糕，但<code>new</code>一个<code>map</code>并试图向其填充数据，将会引发运行时错误，因为<code>new(map)</code>返回的是<code>nil</code>指针，它尚未被分配内存</li>
</ol></li>
</ol>
<h3 id="bytes包">bytes包</h3>
<p>类似java / C#
中的StringBuilder类，通过声明bytes.Buffer对象，或者new一个出来，或者通过函数<code>func NewBuffer(buf []byte) *Buffer</code>，创建一个 <code>Buffer</code>对象并且用 <code>buf</code>初始化好</p>
<h2 id="for-range-结构">for-range 结构</h2>
<ol type="1">
<li><p>在for-range结构中使用_来忽略索引 / 变量</p></li>
<li><p>如果只需要索引，可以直接忽略第二个变量</p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">seasons :&#x3D; []string&#123;&quot;Spring&quot;, &quot;Summer&quot;, &quot;Autumn&quot;, &quot;Winter&quot;&#125;
for _, season &#x3D; range seasons &#123;
        fmt.Printf(&quot;%s\n&quot;, season)
&#125;

for ix :&#x3D; range seasons &#123;
    fmt.Printf(&quot;%d&quot;, ix)
&#125;</code></pre></p></li>
</ol>
<h2 id="切片重组reslice">切片重组（reslice）</h2>
<h2 id="切片复制与追加">切片复制与追加</h2>
<ol type="1">
<li>使用<code>copy(to []T, from []T)</code>来将from切片中的内容拷贝到to切片中，覆盖to现有的元素，函数返回赋值的个数</li>
<li>使用<code>append(s []T, x ...T)</code>来将多个相同类型元素（如果需要追加切片，将第二个参数拓展成参数列表<code>x = append(x, y...)</code>）追加到切片后，并返回新的切片。如果原切片容量不足，会分配新的数组给切片，所以新的切片<strong>可能</strong>不再指向同一个数组。</li>
<li>由2可以得到，如果将切片作为函数参数传入，在函数内部对切片进行了扩容，最好再将切片作为返回值传出，才能在函数外部得到扩容后的切片</li>
</ol>
<h2 id="字符串数组和切片的应用">字符串、数组和切片的应用</h2>
<ol type="1">
<li>使用<code>substr := str[start:end]</code>
来获取从索引start到end-1的子字符串</li>
<li>关于切片的操作，可以参考<a
href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/07.6.md#767-append-%E5%87%BD%E6%95%B0%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C">7.6.7
append() 函数常见操作</a></li>
<li>切片底层指向一个数组，只有不被任何切片指向的时候，数组的内存才会被释放，所以注意切片指向的数组，在必要时，以部分内容新建一个切片</li>
<li>使用<code>c := byte[](str)</code>来将字符串转化为字符切片，从而修改字符串内容，字符串内容无法被直接索引修改（放在等号左边）</li>
</ol>
<h1 id="chapter8">Chapter8</h1>
<h2 id="map-的声明初始化和make">Map 的声明、初始化和make</h2>
<ol type="1">
<li><p>自然的，map是引用类型</p></li>
<li><p>map的声明格式如下，不需要长度，因为大小可以动态增长</p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">var map1 map[keytype]valuetype
var map1 map[string]int</code></pre></p></li>
<li><p>key需要时可以用操作符比较的类型，value可以是任何类型</p></li>
<li><p>map可以用 <code>map[keyType]valueType&#123;key1: val1, key2: val2&#125;</code>的描述方法来初始化，就像数组和结构体一样</p></li>
<li><p>引用类型的map使用<code>make</code>进行初始化</p></li>
<li><p>使用<code>make</code>初始化map时可以标明初始容量，当增长到容量上限时，map大小会自动+1</p></li>
<li><p>将value定义成<code>[]int</code>类型或者其他类型的切片，来解决一个value对应多个值的问题</p></li>
</ol>
<h2 id="键值对检查元素删除">键值对检查，元素删除</h2>
<ol type="1">
<li>可以使用 <code>val1 = map1[key1]</code>的方法获取 <code>key1</code> 对应的值 <code>val1</code>。如果 <code>map</code>中不存在 <code>key1</code>，<code>val1</code>就是一个值类型的空值。</li>
<li>如何区分key1不存在还是对应value是空值？可以使用<code>val1, isPresent = map1[key1]</code>，当key存在于map中时，<code>isPresent</code>会返回true</li>
</ol>
<h2 id="for-range-配套用法遍历map">for-range 配套用法（遍历map）</h2>
<ol type="1">
<li>和前面类似的，如果只关心值不关心key，可以<code>_,value := range map</code>
，反之如果只关心key不关心值，可以 <code>key := range map</code></li>
<li>注意，map的本质是散列表，map的增长扩容会导致重新散列，同时Go设计者也让每次遍历的起点不一样，所以遍历map总是无序的，为了让我们不依赖map的遍历排序中的顺序</li>
<li>如果想要获得<code>map</code>类型的切片，就需要使用两次<code>make()</code>函数，第一次用于分配切片，第二次用于分配切片中的每个<code>map</code>元素；注意，当你使用<code>range</code>来遍历分配时，获得的只是map值的拷贝，所以并不能真正进行<code>map</code>元素的初始化</li>
</ol>
<h2 id="map的排序">map的排序</h2>
<ol type="1">
<li>由于<code>map</code>的无序性，当需要为<code>map</code>排序时，考虑将key或value拷贝到切片中，对切片进行排序，再对切片使用<code>for-range</code>，打印出所有key-value</li>
</ol>
<h1 id="chapter9">Chapter9</h1>
<h2 id="标准库概述">标准库概述</h2>
<p>简单记录一下，感觉用得上的</p>
<ol type="1">
<li>io：基本输入输出</li>
<li>bufio：缓冲输入输出</li>
<li>path/filepath：系统目标文件名目录</li>
<li>strings：字符串操作</li>
<li>strconv：字符串转换为基础类型</li>
<li>regexp：正则表达式</li>
<li>bytes：字符型分片</li>
<li>math：数学函数</li>
<li>math/rand：伪随机数生成</li>
<li>sort：数组排序和自定义集合</li>
<li>encoding/json：编码解码json数据</li>
<li>runtime：Go程序运行时交互，垃圾回收/协程创建</li>
<li>reflect：运行时反射</li>
</ol>
<h2 id="锁与sync包">锁与sync包</h2>
<ol type="1">
<li><p><code>sync.Mutex</code>是一个互斥锁，守护在临界区入口保证同一时间只能有一个线程进入临界区</p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Info struct &#123;
    mu sync.Mutex
    &#x2F;&#x2F; ... other fields, e.g.: Str string
&#125;

&#x2F;&#x2F; example
info.mu.Lock()
&#x2F;&#x2F; 临界区修改
info.mu.Unlock()</code></pre></p></li>
<li><p><code>sync.RWMutex</code>锁，能通过<code>RLock()</code>来允许同一时间多个线程对变量进行读操作，但只有一个现成能进行写操作</p></li>
</ol>
<h2 id="精密计算与big包">精密计算与big包</h2>
<p>对于整数的高精度计算，提供了 <code>big</code>包，被包含在 <code>math</code>包下：有用来表示大整数的 <code>big.Int</code>
和表示大有理数的 <code>big.Rat</code>类型</p>
<h2 id="自定义包与可见性">自定义包与可见性</h2>
<ol type="1">
<li><p>import
的一般格式：<code>import “包的路径或URL地址”</code>，非自定义本地包一般存放在$GOROOT/src（官方包）下或​$GOPATH/src（第三方包）下</p></li>
<li><p><strong>（module
mode）</strong>用相对路径（”./”）import自定义包在module
mode下不支持，可以使用从module名（在go.mod中定义）开始相对路径的方式进行import</p>
<p></p>
<p><a href="/p/e842888b11eb/Untitled_3.png" class="gallery-item"><img src="/p/e842888b11eb/Untitled_3.png" class="" title="这里在IDE中enable-go-modules-integration后的状态"></a></p>
<p>这里是enable go modules integration状态</p></li>
<li><p><strong>（module mode）</strong>如果需要用go install / go get
来下载package，需要打开module mode</p>
<p><a href="/p/e842888b11eb/Untitled_4.png" class="gallery-item"><img src="/p/e842888b11eb/Untitled_4.png" class="" title="提示当前modules被关闭"></a></p></li>
<li><p><strong>（module mode）</strong>通过go env 来查看是否打开了GO
MODULE MODE</p>
<p><a href="/p/e842888b11eb/Untitled_5.png" class="gallery-item"><img src="/p/e842888b11eb/Untitled_5.png" class="" title="go env输出结果"></a></p></li>
<li><p><strong>（module mode）</strong>通过go install / go
get下载的package，会被下载到$GOPATH的pkg目录下</p></li>
<li><p><strong>（module
mode）</strong>要使用下载的package，需要编辑项目的go.mod（是不是IDE帮我自动编辑了我不是很清楚）</p>
<p><a href="/p/e842888b11eb/Untitled_6.png" class="gallery-item"><img src="/p/e842888b11eb/Untitled_6.png" class="" title="go.mod文件内容"></a></p></li>
<li><p>使用<code>import [name] “path”</code>，来给import的包起一个别名，使用<code>import _ “path”</code>，来忽略这个包，仅通过import执行package的init方法</p></li>
</ol>
<h1 id="chapter10">Chapter10</h1>
<h2 id="结构与方法">结构与方法</h2>
<ol type="1">
<li>Go通过类型别名和结构体的形式支持用户自定义类型</li>
<li>结构体也是<strong>值类型</strong>，所以通过<code>new()</code>函数来创建</li>
<li>Go语言中没有类的概念，因此结构体有着更为重要的地位</li>
</ol>
<h2 id="结构体定义">结构体定义</h2>
<ol type="1">
<li><p>结构体的定义方式：</p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type identifier struct &#123;
    field1 type1
    field2 type2
&#125;</code></pre></p></li>
<li><p>声明结构体变量的方式</p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">var t *T
t &#x3D; new(T) &#x2F;&#x2F; 使用new()，t的类型是*T

var s T
T.a &#x3D; 5 &#x2F;&#x2F; 直接声明结构体变量，t的类型是T

&#x2F;&#x2F;结构体字面量：struct-literal
ms :&#x3D; struct1&#123;10, 15.5, &quot;Chris&quot;&#125; &#x2F;&#x2F;必须按照字段顺序写，ms的类型是struct1
ms :&#x3D; &amp;struct1&#123;10, 15.5, &quot;Chris&quot;&#125; &#x2F;&#x2F; 同上，ms的类型是*struct1
intr :&#x3D; Interval&#123;end:5, start:1&#125; &#x2F;&#x2F; 可以不按照字段顺序，可以不给每一个字段赋值
r1 :&#x3D; Rect1&#123;Point&#123;10, 20&#125;, Point&#123;50, 60&#125;&#125; &#x2F;&#x2F; 嵌套</code></pre></p></li>
<li><p>对于一个结构体类型和一个结构体类型指针，都可以用相同的<strong>选择器符（selector-notation）</strong>，即<code>.</code>符号来引用结构体的字段</p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type myStruct struct &#123; i int &#125;
var v myStruct    &#x2F;&#x2F; v 是结构体类型变量
var p *myStruct   &#x2F;&#x2F; p 是指向一个结构体类型变量的指针
v.i
p.i &#x2F;&#x2F; 这里会报错，因为p指针为nil</code></pre></p></li>
<li><p>当为结构体定义了一个<code>alias</code>类型时，结构体和它的<code>alias</code>类型具有相同的底层类型，可以互相转换</p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type number struct &#123;
    f float32
&#125;

type nr number   &#x2F;&#x2F; alias type</code></pre></p></li>
<li><p>使用 <code>fmt.Println()</code>打印一个结构体的默认输出可以很好的显示它的内容，类似使用 <code>%v</code>选项。使用<code>%+v</code>选项会先输出字段名字再输出字段的值，使用<code>%#v</code>字段会在前者基础上先输出结构体的名字</p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">The name of person is &#123;EDWARD CHEN&#125;
The name of person is &amp;&#123;firstName:EDWARD lastName:CHEN&#125;
The name of person is chapter10.Person&#123;firstName:&quot;EDWARD&quot;, lastName:&quot;CHEN&quot;&#125;</code></pre></p></li>
<li><p><code>fmt.Printf</code> / <code>fmt.Print</code> /
<code>fmt.Println</code> 均会自动使用结构体的String
方法，通过给出结构体为接收者的String方法来进行自定义</p></li>
</ol>
<h2 id="使用工厂方法创建结构体实例">使用工厂方法创建结构体实例</h2>
<ol type="1">
<li>Go语言不支持面向对象编程语言中的构造方法，但是可以可以很容易实现“构造子工厂”方法，按惯例以“new…”或“New…”开头</li>
<li>通过可见性原则可以将结构体由小写开始，来禁止使用<code>new()</code>函数，强制用户使用工厂方法</li>
</ol>
<h2 id="带标签的结构体">带标签的结构体</h2>
<p>类似注释，在结构体的字段类型后面可以用<code>""</code>进行字段的解释，称为标签(tag)</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type TagType struct &#123; &#x2F;&#x2F; tags
    field1 bool   &quot;An important answer&quot;
    field2 string &quot;The name of the thing&quot;
    field3 int    &quot;How much there are&quot;
&#125;</code></pre>
<h2 id="匿名字段和内嵌结构体">匿名字段和内嵌结构体</h2>
<ol type="1">
<li>可以包含一个或多个匿名字段，这些字段只有<strong>类型</strong>是必须的，匿名字段本身也可以是一个结构体，即内嵌结构体；结构体中每一种数据类型只能有一个匿名字段</li>
<li>匿名字段/内嵌结构体
被用来模拟类似继承的行为，Go语言通过<strong>内嵌或组合</strong>来实现</li>
<li>当只有一个内嵌结构体时，可能看起来像是继承；当有多个内嵌结构体，看起来就会像是组合；实际上当只有一个内嵌结构体时，按组合去理解也会更贴近go的设计</li>
<li>不难得到，类型A内嵌了类型B时，类型B指针无法指向类型A实例（即使类型B是唯一的内嵌类型）</li>
<li>外层结构体可以直接通过选择器符<code>.</code>直接访问内层结构体的字段</li>
<li>两个字段拥有相同名字时：外层名字覆盖内层名字，同一层级的相同名字字段需要明确来自哪一个类型（c.A.a，c.B.a）</li>
</ol>
<h2 id="方法">方法</h2>
<h3 id="方法-1">方法</h3>
<ol type="1">
<li>结构体像是类的简化形式，而方法是在接收者上的函数，接收者可以是某种类型的值，或者是其他允许类型的指针。</li>
<li>接收器不可以是一个接口类型，因为接口是抽象定义。</li>
<li>一个结构体加上它的方法等价于面向对象中的一个类，在Go中结构体和绑定的方法可以不在一起，但是需要在同一个包内</li>
<li>不允许方法重载，可以重载类型</li>
<li>调用方法的方式：<code>recv.Method1()</code>，如果recv可以是类型值，或类型指针（自动解引用）</li>
</ol>
<h3 id="函数方法的区别">函数方法的区别</h3>
<p>函数将变量作为参数：<code>Function1(recv)</code>，方法在变量上被调用：<code>recv.Method1()</code></p>
<h3 id="指针或值作为接收者">指针或值作为接收者</h3>
<ol type="1">
<li>recv常见的是一个指向receiver_type的指针，这样就不会产生结构体的拷贝，而且可以修改结构体的内容</li>
<li>指针方法和值方法都可以在指针或者非指针（值）上被调用，go会自动为你做类型转换</li>
</ol>
<h3 id="方法与未导出字段">方法与未导出字段</h3>
<p>对于未导出的字段，使用<code>getter</code>和<code>setter</code>方法进行修改，在Go中<code>setter</code>方法会使用Set前缀，而<code>getter</code>只使用成员名</p>
<h3 id="内嵌类型的方法和继承">内嵌类型的方法和继承</h3>
<ol type="1">
<li><p>匿名类型被内嵌到结构体中时，匿名类型的可见方法也被内嵌，这相当于实现了继承</p></li>
<li><p>内嵌将一个已存在类型的字段和方法注入到了另一个类型里：匿名字段上的方法“晋升”成为了外层类型的方法。</p></li>
<li><p>外层类型的方法会覆写内嵌类型对应的方法，想要调用内嵌类型的方法，用内嵌类型名进行访问</p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (n *NamedPoint) Abs() float64 &#123;
    return n.Point.Abs() * 100.
&#125;</code></pre></p></li>
</ol>
<h3 id="如何在类型中嵌入功能">如何在类型中嵌入功能</h3>
<ol type="1">
<li><p>聚合（组合）：包含所需功能类型的具体字段；内嵌：使用内嵌类型，把所需的功能类型内嵌</p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 聚合（组合）
type Customer struct &#123;
    Name string
    log  *Log
&#125;
&#x2F;&#x2F; 内嵌
type Customer struct &#123;
    Name string
    Log
&#125;</code></pre></p></li>
</ol>
<h3 id="多重继承">多重继承</h3>
<p>在类型中嵌入必要的父类型就能简单地实现多重继承</p>
<h3 id="与其他面向对象语言的比较">与其他面向对象语言的比较…</h3>
<ol type="1">
<li>go中分离了类型与方法，方法只要定义就可以调用，与其他类型是否存在方法并无关系</li>
<li>go中并不使用类继承的概念，“继承”的两个好处，代码复用通过<strong>组合</strong>和<strong>委托</strong>实现，多态通过<strong>接口</strong>的使用来实现。又是这也叫<strong>组件编程
(Component Programming) <a
href="https://www.notion.so/OOP-0c9b2e9623044a28b70d39fe959e34be">面向对象设计
OOP</a></strong></li>
</ol>
<h2 id="垃圾回收与setfinalizer">垃圾回收与SetFinalizer</h2>
<p>如果需要在一个对象被内存移出前做一些特殊操作，可以通过如下方法调用实现</p>
<h1 id="chapter11">Chapter11</h1>
<h2 id="接口">接口</h2>
<ol type="1">
<li><p>接口定义了一组方法，不包含实现，不包含变量</p></li>
<li><p>可以声明一个接口类型的变量，初始值为nil，本质是一个指针（内部的receiver为类型变量，method
table ptr指向该类型的方法表）</p>
<p><a href="/p/e842888b11eb/Untitled_7.png" class="gallery-item"><img src="/p/e842888b11eb/Untitled_7.png" class="" title="一个接口变量的内容"></a></p></li>
<li><p><strong>如果类型的所有方法组成的集合，包含了该接口的方法集，这个类型就实现了这个接口</strong></p></li>
<li><p>除了接口被<strong>隐式</strong>地实现，其他都与你熟悉的接口差不多</p></li>
<li><p>接口类型的变量可以指向实现了此接口的实例</p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Shaper interface &#123;
    Area() float32
&#125;

type Square struct &#123;
    side float32
&#125;

func (sq *Square) Area() float32 &#123;
    return sq.side * sq.side
&#125;

func main() &#123;
    sq1 :&#x3D; new(Square)
    sq1.side &#x3D; 5

    var areaIntf Shaper
    areaIntf &#x3D; sq1
    &#x2F;&#x2F; shorter,without separate declaration:
    &#x2F;&#x2F; areaIntf :&#x3D; Shaper(sq1)
    &#x2F;&#x2F; or even:
    &#x2F;&#x2F; areaIntf :&#x3D; sq1
    fmt.Printf(&quot;The square has area: %f\n&quot;, areaIntf.Area())
&#125;</code></pre></p></li>
<li><p>实现了同一接口的实例可以填充到同一个数组 / 切片中</p></li>
<li><p>接口是一种契约，实现接口的类型必须满足它，它描述了类型的行为，规定类型可以做什么。接口将类型能做什么，与如何做分离开来，使得变量可以在不同时刻表现出不同行为。</p></li>
</ol>
<h2 id="接口嵌套接口">接口嵌套接口</h2>
<p>一个接口可以包含一个或多个其他接口，相当于将内嵌接口的方法列举在外层接口中</p>
<h2 id="类型断言">类型断言</h2>
<ol type="1">
<li><p>使用类型断言来检测接口varI是否包含类型T的值</p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">if v, ok :&#x3D; varI.(T); ok &#123;  &#x2F;&#x2F; checked type assertion
    Process(v)
    return
&#125;
&#x2F;&#x2F; varI is not of type T
&#x2F;&#x2F; -------
&#x2F;&#x2F; 如果只是想测试一下是否是类型T
if _, ok :&#x3D; varI.(T); ok &#123;
    &#x2F;&#x2F; ...
&#125;</code></pre></p></li>
<li><p>注意如果实现接口的receiver是<code>T</code>类型，那么<code>T</code>和<code>*T</code>的检测都可行（不会有编译报错，是否通过取决于3↓）；如果receiver是<code>*T</code>类型，那么<code>T</code>的检测会有编译报错</p></li>
<li><p><strong>即：使用T指针类型作为receiver，导致：</strong></p>
<ol type="1">
<li>无法进行接口变量的T类型断言</li>
<li>无法将T类型值赋值给接口变量</li>
</ol>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 举例：receiver是*T类型
type Shaper interface &#123;
    Area() float32
&#125;

func (sq *Square) Area() float32 &#123;
    return sq.side * sq.side
&#125;

func main() &#123;
    var areaIntf Shaper
    sq1 :&#x3D; new(Square)
    sq1.side &#x3D; 5

    areaIntf &#x3D; sq1
    &#x2F;&#x2F; Is Square the type of areaIntf?
    if t, ok :&#x3D; areaIntf.(*Square); ok &#123;
        fmt.Printf(&quot;The type of areaIntf is: %T\n&quot;, t)
    &#125;
&#125;</code></pre></p>
<p><a href="/p/e842888b11eb/Untitled_8.png" class="gallery-item"><img src="/p/e842888b11eb/Untitled_8.png" class="" title="实现Shaper接口的是*Square类型，对Square类型断言会有编译报错"></a></p></li>
<li><p>至于<code>T</code>类型还是<code>*T</code>类型的检测会通过，取决于赋值给接口变量的是结构体值还是结构体的指针</p></li>
</ol>
<h2 id="类型判断">类型判断</h2>
<p>接口变量的类型可以用以下特殊形式（在11.3的类型处使用<code>type</code>关键字）的switch语句来进行检测：<code>type-switch</code></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">switch t :&#x3D; areaIntf.(type) &#123; &#x2F;&#x2F; &lt;-
case *Square:
    fmt.Printf(&quot;Type Square %T with value %v\n&quot;, t, t)
case *Circle:
    fmt.Printf(&quot;Type Circle %T with value %v\n&quot;, t, t)
case nil:
    fmt.Printf(&quot;nil value: nothing to check?\n&quot;)
default:
    fmt.Printf(&quot;Unexpected type %T\n&quot;, t)
&#125;</code></pre>
<h2 id="测试是否实现了接口">测试是否实现了接口</h2>
<p>与11.3类似，不同的是将类型替换为接口名，即可检测变量是否实现了特定接口</p>
<h2 id="使用方法集与接口">使用方法集与接口</h2>
<p>在方法一节我们讨论过，当调用变量的方法是，变量是指针还是值都能够正常工作。但是当变量是接口类型时多了一些限制，原因是接口变量中存储的具体值是<strong>不可寻址</strong>的（可以理解为接口变量内存储了一个结构体的值，而非存储了存有结构体地址的指针，但是unsafe.Sizeof打印出来大小都是两个地址的16byte…）：</p>
<p>所以分两种调用方法的情况：（1）将结构体<strong>值</strong>赋值给了接口变量，以及（2）将结构体<strong>指针</strong>赋值给了接口变量。</p>
<p>对于后者，结构体实现的接口方法中，接收者是值以及是指针的方法都能正常调用；但是对于前者，结构体实现的接口方法中，接收者是指针的方法将无法调用</p>
<p><strong>总结</strong></p>
<ul>
<li>指针方法可以通过指针调用</li>
<li>值方法可以通过值调用</li>
<li>接收者是值的方法可以通过指针调用，因为指针会首先被解引用</li>
<li>接收者是指针的方法不可以通过值调用，因为存储在接口中的值没有地址</li>
</ul>
<p><strong>结合11.3 可以得到</strong></p>
<ol type="1">
<li>只要存在一个用类型指针作为接收者的接口方法，就不能用值来给接口变量赋值，从而值类型断言也没有意义了；</li>
<li>反之，如果所有的接口方法都只用值作为接收者实现，就有很大的局限性（方法不能改变结构成员），反而没有意义；虽然可以自由地用值
/
指针给接口变量赋值，但是意义不大；不用担心无法调用接收者是指针的方法，因为不存在这种方法；</li>
<li>所以可以考虑一般情况下：实现接口方法时，接收者是值还是指针从实际出发，并且统一用指针给接口变量赋值，类型断言也用指针类型来判断；虽然无法用值给接口变量赋值，少一种选择反而少一些负担，不用担心无法调用接收者是指针的方法，因为不会用值来给接口变量赋值、也让类型断言变简单，只要考虑接口的指针类型断言就可以了</li>
</ol>
<p>*实际上是类型A实现了接口还是指针类型A实现了接口本身就是两种情况，不要混为一谈会更好理解。方法调用时不区分值还是指针可以看作是语法糖，而此处指针赋值的接口变量，可以调用接收者是值得方法也是做了额外处理。</p>
<h2 id="空接口">空接口</h2>
<p>一个空接口对实现不做任何要求</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type Any interface &#123;&#125; &#x2F;&#x2F; 对于函数参数 interface &#123;&#125; 也是可行的
var val interface &#123;&#125; &#x2F;&#x2F; 空接口类型</code></pre>
<ol type="1">
<li><p>空接口类似 <code>Java/C#</code>中所有类的基类： <code>Object</code>类，二者的目标也很相近，可以给一个空接口类型变量赋任何类型的值</p></li>
<li><p>使用空接口来实现类似泛型的功能，将一个空接口类型作为Element</p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Vector struct &#123;
    a []Element
&#125;

func (p *Vector) At(i int) Element &#123;
    return p.a[i]
&#125;

func (p *Vector) Set(i int, e Element) &#123;
    p.a[i] &#x3D; e
&#125;</code></pre></p></li>
<li><p>不能将特定类型的切片直接赋值给空接口切片，因为他们的内存布局不一致，需要for-range来一个一个显式赋值</p></li>
<li><p>一个接口的值可以赋值给另一个接口变量，只要底层类型实现了必要的方法，注意这个转换在<strong>运行时</strong>检查，转换失败将导致一个<strong>运行时错误</strong></p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type myPrintInterface interface &#123;
    print()
&#125;

func f3(x myInterface) &#123;
    x.(myPrintInterface).print() &#x2F;&#x2F; type assertion to myPrintInterface
&#125;</code></pre></p></li>
</ol>
<h2 id="反射">反射</h2>
<ol type="1">
<li>使用reflect包来进行反射</li>
<li><code>reflect.TypeOf</code>和<code>reflect.ValueOf</code>用于返回被检查对象的类型和值，他们的参数类型都是interface{}</li>
<li><code>reflect.ValueOf</code>返回的reflect.Value类型对象存在<code>Type()</code>返回类型，<code>Kind()</code>返回一个常量来表示类型，同样当你确定了reflect.Value的确切类型，有叫做Int()，Float()的方法来获取存储值，或者直接用<code>Interface</code>来获取空接口类型值</li>
<li>通过反射来修改值时，可以通过对Value的CanSet方法来检查是否可设置，如果想要Value对象可设置，有时需要用指针来调用<code>ValueOf</code>，并且需要使用<code>Elem()</code>函数</li>
<li>使用<code>Field(index int)</code>来获取结构体的成员，并且通过<code>SetInt</code>，<code>SetString</code>等接口设置值</li>
<li>使用<code>NumField</code>来获取结构体有多少个成员</li>
<li>使用<code>Method(index int)</code>来获取结构体的方法，并且使用<code>Call()</code>进行调用</li>
</ol>
<h2 id="接口与动态类型">接口与动态类型</h2>
<ol type="1">
<li><p>Go中没有类，数据（结构体或是一般类型）与方法是一种松耦合的正交关系</p></li>
<li><p>Go中的接口都是必须提供一个方法集的实现，但是更灵活，都是隐式实现而不用显式声明，类型和接口之间也是松耦合的</p></li>
<li><p>使用接口类型作为参数的函数，类似于动态类型，更看重对象能做什么，而不是对象是什么</p></li>
<li><p>Go的动态方法调用，需要编译器静态检查的支持，变量赋值给接口类型变量时，编译器会检查类型是否实现了接口所有的函数。一般传入像<code>interface&#123;&#125;</code>这样的泛型变量，之后再用类型断言来进行变量的检查。</p></li>
<li><p>接口的继承：当类型内嵌另一个实现了接口的类型指针时，该类型就可以使用另一个类型的所有接口方法，通过组合的方式实现了继承</p>
<p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Task struct &#123;
    Command string
    *log.Logger &#x2F;&#x2F; log.Logger实现了Log()方法
&#125;

task.Log() &#x2F;&#x2F; Task类型的实例调用Logger的Log()方法</code></pre></p></li>
</ol>
<h2 id="go中的面向对象总结">Go中的面向对象总结</h2>
<p>面向对象中的重要概念：封装、继承、多态</p>
<p>（之前读到的内容说继承是实现多态的一种方式 <a
href="https://www.notion.so/OOP-0c9b2e9623044a28b70d39fe959e34be">面向对象设计
OOP</a>
…不过这里就先不把问题复杂化了，先看Go语言如何实现面向对象的重要概念）</p>
<p><strong>封装</strong>：简化的访问层级，首字母小写的标识符包内可见，首字母大写的标识符包外可见</p>
<p><strong>继承</strong>：用内嵌类型这样“组合”的方式来实现</p>
<p><strong>多态</strong>：用接口来实现，实现了接口规定方法集的类型实例，可以赋给接口类型变量</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script src="/js/lg-thumbnail.min.js"></script><script src="/js/lg-zoom.min.js"></script><script src="/js/lg-fullscreen.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>《The Way to Go》Chapter16 常见陷阱与错误</title>
    <url>/p/c629bb3de01f/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="chapter16-常见陷阱与错误">Chapter16 常见陷阱与错误</h1>
<p>前15章提及了一些错误使用方式，就不再赘述，<a
href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/16.0.md">https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/16.0.md</a>
中也都列出了，重要的是有以下最佳实践：</p>
<ol type="1">
<li>使用正确的方式初始化值是切片slice的一个映射map</li>
<li>使用逗号ok模式进行类型断言</li>
<li>使用一个工厂函数创建并实例化自己的定义的类型</li>
<li>只有当想要改变结构体时，使用结构体指针作为方法接收者，否则都使用结构体值类型</li>
</ol>
<span id="more"></span>
<h3 id="误用短声明导致变量覆盖">误用短声明导致变量覆盖</h3>
<p>如果在语句块内使用了短声明<code>:=</code>，那么语句块内的同名变量仅在语句块内有效，退出语句块后仍然是外部的变量生效</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var remember bool &#x3D; false
if something &#123;
    remember :&#x3D; true &#x2F;&#x2F;错误
&#125;
&#x2F;&#x2F; 使用remember，得到的仍然是false

&#x2F;&#x2F; ------
&#x2F;&#x2F; 正确做法
if something &#123;
    remember &#x3D; true
&#125;</code></pre>
<h3 id="误用字符串">误用字符串</h3>
<p>字符串是不可变的，使用 <code>a+=b</code>
会导致大量内存开销和拷贝，考虑使用字符数组代替字符串，将字符串内容写入到缓存中，即
<code>bytes.Buffer</code></p>
<h3 id="错误地使用defer">错误地使用defer</h3>
<p><code>defer</code>仅在函数返回时执行，在循环的结尾或者有限范围的代码内不会执行</p>
<h3 id="何时使用new和make">何时使用new()和make()</h3>
<p>重复内容：</p>
<ol type="1">
<li>对切片slice、映射map、通道channel使用make()</li>
<li>对数组、结构体和值类型，使用new()</li>
</ol>
<h3
id="不要对接口使用指针类型减少对值类型使用指针">不要对接口使用指针类型，减少对值类型使用指针</h3>
<p>如使用接口的指针类型函数参数，这会导致编译错误 →
接口本身已是一个指针</p>
<p>尽管值类型的拷贝似乎是对内存的滥用，但值类型内存的栈上分配快速且开销小；如果传递值类型的指针会导致对象的创建，且移动到了堆上。</p>
<h3 id="闭包与协程的使用">闭包与协程的使用</h3>
<p>注意在循环中对索引值（index）使用闭包时，可能指向的是同一个变量，在闭包逻辑执行时，可能循环已经结束，得到的都是索引的最终值；可选的方法是创建局部变量（值复制），让闭包指向这些变量，或者用这些值启动协程</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">var values &#x3D; [5]int&#123;10, 11, 12, 13, 14&#125;
func main() &#123;
        &#x2F;&#x2F; ...
    &#x2F;&#x2F; 版本 B：和 A 版本类似，但是通过调用闭包作为一个协程
    for ix :&#x3D; range values &#123;
        go func() &#123;
            fmt.Print(ix, &quot; &quot;)
        &#125;()
    &#125;
    fmt.Println()
    time.Sleep(5e9)
        &#x2F;&#x2F; 4 4 4 4 4
    &#x2F;&#x2F; 版本 C：正确的处理方式
    for ix :&#x3D; range values &#123;
        go func(ix interface&#123;&#125;) &#123;
            fmt.Print(ix, &quot; &quot;)
        &#125;(ix)
    &#125;
    fmt.Println()
    time.Sleep(5e9)
        &#x2F;&#x2F; 1 0 3 4 2
&#125;
</code></pre>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script src="/js/lg-thumbnail.min.js"></script><script src="/js/lg-zoom.min.js"></script><script src="/js/lg-fullscreen.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>unity中的原生对象与托管对象</title>
    <url>/p/27ad02cebc90/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="序">序</h2>
<p>最初在工作中接触到引擎原生层相关的问题，是项目实现的延时执行模块，模块提供接口来进行委托的延时调用：</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 返回一个token用于后续的CancelDelayCall
m_DelayExecuteGuidance &#x3D; GameFacade.CurrentGame.DelayCall(8.0f, OnPlayerGuideFinished);

&#x2F;&#x2F; 延时执行的代码示例
private void OnPlayerGuideFinished()
&#123;
    &#x2F;&#x2F; 作为MonoBehaviour的成员方法，访问gameObject
    Debug.Log(gameObject.name);
    &#x2F;&#x2F; something else...
&#125;</code></pre>
<p>延时执行模块与协程不同，不会因为gameObject的销毁而取消执行，假设在指定的8s后，组件绑定的gameObject已经销毁，那么试图在访问时就会产生这样的报错：</p>
<a href="/p/27ad02cebc90/image-20211221124140635.png" class="gallery-item"><img src="/p/27ad02cebc90/image-20211221124140635.png" class="" title="Unity console窗口内报错日志"></a>
<p>可以看到延时模块仍然保留了对MonoBehaviour的引用，但在试图通过property访问gameObejct的时候发生了报错，且提示代码位置为“managed-to-native”，体现了本文的主体：引擎的托管（managed）代码对原生（native）代码的访问，下面我们就集中介绍Unity引擎中的原生对象与托管对象。</p>
<span id="more"></span>
<h2 id="原生对象与托管对象">原生对象与托管对象</h2>
<p>Unity作为C++实现的游戏引擎，在运行时大部分的逻辑和内存管理都是在原生层（C++
code）进行，这里就将引擎在原生层创建的对象称为原生对象（native
object），基于引擎的游戏逻辑中创建的对象成为托管对象（managed
object）。当Unity创建一个Object的时候，存在着核心的原生层面的逻辑，另一部分则是更为常用的托管层面的C#逻辑，下面就先从Unity引擎中的Object说起。</p>
<hr />
<h2 id="understanding-unity-engine-objects">Understanding Unity Engine
Objects</h2>
<blockquote>
<p>节选翻译自
https://blog.eyas.sh/2020/10/unity-for-engineers-pt5-object-component/</p>
</blockquote>
<p>Unity引擎运行时使用C++实现，大多数引擎的要素（gameObject以及component等等）都处于C++侧。你也许也知道Unity引擎的API是以C#形式提供的。这些API为你提供了对Unity原生对象的访问，以至于这些对象用起来就像是C#对象一样亲切易懂。</p>
<a href="/p/27ad02cebc90/object-hierarchy.svg" class="gallery-item"><img src="/p/27ad02cebc90/object-hierarchy.svg" class="" title="A GameObject, MonoBehaviour, and ScriptableObject all inherit from UnityEngine Object"></a>
<h3 id="unityengine.object">UnityEngine.Object</h3>
<p>在继承链的顶端的是<code>UnityEngine.Object</code>。大多数情况下都提供<code>name</code>字符串，<code>GetInstanceID()</code>接口，以及一系列比较器（equality
comparers）。</p>
<p>这个类同时提供了静态方法 <code>static void Destroy(Object obj)</code>
来销毁一个 <code>UnityEngine.Object</code>
以及它的一切子类。当一个Object被销毁时，这个对象的原生层部分已被从内存中释放，而相对小的托管层部分将会在它没有被引用时被垃圾回收。</p>
<p>因为你在托管层对<code>UnityEngine.Object</code>的引用可能指向一个已经被销毁的原生层对象，所以<code>UnityEngine.Object</code>重写了C#的<code>operator==</code>以及<code>operator!=</code>让一个已被销毁的Object能够表现为null。所以对已在原生层被销毁的Object进行null判定会返回true，或者直接引发<code>NullRefrenceException</code>，来告诉你该对象已经被销毁。</p>
<p>可以在C#侧看到Object实现中，若与null进行比较，会调用<code>IsNativeObjectAlive</code>进行判定。</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; UnityEngine.Object.CompareBaseObjects
private static bool CompareBaseObjects(Object lhs, Object rhs)
&#123;
  bool flag1 &#x3D; (object) lhs &#x3D;&#x3D; null;
  bool flag2 &#x3D; (object) rhs &#x3D;&#x3D; null;
  if (flag2 &amp;&amp; flag1)
    return true;
  if (flag2)
    return !Object.IsNativeObjectAlive(lhs);
  return flag1 ? !Object.IsNativeObjectAlive(rhs) : lhs.m_InstanceID &#x3D;&#x3D; rhs.m_InstanceID;
&#125;</code></pre>
<h4 id="进行一下回顾非原文内容">进行一下回顾（非原文内容）</h4>
<p>在文章开始时我们给出了例子<code>GameFacade.CurrentGame.DelayCall</code>，现在我们在延时执行的代码中加上这些判断语句，并记录关键日志：</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">private void OnPlayerGuideFinished()
&#123;
    Debugger.Log(&quot;[UINewAutoPickUpSettingController.OnPlayerGuideFinished]&quot;);
    if (this &#x3D;&#x3D; null)
    &#123;
        Debugger.Log(&quot;[UINewAutoPickUpSettingController.OnPlayerGuideFinished] this is null&quot;);
    &#125;

    var mono &#x3D; this as MonoBehaviour;
    if (mono &#x3D;&#x3D; null)
    &#123;
        Debugger.Log(&quot;[UINewAutoPickUpSettingController.OnPlayerGuideFinished] mono is null&quot;);
    &#125;

    if (m_View.GuideCoverBtn &#x3D;&#x3D; null)
    &#123;
        Debugger.Log(&quot;[UINewAutoPickUpSettingController.OnPlayerGuideFinished] m_View.GuideCoverBtn is null&quot;);
    &#125;

    if (m_View.GuideCoverBtn.gameObject &#x3D;&#x3D; null)
    &#123;
        Debugger.Log(&quot;[UINewAutoPickUpSettingController.OnPlayerGuideFinished] m_View.GuideCoverBtn.gameObject is null&quot;);
    &#125;

    m_View.GuideCoverBtn.gameObject.SetActive(false);
&#125;</code></pre>
<p>运行测试时，我们会发现这些尽管托管层仍持有这些MonoBehaviour的引用，但这些引用已经全部被判定为null，这是由于我们销毁gameObject时，原生层对应的对象已经被从内存中销毁，对应内内存空间被释放，所以尽管托管层的<code>Object</code>对象还没有被垃圾回收，对象仍然可以被访问，但对自身的null判定会全部为true。</p>
<p>同时我们也要注意到null判定为true是因为<code>operator==</code>的重写，但是仍然指向一个托管层的<code>Object</code>对象，这个对象的成员（如m_View，是一个纯C#侧对象）仍然是可以被访问的，只在最终访问到原生层对象，或者试图获取原生层对象时报错。</p>
<a href="/p/27ad02cebc90/image-20211221143715637.png" class="gallery-item"><img src="/p/27ad02cebc90/image-20211221143715637.png" class="" title="image-20211221143715637"></a>
<p>上图为运行日志结果，报错的为<code>UnityEngine.Component</code>中的<code>getter</code>方法：</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;&#x2F; &lt;summary&gt;
&#x2F;&#x2F;&#x2F;   &lt;para&gt;The game object this component is attached to. A component is always attached to a game object.&lt;&#x2F;para&gt;
&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;
&#x2F;&#x2F;&#x2F; &lt;footer&gt;&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;docs.unity3d.com&#x2F;2018.4&#x2F;Documentation&#x2F;ScriptReference&#x2F;30_search.html?q&#x3D;Component-gameObject&quot;&gt;&#96;Component.gameObject&#96; on docs.unity3d.com&lt;&#x2F;a&gt;&lt;&#x2F;footer&gt;
public extern GameObject gameObject &#123; [FreeFunction(&quot;GetGameObject&quot;, HasExplicitThis &#x3D; true), MethodImpl(MethodImplOptions.InternalCall)] get; &#125;</code></pre>
<p>可以看到这里就是在试图获取原生层gameObject时抛出了错误</p>
<h3 id="gameobject-component">GameObject &amp; Component</h3>
<h4 id="gameobject">GameObject</h4>
<blockquote>
<p>此部分内容进行省略，可跳转到原文查看完整内容</p>
</blockquote>
<p><code>GameObject</code>从<code>Object</code>继承而来，用以代表你场景中的一切对象。一个GameObject持有一个Component的列表，且至少拥有一个Component，即Transform，用以描述GameObject的空间信息，如position和rotation等。</p>
<h4 id="component">Component</h4>
<blockquote>
<p>此部分内容进行省略，可跳转到原文查看完整内容</p>
<p>Unity通过Component对象的组合来定义gameObject的行为表现，这是被游戏引擎（游戏开发者）成为Entity
Component System的核心描述/信条...
容易混淆的是Unity也将他们推出的次世代高性能游戏编程范式（paradigm）成为ECS，即不仅引擎逻辑，游戏逻辑也使用ECS来实现，从而成为一种数据驱动的设计。</p>
</blockquote>
<p>GameObject的行为通过Component的组合来驱动，用户实现的组件通常需要继承类<code>MonoBehaviour</code>。对于Component来说：</p>
<ol type="1">
<li>必须归属于一个GameObject，通过属性<code>gameObject</code>进行访问</li>
<li>可以接收到<strong>messages</strong>，用于驱动自身的特殊行为（即事件方法）</li>
</ol>
<p>Component最重要的功能由Unity Messages驱动（也称为Unity Event
Functions），这些都是引擎在特定时间下触发的callback方法，详情可以参考官方文档。</p>
<p>若你需要在特定时机执行一些逻辑，添加这些message的同名方法即可，引擎运行时（runtime）会使用反射来进行方法调用，这就是为什么你在这些方法上看不到<code>override</code>关键字。每个Component类型的<code>Update</code>，<code>LateUpdate</code>，<code>FixedUpdate</code>这些消息都只会被反射获取一次，所以不用担心反射在每个游戏帧都被执行（有关内容可以参阅
https://blog.unity.com/technology/1k-update-calls）。</p>
<p><code>Behaviour</code>是可以被设置enabled / disabled
状态的Component，在disable的状态下，一些事件方法将不会执行。而<code>MonoBehaviour</code>是可以使用协程（受Unity
Engine管理）的Behaviour。</p>
<p>开发的时候遇到一个问题，为什么unity项目中的C#代码会提示无法去new一个component呢（new
GameObject却是可行的）。原因是component是需要依赖gameObject存在的，需要gameObject驱动各种生命周期。而C#的new行为并不能在创建component指派component依附的对象，这就导致一些功能不能正常作用。参考了unity论坛此回答：https://answers.unity.com/questions/653904/you-are-trying-to-create-a-monobehaviour-using-the-2.html</p>
<h3 id="要点">要点</h3>
<ol type="1">
<li>Unity
object在原生层销毁后表现为null，<code>== null</code>判定可能做了一些你料想之外的工作</li>
<li>因此，其他的null运算符（如?.）可能不起作用</li>
<li>Unity Messages 可以是私有的！</li>
<li>如果没有必要的话，不要声明<code>Update</code>这样的方法用于override等，这会让引擎多调用一些额外的方法</li>
<li>对无用的Object或者Component进行disable是限制游戏逻辑或节省CPU开销的一种方式，但这些对象仍然会占用内存</li>
</ol>
<hr />
<h2 id="原生对象与托管对象的引擎管理">原生对象与托管对象的引擎管理</h2>
<p>原计划是搬运一下参考文章3中，结果粗略看下来参考3更多是说一些序列化 /
反序列化在Editor /
AssetBundle中的应用以及实现原理，而没有太多涉及游戏运行时的内容，后续深入学习的时候再补充了</p>
<h2 id="参考文章">参考文章</h2>
<ol type="1">
<li><a href="https://blog.eyas.sh/2020/10/unity-for-engineers-pt5-object-component/" title="" target="">Understanding Unity Engine Objects</a></li>
<li><a href="https://blog.unity.com/technology/1k-update-calls" title="文章1中的推荐阅读" target="">unity blog: 10000 Update() calls</a></li>
<li><a href="https://developer.unity.cn/projects/6152e4fbedbc2a0020584027" title="" target="">揭秘Unity的黑盒世界，原生对象和托管对象浅谈</a></li>
</ol>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script src="/js/lg-thumbnail.min.js"></script><script src="/js/lg-zoom.min.js"></script><script src="/js/lg-fullscreen.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>]]></content>
      <categories>
        <category>游戏开发</category>
        <category>引擎实现原理</category>
      </categories>
      <tags>
        <tag>游戏开发</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
</search>
